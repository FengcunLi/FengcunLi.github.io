<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="基本的线程管理启动线程123void do_some_work();std::thread my_thread(do_some_work); 1234567891011121314151617181920212223242526#include &amp;lt;thread&amp;gt;class background_task &amp;#123;   public:    void operator()() con">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Concurrency in Action">
<meta property="og:url" content="http://yoursite.com/2021/03/07/C-Concurrency-In-Action/index.html">
<meta property="og:site_name" content="The next stop - Antarctica">
<meta property="og:description" content="基本的线程管理启动线程123void do_some_work();std::thread my_thread(do_some_work); 1234567891011121314151617181920212223242526#include &amp;lt;thread&amp;gt;class background_task &amp;#123;   public:    void operator()() con">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2021-03-28T08:09:25.868Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ Concurrency in Action">
<meta name="twitter:description" content="基本的线程管理启动线程123void do_some_work();std::thread my_thread(do_some_work); 1234567891011121314151617181920212223242526#include &amp;lt;thread&amp;gt;class background_task &amp;#123;   public:    void operator()() con">

<link rel="canonical" href="http://yoursite.com/2021/03/07/C-Concurrency-In-Action/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++ Concurrency in Action | The next stop - Antarctica</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">The next stop - Antarctica</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">To see behind walls. To draw closer.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/07/C-Concurrency-In-Action/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fengcun Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The next stop - Antarctica">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ Concurrency in Action
        </h1>

        <div class="post-meta">
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-28 16:09:25" itemprop="dateModified" datetime="2021-03-28T16:09:25+08:00">2021-03-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="基本的线程管理"><a href="#基本的线程管理" class="headerlink" title="基本的线程管理"></a>基本的线程管理</h2><h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_some_work</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">(do_some_work)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">background_task</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do_something();</span></span><br><span class="line">        <span class="comment">// do_something_else();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// warning: parentheses were disambiguated as a function declaration</span></span><br><span class="line">    <span class="comment">// note: add a pair of parentheses to declare a variable</span></span><br><span class="line">    <span class="comment">// std::thread my_thread(background_task());</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">((background_task()))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象 my_thread 析构前，没有 join 或者 detach</span></span><br><span class="line">    <span class="comment">// libc++abi.dylib: terminating</span></span><br><span class="line">    <span class="comment">// [1]    66998 abort      ./concurrency</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象 my_thread 析构前，join 或者 detach 之后，就没有问题了。</span></span><br><span class="line">    <span class="comment">// my_thread.join();</span></span><br><span class="line">    <span class="comment">// my_thread.detach();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="C-’s-most-vexing-parse"><a href="#C-’s-most-vexing-parse" class="headerlink" title="C++’s most vexing parse"></a>C++’s most vexing parse</h3><p><code>std::thread my_thread(background_task());</code> 会被视为函数声明，而不是对象的定义。<br>可以通过两种方式进行避免</p>
<ol>
<li><code>std::thread my_thread((background_task()))</code></li>
<li><code>std::thread my_thread{background_task()}</code> uniform initialization syntax</li>
</ol>
<p>一旦启动一个线程，必须<strong>显式地指定</strong><code>join</code>还是<code>detach</code>：</p>
<ul>
<li>wait for it (by joining with it)</li>
<li>leave it to run on its own (by detaching it)。</li>
</ul>
<p>如果在 <code>std::thread</code> 对象被析构前，没有进行任何指定，则程序会被终止(<code>std::thread</code> 析构函数会调用 <code>std::terminate()</code>)。<br>需要注意的是，仅仅需要在 <code>std::thread</code> 对象被析构之前完成指定即可，在指定 <code>join</code> 或者 <code>detach</code> 之时，线程本身可能已经结束。<br>如果你决定 detach it，线程可能在 <code>std::thread</code> 对象析构之后仍然继续运行很长时间。</p>
<h3 id="确保线程访问的数据的有效性"><a href="#确保线程访问的数据的有效性" class="headerlink" title="确保线程访问的数据的有效性"></a>确保线程访问的数据的有效性</h3><blockquote>
<p>If you don’t wait for your thread to finish, then you need to ensure that the data accessed by the thread is valid until the thread has finished with it.</p>
</blockquote>
<p>如果线程持有指向局部变量的指针或者引用，并且在函数退出时线程仍未结束，就会出现问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>&amp; i;</span><br><span class="line">    func(<span class="keyword">int</span>&amp; i_) : i(i_) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">1000000</span>; ++j) &#123;</span><br><span class="line">            do_something(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    my_thread.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="等待线程结束"><a href="#等待线程结束" class="headerlink" title="等待线程结束"></a>等待线程结束</h3><blockquote>
<p>In real code the original thread would either have work to do itself or it would have launched several threads to do useful work before waiting for all of them to complete.</p>
</blockquote>
<p><code>join</code> 是一个简单粗暴的方式。</p>
<blockquote>
<p>If you need more fine-grained control over waiting for a thread, such as to check whether a thread is finished, or to wait only a certain period of time, then you have to use alternative mechanisms such as condition variables and futures.</p>
</blockquote>
<blockquote>
<p>The act of calling <code>join()</code> also cleans up any storage associated with the thread, so the <code>std::thread</code> object is no longer associated with the now-finished thread; it isn’t associated with any thread. This means that you can call <code>join()</code> only once for a given <code>std::thread</code> object; once you’ve called <code>join()</code>, the <code>std::thread</code> object is no longer joinable, and <code>joinable()</code> will return false.</p>
</blockquote>
<p>只能在 <code>std::thread</code> object 上 <code>join</code> 一次，一旦 <code>join</code> 了，<code>std::thread</code> object 就废弃了，不存在和任何线程的绑定关系了。</p>
<h3 id="在异常发生时等待线程结束"><a href="#在异常发生时等待线程结束" class="headerlink" title="在异常发生时等待线程结束"></a>在异常发生时等待线程结束</h3><p>需要在代码中选择合适的地方对线程进行 join，如果异常发生在线程启动之后、<code>join</code> 之前，<code>join</code> 的调用则有可能会被跳过，这样的话应用就会被 terminated。</p>
<h4 id="Try-catch"><a href="#Try-catch" class="headerlink" title="Try/catch"></a>Try/catch</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>&amp; i;</span><br><span class="line">    func(<span class="keyword">int</span>&amp; i_) : i(i_) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> j = <span class="number">0</span>; j &lt; <span class="number">1000000</span>; ++j) &#123;</span><br><span class="line">            do_something(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f__</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="comment">// 如果 do_something_in_current_thread 抛出异常，下一行的 my_thread.join(); 不会被执行，</span></span><br><span class="line">    <span class="comment">// 会发生栈回退，my_thread 的析构函数会被调用，由于没有 join，其析构函数调用的 terminate 会杀掉整个应用，</span></span><br><span class="line">    <span class="comment">// 传递性抛出去的异常也不会有机会被捕获处理了，整个应用都退出了。</span></span><br><span class="line">    do_something_in_current_thread();</span><br><span class="line">    my_thread.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        do_something_in_current_thread();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        my_thread.join();</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    my_thread.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h4><blockquote>
<p><strong>Resource Acquisition Is Initialization</strong>，用于解决<strong>资源管理</strong>的<strong>异常安全性</strong>。<br>RAII 要求，<strong>资源的有效期</strong>与<strong>持有资源的对象的生命期</strong>严格绑定，即由对象的构造函数完成资源的获取，由析构函数完成资源的释放，在这种要求下，只要对象能够被正确地析构，就不会出现资源泄露问题。C++ 保证了所有<strong>栈对象</strong>在生命期结束时都会被析构，无论是否发生了异常。</p>
</blockquote>
<p>使用 RAII 来解决<strong>资源管理</strong>的<strong>异常安全性</strong>，此处的资源就是线程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thread_guard</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::thread&amp; t;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 禁用隐式类型转换</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(<span class="built_in">std</span>::thread&amp; t_)</span> : <span class="title">t</span><span class="params">(t_)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用拷贝构造函数</span></span><br><span class="line">    thread_guard(<span class="keyword">const</span> thread_guard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">// 禁用拷贝赋值运算符</span></span><br><span class="line">    thread_guard&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> thread_guard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~thread_guard() &#123;</span><br><span class="line">        <span class="keyword">if</span> (t.joinable()) &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> some_local_state = <span class="number">0</span>;</span><br><span class="line">    <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">my_thread</span><span class="params">(my_func)</span></span>;</span><br><span class="line">    <span class="function">thread_guard <span class="title">guard</span><span class="params">(my_thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    do_something_in_current_thread();</span><br><span class="line">    <span class="comment">// 无论函数是 normal 或者 exceptional 退出，都会对线程进行 join。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>When the execution of the current thread reaches the end of <code>f</code> , the local objects are destroyed in reverse order of construction. Consequently, the <code>thread_guard</code> object guard is destroyed first, and the thread is joined within the destructor. 确保 <code>std::thread</code> 对象析构之前被 join。</p>
</blockquote>
<blockquote>
<p>If you don’t need to wait for a thread to finish, you can avoid this exception-safety issue by detaching it. This breaks the association of the thread with the <code>std::thread</code> object and ensures that <code>std::terminate()</code> won’t be called when the <code>std::thread</code> object is destroyed, even though the thread is still running in the background.</p>
</blockquote>
<h3 id="在后台运行线程"><a href="#在后台运行线程" class="headerlink" title="在后台运行线程"></a>在后台运行线程</h3><p>Detached 线程是在后台运行的，ownership 和 control 会被传递给 C++ Runtime Library，它会确保在线程退出时与该线程相关联的资源得到正确释放。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit_document</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; filename)</span> </span>&#123;</span><br><span class="line">    open_document_and_display_gui(filename);</span><br><span class="line">    <span class="keyword">while</span> (!done_editing()) &#123;</span><br><span class="line">        user_command cmd = get_user_input();</span><br><span class="line">        <span class="keyword">if</span> (cmd.type == open_new_document) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span> new_name = get_filename_from_user();</span><br><span class="line">            <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(edit_document, new_name)</span></span>;</span><br><span class="line">            t.detach();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            process_user_input(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="向线程函数传递参数"><a href="#向线程函数传递参数" class="headerlink" title="向线程函数传递参数"></a>向线程函数传递参数</h3><p>默认情况下，参数是被拷贝进线程内部存储 (internal storage) 的（即使<strong>线程函数</strong>的参数期望是一个引用）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Int</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    Int(<span class="keyword">int</span> val) : data&#123;val&#125; &#123;&#125;;</span><br><span class="line">    Int(<span class="keyword">const</span> Int&amp; i) : data&#123;i.data&#125; &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">": 拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ~Int() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">": 析构函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> Int&amp; input)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"In func: "</span> &lt;&lt; &amp;input &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="function">Int <span class="title">myInt</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;myInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">thread <span class="title">myThread</span><span class="params">(func, myInt)</span></span>;</span><br><span class="line"></span><br><span class="line">    myThread.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0x7ffeeb203338</span></span><br><span class="line"><span class="comment">// 0x7ffeeb203288: 拷贝构造函数</span></span><br><span class="line"><span class="comment">// 0x7f9b2b405a10: 拷贝构造函数</span></span><br><span class="line"><span class="comment">// 0x7ffeeb203288: 析构函数</span></span><br><span class="line"><span class="comment">// In func: 0x7f9b2b405a10</span></span><br><span class="line"><span class="comment">// 0x7f9b2b405a10: 析构函数</span></span><br><span class="line"><span class="comment">// 0x7ffeeb203338: 析构函数</span></span><br></pre></td></tr></table></figure>
<p>This is particularly important when the argument supplied is a pointer to an automatic variable, as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops</span><span class="params">(<span class="keyword">int</span> some_param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">"%i"</span>, some_param);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(f, <span class="number">3</span>, buffer)</span></span>;</span><br><span class="line">    t.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>In this case, it’s the pointer to the local variable <code>buffer</code> that’s passed through to the new thread, and there’s a significant chance that the function <code>oops</code> will exit before the <code>buffer</code> has been converted to a <code>std::string</code> on the new thread, thus leading to undefined behavior.</p>
</blockquote>
<p>这里的 dangling pointer 问题在于依赖了 <code>char *</code> 到 <code>std::string</code> 的隐式类型转换，而这个隐式类型转换是发生在新线程中的 <code>f(3, buffer)</code> 处。</p>
<p>The solution is to cast to <code>std::string</code> before passing the buffer to the <code>std::thread</code> constructor:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">not_oops</span><span class="params">(<span class="keyword">int</span> some_param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(buffer, <span class="string">"%i"</span>, some_param);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(f, <span class="number">3</span>, <span class="built_in">std</span>::<span class="built_in">string</span>(buffer))</span></span>;</span><br><span class="line">    t.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>The <code>std::thread</code> constructor copies the supplied values as is, without converting to the expected argument type.</strong><br>考虑下面的问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_data_for_widget</span><span class="params">(widget_id w, widget_data&amp; data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops_again</span><span class="params">(widget_id w)</span> </span>&#123;</span><br><span class="line">    widget_data data;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(update_data_for_widget, w, data)</span></span>;</span><br><span class="line">    display_status();</span><br><span class="line">    t.join();</span><br><span class="line">    process_widget_data(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Although <code>update_data_for_widget</code> expects the second parameter to be passed by reference, the <code>std::thread</code> constructor doesn’t know that; it’s oblivious to the types of the arguments expected by the function and blindly copies the supplied values.</p>
<p>When <strong>the new thread</strong> calls <code>update_data_for_widget</code>, it will end up passing a reference to <strong>its</strong> internal copy of data and not a reference to data itself. Consequently, when the thread finishes, these updates will be discarded as the internal copies of the supplied arguments are destroyed, and <code>process_widget_data</code> will be passed an unchanged data rather than a correctly updated version.</p>
<p>The solution is:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(update_data_for_widget, w, <span class="built_in">std</span>::ref(data))</span></span>;</span><br></pre></td></tr></table></figure>
<p>Both the operation of the <code>std::thread</code> constructor and the operation of <code>std::bind</code> are defined in terms of the same mechanism. This means that, for example, you can pass a member function pointer as the function, provided you supply a suitable object pointer as the first argument:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_lengthy_work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">X my_x;</span><br><span class="line"><span class="built_in">std</span>::thread(&amp;X::do_lengthy_work, &amp;my_x);</span><br></pre></td></tr></table></figure>
<h4 id="当参数-not-copyable-but-movable"><a href="#当参数-not-copyable-but-movable" class="headerlink" title="当参数 not copyable but movable"></a>当参数 not copyable but movable</h4><blockquote>
<p>moved: The data held within one object is transferred over to another, leaving the original object “empty”. 内部数据被转移走了，留下了一个空壳。</p>
</blockquote>
<p>An example of such a type is <code>std::unique_ptr</code>, which provides automatic memory management for dynamically allocated objects. Only one <code>std::unique_ptr</code> instance can point to a given object at a time, and when that instance is destroyed, the pointed-to object is deleted. The move constructor and move assignment operator allow the ownership of an object to be transferred around between <code>std::unique_ptr</code> instances.</p>
<div class="note info">
            <p><strong>被管理的资源的持有权在 <code>std::unique_ptr</code> 实例之间流转。</strong></p>
          </div>
<p>Such a transfer leaves the source object with a NULL pointer. This moving of values allows objects of this type to be accepted as function parameters or returned from functions.</p>
<p>在 <code>std::unique_ptr</code> 中 move 的应用倒不是主要出于效率的考虑，而是出于 unique 的考虑。</p>
<p>Where the source object is a temporary, the move is automatic, but where the source is a named value, the transfer must be requested directly by invoking <code>std::move()</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_big_object</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;big_object&gt;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;big_object&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> big_object)</span></span>;</span><br><span class="line">p-&gt;prepare_data(<span class="number">42</span>);</span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(process_big_object, <span class="built_in">std</span>::move(p))</span></span>;</span><br></pre></td></tr></table></figure>
<p>By specifying <code>std::move(p)</code> in the <code>std::thread</code> constructor, the ownership of the big_object（被管理的资源的持有权）<code>is **transferred</code>first into internal storage for the newly created thread (否则的话默认就是拷**贝了，而不是 move) and then into <code>process_big_object</code>.</p>
<p>Several of the classes in the Standard Thread Library exhibit the same ownership semantics as <code>std::unique_ptr</code>, and <code>std::thread</code> is one of them. Though <code>std::thread</code> instances don’t own a dynamic object in the same way as <code>std::unique_ptr</code> does, they do own a resource: each instance is responsible for managing a thread of execution. This ownership can be transferred between instances, because <strong>instances of <code>std::thread</code> are movable, even though they aren’t copyable.</strong> This ensures that only one object is associated with a particular thread of execution at any one time while allowing programmers the option of transferring that ownership between objects.</p>
<h3 id="在线程对象间传递线程的持有权"><a href="#在线程对象间传递线程的持有权" class="headerlink" title="在线程对象间传递线程的持有权"></a>在线程对象间传递线程的持有权</h3><div class="note info">
            <p><strong>被管理的线程的持有权在 <code>std::thread</code> 实例之间流转。</strong></p><blockquote><p>instances of <code>std::thread</code> are movable, not copyable.</p></blockquote>
          </div>
<p>在函数的内外传递线程的持有权是很常见的，即函数的参数或者返回值是 <code>std::thread</code> 实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">som_other_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(some_function)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// not working，拷贝构造函数被禁用了</span></span><br><span class="line"><span class="comment">// std::thread t2 = t1;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::thread t2 = <span class="built_in">std</span>::move(t1); <span class="comment">// 移动构造函数</span></span><br><span class="line"></span><br><span class="line">t1 = <span class="built_in">std</span>::thread(som_other_function); <span class="comment">// std::thread(som_other_function) 表达式是一个将亡值，此处会调用移动赋值运算符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::thread t3;</span><br><span class="line">t3 = <span class="built_in">std</span>::move(t2);</span><br><span class="line">t1 = <span class="built_in">std</span>::move(t3); <span class="comment">// This assignment will terminate program!</span></span><br></pre></td></tr></table></figure>
<p>In the last assignment, <code>t1</code> already had an associated thread (which was running <code>some_other_function</code>), so <code>std::terminate()</code> is called to terminate the program. This is done for consistency with the <code>std::thread</code> destructor. As you must explicitly wait for a thread to complete or detach it before destruction, and the same applies to assignment: you can’t just “drop” a thread by assigning a new value to the <code>std::thread</code> object that manages it.</p>
<h4 id="Returning-a-std-thread-from-a-function"><a href="#Returning-a-std-thread-from-a-function" class="headerlink" title="Returning a std::thread from a function"></a>Returning a std::thread from a function</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::thread(some_function); <span class="comment">// std::thread(some_function) 表达式是一个将亡值，不用显式地调用 std::move</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::thread <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">some_other_function</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(some_other_function, <span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> t; <span class="comment">// 局部变量，这个对象即将被销毁，是一个将亡值，不用显式地调用 std::move，自动发生 move。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Pass-a-std-thread-into-a-function"><a href="#Pass-a-std-thread-into-a-function" class="headerlink" title="Pass a std::thread into a function"></a>Pass a std::thread into a function</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">std</span>::thread)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line">    f(<span class="built_in">std</span>::thread(some_function));</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(some_function)</span></span>;</span><br><span class="line">    f(<span class="built_in">std</span>::move(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 move 修改 <code>thread_guard</code>，让 <code>thread_guard</code> 实际持有线程，而不是通过持有一个线程对象的引用来间接管理线程。<br>去掉了引用，带来的好处：</p>
<ul>
<li><code>thread_guard</code> 可以在线程对象所在的作用域之外生存（引用的存在会让 <code>thread_guard</code> 和线程对象牢牢绑在同一个作用域内）</li>
<li>把线程的持有权转移进了 <code>thread_guard</code> 对象，外部的线程对象没有了线程的持有权，避免了其他人对线程对象调用 <code>join</code> 或者 <code>detach</code>，因为此时外部的线程对象已经 not joinable。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">scoped_thread</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::thread t;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_thread</span><span class="params">(<span class="built_in">std</span>::thread t_)</span> : <span class="title">t</span><span class="params">(<span class="built_in">std</span>::move(t_))</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!t.joinable()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">"No thread."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~scoped_thread() &#123;</span><br><span class="line">        t.join();</span><br><span class="line">    &#125;</span><br><span class="line">    scoped_thread(<span class="keyword">const</span> scoped_thread&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    scoped_thread&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> scoped_thread&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> some_local_state;</span><br><span class="line">    <span class="function">scoped_thread <span class="title">t</span><span class="params">(<span class="built_in">std</span>::thread(func(some_local_state)))</span></span>;</span><br><span class="line"></span><br><span class="line">    do_something_in_current_thread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="std-vector-lt-std-thread-gt"><a href="#std-vector-lt-std-thread-gt" class="headerlink" title="std::vector&lt;std::thread&gt;"></a><code>std::vector&lt;std::thread&gt;</code></h4><p>The move support in <code>std::thread</code> also allows for containers of <code>std::thread</code> objects, if those containers are move aware (like the updated <code>std::vector&lt;&gt;</code>). This means that you can write code like that in the following listing, which spawns a number of threads and then waits for them to finish.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_work</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        threads.push_back(<span class="built_in">std</span>::thread(do_work, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::for_each(threads.begin(), threads.end(), <span class="built_in">std</span>::mem_fn(&amp;<span class="built_in">std</span>::thread::join));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Putting <code>std::thread</code> objects in a <code>std::vector</code> is a step toward automating the management of those threads: rather than creating separate variables for those threads and joining with them directly, they can be treated as a group.</p>
<h3 id="Choosing-the-number-of-threads-at-runtime"><a href="#Choosing-the-number-of-threads-at-runtime" class="headerlink" title="Choosing the number of threads at runtime"></a>Choosing the number of threads at runtime</h3><p>在运行时通过 <code>std::thread::hardware_concurrency()</code> 来获得可以真正并发的线程数目，在一个多核系统上，返回值可能是 CPU 的核心数目。返回值仅仅是一个 hint，在这个信息不可用时，返回 0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">accumulate_block</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Iterator first, Iterator last, T&amp; result)</span> </span>&#123;</span><br><span class="line">        result = <span class="built_in">std</span>::accumulate(first, last, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">parallel_accumulate</span><span class="params">(Iterator first, Iterator last, T init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> length = <span class="built_in">std</span>::distance(first, last);</span><br><span class="line">    <span class="keyword">if</span> (!length) &#123;</span><br><span class="line">        <span class="keyword">return</span> init;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> min_per_thread = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> max_threads = (length + min_per_thread - <span class="number">1</span>) / min_per_thread;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> hardware_threads = <span class="built_in">std</span>::thread::hardware_concurrency();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> num_threads = <span class="built_in">std</span>::min(hardware_threads != <span class="number">0</span> ? hardware_threads : <span class="number">2</span>, max_threads);</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; <span class="title">threads</span><span class="params">(num_threads - <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; <span class="title">results</span><span class="params">(num_threads)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max_threads: "</span> &lt;&lt; max_threads &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></span><br><span class="line">              &lt;&lt; <span class="string">"hardware_threads: "</span> &lt;&lt; hardware_threads &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></span><br><span class="line">              &lt;&lt; <span class="string">"num_threads: "</span> &lt;&lt; num_threads &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> block_size = (length + num_threads - <span class="number">1</span>) / num_threads;</span><br><span class="line">    Iterator block_start = first;</span><br><span class="line">    Iterator block_end = first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_threads - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::advance(block_end, block_size);</span><br><span class="line">        threads[i] = <span class="built_in">std</span>::thread(accumulate_block&lt;Iterator, T&gt;(), block_start, block_end, <span class="built_in">std</span>::ref(results[i]));</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread #"</span> &lt;&lt; i &lt;&lt; <span class="string">" will process "</span> &lt;&lt; block_size &lt;&lt; <span class="string">" elements"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        block_start = block_end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The main Thread will process "</span> &lt;&lt; <span class="built_in">std</span>::distance(block_end, last) &lt;&lt; <span class="string">" elements"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    accumulate_block&lt;Iterator, T&gt;()(block_end, last, <span class="built_in">std</span>::ref(results.back()));</span><br><span class="line">    <span class="built_in">std</span>::for_each(threads.begin(), threads.end(), <span class="built_in">std</span>::mem_fn(&amp;<span class="built_in">std</span>::thread::join));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::accumulate(results.begin(), results.end(), init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> result = parallel_accumulate(v.begin(), v.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Result is "</span> &lt;&lt; result &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// max_threads: 3</span></span><br><span class="line"><span class="comment">// hardware_threads: 8</span></span><br><span class="line"><span class="comment">// num_threads: 3</span></span><br><span class="line"><span class="comment">// Thread #0 will process 2 elements</span></span><br><span class="line"><span class="comment">// Thread #1 will process 2 elements</span></span><br><span class="line"><span class="comment">// The main Thread will process 1 elements</span></span><br><span class="line"><span class="comment">// Result is 15</span></span><br></pre></td></tr></table></figure>
<h2 id="线程间共享数据"><a href="#线程间共享数据" class="headerlink" title="线程间共享数据"></a>线程间共享数据</h2><p>If all shared data is read-only, there’s no problem, because the data read by one thread is unaffected by whether or not another thread is reading the same data.</p>
<p>If one of the member functions returns a pointer or reference to the protected data, then it doesn’t matter that the member functions all lock the mutex in a nice orderly fashion, because you’ve just blown a big hole in the protection. Any code that has access to that pointer or reference can now access (and potentially modify) the protected data without locking the mutex. Protecting data with a mutex therefore requires careful interface design, to ensure that the mutex is locked before there’s any access to the protected data and that there are no backdoors.<br>互斥锁需要好的接口设计配合才能真正起到保护作用，不留后门。</p>
<h3 id="用互斥锁来构建一个线程安全的栈"><a href="#用互斥锁来构建一个线程安全的栈" class="headerlink" title="用互斥锁来构建一个线程安全的栈"></a>用互斥锁来构建一个线程安全的栈</h3><p>有的数据结构的接口本身存在固有的竞争条件(race conditions inherent in interfaces)，这时就必须重新设计接口，并注意异常安全性问题。</p>
<p>If the <code>pop()</code> function was defined to return the value popped, <strong>as well as</strong> remove it from the stack, you have a potential problem: the value being popped is returned to the caller only after the stack has been modified, but the process of copying the data to return to the caller might throw an exception. If this happens, the data just popped is lost; it has been removed from the stack, but the copy was unsuccessful! The designers of the <code>std::stack</code> interface helpfully split the operation in two: get the top element (<code>top()</code>) and then remove it from the stack (<code>pop()</code>), so that if you can’t safely copy the data, it stays on the stack. If the problem was lack of heap memory, maybe the application can free some memory and try again.<strong>Unfortunately, it’s precisely this split that you’re trying to avoid in eliminating the race condition!</strong></p>
<ul>
<li>OPTION 1: PASS IN A REFERENCE</li>
<li>OPTION 2: REQUIRE A NO-THROW COPY CONSTRUCTOR OR MOVE CONSTRUCTOR. This option restricts the use of your thread-safe stack to those types that can safely be returned by value without throwing an exception.</li>
<li>OPTION 3: RETURN A POINTER TO THE POPPED ITEM</li>
<li>OPTION 4: PROVIDE BOTH OPTION 1 AND EITHER OPTION 2 OR 3</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">empty_stack</span> :</span> <span class="built_in">std</span>::exception &#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"empty stack"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_stack</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt; data;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex m;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    threadsafe_stack() &#123;&#125;</span><br><span class="line">    threadsafe_stack(<span class="keyword">const</span> threadsafe_stack&amp; other) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;</span><br><span class="line">        data = other.data;</span><br><span class="line">    &#125;</span><br><span class="line">    threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        data.push(new_value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data.empty()) <span class="keyword">throw</span> empty_stack();</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="keyword">const</span> <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(data.top()))</span></span>;</span><br><span class="line">        data.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data.empty()) <span class="keyword">throw</span> empty_stack();</span><br><span class="line">        value = data.top();</span><br><span class="line">        data.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The <code>pop()</code> functions throw an <code>empty_stack</code> exception if the stack is empty, so everything still works even if the stack is modified after a call to <code>empty()</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!si.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    si.pop(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Because all the member functions use a <code>std::lock_guard&lt;&gt;</code> to protect the data, it’s safe for any number of threads to call the stack member functions. The only member functions that aren’t safe are the <strong>constructors</strong> and <strong>destructors</strong>, but this isn’t a particular problem; the object can be constructed only once and destroyed only once. Calling member functions on an incompletely constructed object or a partially destructed object is never a good idea whether done concurrently or not.<br><strong>As a consequence, the user must ensure that other threads aren’t able to access the stack until it’s fully constructed and must ensure that all threads have ceased accessing the stack before it’s destroyed.</strong></p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>Deadlock is the biggest problem with having to lock two or more mutexes in order to perform an operation.<br>为了执行一个操作，需要对两个甚至更多的锁进行上锁。<br>The common advice for avoiding deadlock is to always lock the two mutexes in the same order: <strong>if you always lock mutex A before mutex B, then you’ll never deadlock.</strong></p>
<p><code>std::lock</code>— 对多个锁同时上锁，并提供 <strong>all-or-nothing</strong> 语义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_big_object</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(some_big_object&amp; lhs, some_big_object&amp; rhs)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    some_big_object some_detail;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex m;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    X(some_big_object <span class="keyword">const</span>&amp; sd) : some_detail(sd) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// the arguments are checked to ensure they are different instances, because attempting to</span></span><br><span class="line">        <span class="comment">// acquire a lock on a std::mutex when you already hold it is undefined behavior.</span></span><br><span class="line">        <span class="comment">// 对一个自己已经上过锁的 std::mutex 再次上锁会导致未定义行为，毕竟不是递归锁。</span></span><br><span class="line">        <span class="comment">// std::recursive_mutex 递归锁，能被同一线程多次上锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (&amp;lhs == &amp;rhs)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对两个 std::mutex 进行上锁</span></span><br><span class="line">        <span class="built_in">std</span>::lock(lhs.m, rhs.m);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The std::adopt_lock parameter is supplied in addition to the mutex to indicate to</span></span><br><span class="line">        <span class="comment">// the std::lock_guard objects that the mutexes are already locked,</span></span><br><span class="line">        <span class="comment">// and they should just adopt the ownership of the existing lock on the mutex</span></span><br><span class="line">        <span class="comment">// rather than attempt to lock the mutex in the constructor.</span></span><br><span class="line">        <span class="comment">// 此线程已经获得锁的持有权，std::lock_guard&lt;std::mutex&gt; 只需要收养锁的持有权即可，</span></span><br><span class="line">        <span class="comment">// 不要再次在自己的构造函数中试图上锁争取锁的持有权。</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m, <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m, <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line">        swap(lhs.some_detail, rhs.some_detail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>locking either <code>lhs.m</code> or <code>rhs.m</code> inside the call to <code>std::lock</code> can throw an exception; in this case, the exception is propagated out of <code>std::lock</code>. If <code>std::lock</code> has successfully acquired a lock on one mutex and an exception is thrown when it tries to acquire a lock on the other mutex, this first lock is released automatically: <code>std::lock</code> provides <strong>all-or-nothing</strong> semantics with regard to locking the supplied mutexes.</p>
<h4 id="Further-guidelines-for-avoiding-deadlock"><a href="#Further-guidelines-for-avoiding-deadlock" class="headerlink" title="Further guidelines for avoiding deadlock"></a>Further guidelines for avoiding deadlock</h4><p>Deadlock doesn’t just occur with locks, although that’s the most frequent cause; you can create deadlock with two threads and no locks just by having each thread call <code>join()</code> on the <code>std::thread</code> object for the other. In this case, neither thread can make progress because it’s waiting for the other to finish, just like the children fighting over their toys. This simple cycle can occur anywhere that a thread can wait for another thread to perform some action if the other thread can simultaneously be waiting for the first thread, and it isn’t limited to two threads: a cycle of three or more threads will still cause deadlock. <strong>The guidelines for avoiding deadlock all boil down to one idea: don’t wait for another thread if there’s a chance it’s waiting for you.</strong></p>
<ul>
<li>AVOID NESTED LOCKS. 尽量不要设计出需要获得多个锁才能执行的“骚”操作。If you need to acquire multiple locks, do it as a single action with <code>std::lock</code> in order to acquire them without deadlock.</li>
<li>ACQUIRE LOCKS IN A FIXED ORDER 以固定的顺序上锁</li>
<li>USE A LOCK HIERARCHY 使用锁层次结构<br>Although this is really a particular case of defining lock ordering, a lock hierarchy can provide a means of checking that the convention is adhered to <strong>at runtime</strong>.<br>The idea is that you divide your application into layers and identify all the mutexes that may be locked in any given layer. When code tries to lock a mutex, it isn’t permitted to lock that mutex if it already holds a lock from a lower layer.（确保以固定的顺序上锁，不允许一个线程在锁层次中从上到下上锁，另外一个线程在锁层次中从下到上上锁，造成死锁）<br>You can check this at runtime by assigning layer numbers to each mutex and keeping a record of which mutexes are locked by each thread.<br>每个锁有一个层次号，并维护一个当前线程的上锁记录。</li>
<li>AVOID CALLING USER-SUPPLIED CODE WHILE HOLDING A LOCK 在持有锁的情况下不要调用用户提供的代码</li>
</ul>
<h3 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h3><p><strong>被管理的锁的持有权在 <code>std::unique_lock</code> 实例之间流转。</strong></p>
<p>unique_lock 和 lock_guard 都是基于 RAII 思想的锁管理工具，RAII 用于解决<strong>资源管理</strong>的<strong>异常安全性</strong>，unique_lock 和 lock_guard 可以保证即使发生了异常，自己持有的锁也可以得到正确地释放。</p>
<p>unique_lock 实例不一定<strong>一直</strong>持有着锁<br>unique_lock 实例不一定<strong>真正</strong>持有着锁</p>
<p>unique_lock 比 lock_guard 更加灵活：</p>
<ul>
<li><code>unique_lock</code> 可以在不析构的情况下提前解锁。The ability to release a lock before the <code>std::unique_lock</code> instance is destroyed means that you can optionally release it in a specific code branch if it’s apparent that the lock is no longer required.</li>
<li>被管理的锁的持有权在 <code>std::unique_lock</code> 实例之间流转</li>
<li>pass <code>std::adopt_lock</code> as the second argument to the constructor 来收养锁的持有权</li>
<li>pass <code>std::defer_lock</code> as the second argument to the constructor 来推迟构造函数中原本要进行的上锁操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_big_object</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(some_big_object&amp; lhs, some_big_object&amp; rhs)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    some_big_object some_detail;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex m;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    X(some_big_object <span class="keyword">const</span>&amp; sd) : some_detail(sd) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;lhs == &amp;rhs)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m, <span class="built_in">std</span>::defer_lock)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m, <span class="built_in">std</span>::defer_lock)</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::lock(lock_a, lock_b);</span><br><span class="line">        swap(lhs.some_detail, rhs.some_detail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>The <code>std::unique_lock</code> objects could be passed to <code>std::lock()</code> because <code>std::unique_lock</code> provides <code>lock()</code>, <code>try_lock()</code>, and <code>unlock()</code> member functions. These forward to the member functions of the same name on the underlying mutex to do the actual work and <strong>just update a flag inside the <code>std::unique_lock</code> instance to indicate whether the mutex is currently owned by that instance</strong>. This flag is necessary in order to ensure that <code>unlock()</code> is called correctly in the destructor. <strong>If the instance does own the mutex, the destructor must call unlock(), and if the instance does not own the mutex, it must not call unlock().</strong> This flag can be queried by calling the owns_lock() member function.</p>
<h4 id="被管理的锁的持有权在-std-unique-lock-实例之间流转"><a href="#被管理的锁的持有权在-std-unique-lock-实例之间流转" class="headerlink" title="被管理的锁的持有权在 std::unique_lock 实例之间流转"></a>被管理的锁的持有权在 <code>std::unique_lock</code> 实例之间流转</h4><p><code>std::unique_lock</code> is movable but not copyable.</p>
<p>一个函数上锁，并将锁的持有权转移给另外一个函数，也就是完成了被管理的锁的持有权在 <code>std::unique_lock</code> 实例之间流转，一个函数中的实例到另一个函数中的实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">get_lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="built_in">std</span>::mutex some_mutex;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(some_mutex)</span></span>;</span><br><span class="line">    prepare_data();</span><br><span class="line">    <span class="keyword">return</span> lk;  <span class="comment">// 将亡值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(get_lock())</span></span>;</span><br><span class="line">    do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Lazy-initialization"><a href="#Lazy-initialization" class="headerlink" title="Lazy initialization"></a>Lazy initialization</h3><p>单线程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;some_resource&gt; resource_ptr;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!resource_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        resource_ptr.reset(<span class="keyword">new</span> some_resource);</span><br><span class="line">    &#125;</span><br><span class="line">    resource_ptr-&gt;do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多线程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;some_resource&gt; resource_ptr;</span><br><span class="line"><span class="built_in">std</span>::mutex resource_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不管三七二十一直接上锁，每次进来都要上锁</span></span><br><span class="line">    <span class="comment">// All threads are serialized here</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(resource_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(!resource_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Only the initialization needs protection</span></span><br><span class="line">        resource_ptr.reset(<span class="keyword">new</span> some_resource);</span><br><span class="line">    &#125;</span><br><span class="line">    lk.unlock();</span><br><span class="line">    resource_ptr-&gt;do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>臭名昭著的 Double-Checked Locking：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">undefined_behaviour_with_double_checked_locking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 后续不需要上锁</span></span><br><span class="line">    <span class="keyword">if</span> (!resource_ptr) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(resource_mutex)</span></span>;</span><br><span class="line">        <span class="comment">// 时过境迁，之前的判断有可能已经失效了，再次进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (!resource_ptr) &#123;</span><br><span class="line">            resource_ptr.reset(<span class="keyword">new</span> some_resource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resource_ptr-&gt;do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This is an example of the type of race condition defined as a <strong>data race</strong> by the C++ Standard and thus specified as ~undefined behavior~. It’s is therefore quite definitely something to avoid. See chapter 5 for a detailed discussion of the <strong>memory model</strong>, including what constitutes a data race.<br>解决方案是：<br>Thread-safe lazy initialization of a class member using <code>std::call_once</code></p>
<h3 id="局部静态对象的初始化"><a href="#局部静态对象的初始化" class="headerlink" title="局部静态对象的初始化"></a>局部静态对象的初始化</h3><p>The initialization of such a variable is defined to occur <strong>the first time control passes through its declaration</strong>; for multiple threads calling the function, this means there’s the potential for a race condition to define first.</p>
<ul>
<li>On many <strong>pre-C++11</strong> compilers this race condition is problematic in practice, because multiple threads may believe they’re first and try to initialize the variable, or threads may try to use it after initialization has started on another thread but before it’s finished.</li>
<li>In <strong>C++11</strong> this problem is solved: the initialization is defined to happen on exactly one thread, and no other threads will proceed until that initialization is complete, so the race condition is just <strong>over which thread gets to do the initialization</strong> rather than anything more problematic.</li>
</ul>
<p><strong>C++11 解决了局部静态对象初始化的竞争问题。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_class</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function">my_class&amp; <span class="title">get_my_class_instance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialization guaranteed to be thread-safe</span></span><br><span class="line">    <span class="keyword">static</span> my_class instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Multiple threads can then call <code>get_my_class_instance()</code> safely, without having to worry about race conditions on the initialization.</p>
<h4 id="构造函数调用时机及数据段"><a href="#构造函数调用时机及数据段" class="headerlink" title="构造函数调用时机及数据段"></a>构造函数调用时机及数据段</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    X() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Default constructor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    X(<span class="keyword">int</span> data_) : data&#123;data_&#125; &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Single argument constructor "</span> &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~X() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Destructor"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter func"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">static</span> X local_static;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> X <span class="title">local_static_1</span><span class="params">(<span class="number">300</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Exit from func"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个 X 型对象</span></span><br><span class="line">X global;</span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">global_1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="keyword">static</span> X global_static;</span><br><span class="line"><span class="function"><span class="keyword">static</span> X <span class="title">global_static_1</span><span class="params">(<span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Main function"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    func();</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Default constructor</span></span><br><span class="line"><span class="comment">// Single argument constructor 100</span></span><br><span class="line"><span class="comment">// Default constructor</span></span><br><span class="line"><span class="comment">// Single argument constructor 200</span></span><br><span class="line"><span class="comment">// Main function</span></span><br><span class="line"><span class="comment">// Enter func</span></span><br><span class="line"><span class="comment">// Default constructor</span></span><br><span class="line"><span class="comment">// Single argument constructor 300</span></span><br><span class="line"><span class="comment">// Exit from func</span></span><br><span class="line"><span class="comment">// Enter func</span></span><br><span class="line"><span class="comment">// Exit from func</span></span><br><span class="line"><span class="comment">// Destructor</span></span><br><span class="line"><span class="comment">// Destructor</span></span><br><span class="line"><span class="comment">// Destructor</span></span><br><span class="line"><span class="comment">// Destructor</span></span><br><span class="line"><span class="comment">// Destructor</span></span><br><span class="line"><span class="comment">// Destructor</span></span><br></pre></td></tr></table></figure>
<p>编译器只能把能放的值放过去，不能调用构造函数。因此 <code>local_static</code>，<code>local_static_1</code>，<code>global</code>，<code>global_1</code> 全都在 uninitialized data section，因为编译器找不到合适的值填充这些对象的空间。在装载可执行文件时，这些对象的内存地址空间会被 exec 初始化为 0，之后 <code>global</code>，<code>global_1</code> 会由 <code>_init</code> 函数完成构造函数的调用，这个地方是没有多线程竞争的，对于 <code>local_static</code>，<code>local_static_1</code> 而言，如果用户代码不调用 <code>func</code> 函数，它们的构造函数永远不会被调用。只有 <code>func</code> 被调用了，第一次调用时才会调用它们的构造函数，因此这里就存在了多线程竞争，多个线程争先想当第一名，争先调用构造函数。</p>
<ul>
<li>initialized data section: 编译器把合适的值放到输出文件中，然后在装载可执行文件时，read from program file by exec。global/static 变量：such as int, 字面量常量</li>
<li>uninitialized data section: 放的也是 global/static 变量，such as int without initialization，complex object. 只不过编译器不知道放什么值，就索性不放了，然后在装载可执行文件时，initialized to zero by exec，这些地址空间之后会被 <code>_init</code> 函数和用户代码再次赋予合适的值。</li>
</ul>
<h3 id="Protecting-rarely-updated-data-structures"><a href="#Protecting-rarely-updated-data-structures" class="headerlink" title="Protecting rarely updated data structures"></a>Protecting rarely updated data structures</h3><p>读写锁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/shared_mutex.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dns_entry</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dns_cache</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, dns_entry&gt; entries;</span><br><span class="line">    boost::shared_mutex entry_mutex;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">dns_entry <span class="title">find_entry</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; domain)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 上读锁</span></span><br><span class="line">        <span class="function">boost::shared_lock&lt;boost::shared_mutex&gt; <span class="title">lk</span><span class="params">(entry_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, dns_entry&gt;::const_iterator <span class="keyword">const</span> it =</span><br><span class="line">            entries.find(domain);</span><br><span class="line">        <span class="keyword">return</span> (it == entries.end()) ? dns_entry() : it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update_or_add_entry</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; domain,</span></span></span><br><span class="line"><span class="function"><span class="params">                             dns_entry <span class="keyword">const</span>&amp; dns_details)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 上写锁</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;boost::shared_mutex&gt; <span class="title">lk</span><span class="params">(entry_mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">        entries[domain] = dns_details;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>线程同步的本质就是 <strong>wait for events</strong>。</p>
<ul>
<li>periodically checking a “task complete” flag or something similar stored in shared data</li>
<li>condition variables</li>
<li>futures one-off event</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_for_flag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="comment">// 判断之前加锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">        <span class="comment">// 睡眠之前解锁</span></span><br><span class="line">        lk.unlock();</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">100</span>));</span><br><span class="line">        <span class="comment">// 睡醒之后加锁</span></span><br><span class="line">        lk.lock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p><strong>wait for events</strong>，等待事件的发生，等待条件的满足。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mut;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;data_chunk&gt; data_queue;</span><br><span class="line"><span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (more_data_to_prepare()) &#123;</span><br><span class="line">        data_chunk <span class="keyword">const</span> data = prepare_data();</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_queue.push(data);</span><br><span class="line">        data_cond.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        why you need the std::unique_lock rather than the std::lock_guard—the waiting thread must unlock the mutex while it’s waiting</span></span><br><span class="line"><span class="comment">        and lock it again afterward, and std::lock_guard doesn’t provide that flexibility</span></span><br><span class="line"><span class="comment">        std::unique_lock 基于 RAII 思想的锁管理工具，RAII 用于解决**资源管理**的**异常安全性**，</span></span><br><span class="line"><span class="comment">        std::unique_lock 的析构函数会在其持有锁时释放锁。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.wait(lk, [] &#123; <span class="keyword">return</span> !data_queue.empty(); &#125;);</span><br><span class="line">        data_chunk data = data_queue.front();</span><br><span class="line">        data_queue.pop();</span><br><span class="line">        lk.unlock();</span><br><span class="line">        process(data);</span><br><span class="line">        <span class="keyword">if</span> (is_last_chunk(data))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(data_preparation_thread)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(data_processing_thread)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>data_cond.wait(lk, [] { return !data_queue.empty(); });</code><br>在检查 lambda 之前是上好锁的，在检查 lambda 之后根据其返回值，决定是解锁睡去还是继续持有锁返回。</p>
<p>可能多次（不定次）被虚假唤醒。</p>
<h4 id="用条件变量来构建一个线程安全的队列"><a href="#用条件变量来构建一个线程安全的队列" class="headerlink" title="用条件变量来构建一个线程安全的队列"></a>用条件变量来构建一个线程安全的队列</h4><p>有的数据结构的接口本身存在固有的竞争条件(race conditions inherent in interfaces)，这时就必须重新设计接口，并注意异常安全性问题。</p>
<p>Consequently, you need to combine <code>front()</code> and <code>pop()</code> into a single function call, much as you combined <code>top()</code> and <code>pop()</code> for the stack.</p>
<p><strong>不然就是 twice and none</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex mut;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;T&gt; data_queue;</span><br><span class="line">    <span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    threadsafe_queue() &#123;&#125;</span><br><span class="line">    threadsafe_queue(threadsafe_queue <span class="keyword">const</span>&amp; other) &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(other.mut)</span></span>;</span><br><span class="line">        data_queue = other.data_queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_queue.push(new_value);</span><br><span class="line">        data_cond.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.wait(lk, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> !data_queue.empty(); &#125;);</span><br><span class="line">        value = data_queue.front();</span><br><span class="line">        data_queue.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        data_cond.wait(lk, [<span class="keyword">this</span>] &#123; <span class="keyword">return</span> !data_queue.empty(); &#125;);</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(data_queue.front()))</span></span>;</span><br><span class="line">        data_queue.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data_queue.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value = data_queue.front();</span><br><span class="line">        data_queue.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data_queue.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(data_queue.front()))</span></span>;</span><br><span class="line">        data_queue.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 常量成员函数</span></span><br><span class="line">        <span class="comment">// locking a mutex is a mutating operation, the mutex object must be marked mutable so it can be locked in empty() and in the copy constructor.</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> data_queue.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>bool try_pop(T&amp; value);</code><br>防止已经 modify 了内部的数据结构（移除了元素），却在返回值拷贝时失败了（vector 拷贝，空间不足），造成数据丢失。因此，<strong>先拷贝后移除</strong>，保证拷贝失败时数据还未移除。</p>
<p><code>std::shared_ptr&lt;T&gt; try_pop();</code><br>内部先拷贝，然后传出一个指针。思想同上，先拷贝后移除，保证拷贝失败时数据还未移除。</p>
<h3 id="future"><a href="#future" class="headerlink" title="future"></a>future</h3><p><code>std::future</code> 指代一个异步结果，将一个线程中函数调用的结果或者异常带回到 <code>std::future</code> 所在的本线程。</p>
<p>被管理的异步结果的持有权在 <code>std::future</code> 实例之间流转。</p>
<p>The thread can then periodically wait on the future for short periods of time to see if the event has occurred (check the departures board) while performing some other task (eating in the overpriced café) in between checks. Alternatively, it can do another task until it needs the event to have happened before it can proceed and then just wait for the future to become ready.</p>
<p>多个 <code>std::future</code> 不能指代同一个异步结果，多个 <code>std::shared_future</code> 可以指代同一个异步结果。</p>
<p>In the latter case, all the instances will become ready at the same time, and they may all access any data associated with the event.</p>
<p>大家访问同一个 <code>std::shared_future</code> 对象是线程不安全的，<br>但是大家访问不同的 <code>std::shared_future</code> 对象副本是线程安全的，即使这些副本指代同一个异步结果。</p>
<h4 id="将结果或者异常带回到-std-future-所在的本线程"><a href="#将结果或者异常带回到-std-future-所在的本线程" class="headerlink" title="将结果或者异常带回到 std::future 所在的本线程"></a>将结果或者异常带回到 <code>std::future</code> 所在的本线程</h4><h5 id="join"><a href="#join" class="headerlink" title="join"></a>join</h5><p>通过 <code>join</code> 等待，wait for it (by joining with it)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_data_for_widget</span><span class="params">(widget_id w, widget_data&amp; data)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops_again</span><span class="params">(widget_id w)</span> </span>&#123;</span><br><span class="line">    widget_data data;</span><br><span class="line">    <span class="comment">// std::thread t(update_data_for_widget, w, data);</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(update_data_for_widget, w, <span class="built_in">std</span>::ref(data))</span></span>;</span><br><span class="line">    display_status();</span><br><span class="line">    t.join();</span><br><span class="line">    process_widget_data(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="async"><a href="#async" class="headerlink" title="async"></a>async</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run in new thread</span></span><br><span class="line"><span class="keyword">auto</span> f6 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, Y(), <span class="number">1.2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run in wait() or get()</span></span><br><span class="line"><span class="keyword">auto</span> f7 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::deferred, baz, <span class="built_in">std</span>::ref(x));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementation chooses</span></span><br><span class="line"><span class="keyword">auto</span> f8 = <span class="built_in">std</span>::async(</span><br><span class="line">    <span class="built_in">std</span>::launch::deferred | <span class="built_in">std</span>::launch::async,</span><br><span class="line">    baz, <span class="built_in">std</span>::ref(x));</span><br><span class="line"><span class="comment">// Implementation chooses</span></span><br><span class="line"><span class="keyword">auto</span> f9 = <span class="built_in">std</span>::async(baz, <span class="built_in">std</span>::ref(x));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke deferred function</span></span><br><span class="line">f7.wait();</span><br></pre></td></tr></table></figure>
<h5 id="std-packaged-task"><a href="#std-packaged-task" class="headerlink" title="std::packaged_task"></a>std::packaged_task</h5><p>You can thus wrap a task in a std::packaged_task and retrieve the future before passing the std::packaged_task object elsewhere to be invoked in due course. When you need the result, you can wait for the future to become ready.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">task</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">return</span> ++value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>)</span>&gt; <span class="title">pt</span><span class="params">(task)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; f = pt.get_future();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 packaged_task 发送过去，把 future 留下来接收结果和异常</span></span><br><span class="line">    <span class="comment">// note: 'packaged_task' has been explicitly marked deleted here</span></span><br><span class="line">    <span class="comment">// packaged_task(const packaged_task&amp;) = delete;</span></span><br><span class="line">    <span class="comment">// 两种做法都可</span></span><br><span class="line">    <span class="comment">// std::thread t(std::ref(pt), 1);</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(<span class="built_in">std</span>::move(pt), <span class="number">1</span>)</span></span>;</span><br><span class="line">    t.detach();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f.get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="std-promises"><a href="#std-promises" class="headerlink" title="std::promises"></a>std::promises</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_1</span><span class="params">(<span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; &amp;pm)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"func_1"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">5</span>));</span><br><span class="line">    pm.set_value(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_2</span><span class="params">(<span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; &amp;&amp;pm)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"func_2"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">5</span>));</span><br><span class="line">    pm.set_value(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; pm;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; f = pm.get_future();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 promise 发送过去，把 future 留下来接收结果和异常</span></span><br><span class="line">    <span class="comment">// note: 'promise' has been explicitly marked deleted here</span></span><br><span class="line">    <span class="comment">// promise(const promise&amp; __rhs) = delete;</span></span><br><span class="line">    <span class="comment">// 两种做法都可</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(func_1, <span class="built_in">std</span>::ref(pm))</span></span>;</span><br><span class="line">    <span class="comment">// std::thread t(func_2, std::move(pm));</span></span><br><span class="line">    t.detach();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f.get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="设计基于锁的并发数据结构"><a href="#设计基于锁的并发数据结构" class="headerlink" title="设计基于锁的并发数据结构"></a>设计基于锁的并发数据结构</h2><ul>
<li>ensuring that the accesses are safe，确保线程安全</li>
<li>enabling genuine concurrent access，确保真正并发<br>enabling greater concurrency while ensuring that the data structure remains thread-safe.<br>how can you minimize the amount of serialization that must occur and enable the greatest amount of true concurrency?<br>最大程度地减少串行，最大程度地并发<br>It’s quite common for a data structure to <strong>support concurrent access from threads performing different operations</strong> while <strong>serializing threads that try to perform the same operation</strong>.</li>
</ul>
<p>前面的 <code>threadsafe_stack</code> 每一个成员函数都加了锁，确保了线程安全，但所有的这些不同的成员函数都在访问底层的数据结构 <code>std::stack</code>，都需要加锁，所以所有的不同的线程对这些成员函数的调用实际上都是串行的，<strong>在 <code>threadsafe_stack</code> 该数据结构上</strong>并没有确保真正的并发。<br>而且并没有等待功能，a waiting thread must either consume precious resources checking for data or the user must write external wait and notification code (for example, using condition variables), which might render the internal locking unnecessary and therefore wasteful.</p>
<p>而 <code>threadsafe_queue</code> 中提供了 <code>wait_and_pop</code>，rather than continuously calling <code>empty()</code>, the waiting thread can just call <code>wait_and_pop()</code> and <strong>the data structure will handle the waiting with a condition variable</strong>.</p>
<p>但是存在一个异常安全性问题：<br>There’s a slight twist with regard to exception safety in that if more than one thread is waiting when an entry is pushed onto the queue, only one thread will be woken by the call to <code>data_cond.notify_one().</code> If that thread then throws an exception in <code>wait_and_pop()</code>, such as when the new <code>std::shared_ptr&lt;&gt;</code> is constructed（也就是在拷贝时发生了异常）, none of the other threads will be woken.<br>If this isn’t acceptable,</p>
<ul>
<li><code>data_cond.notify_all()</code>, which will wake all the threads but at the cost of most of them then going back to sleep when they find that the queue is empty after all.</li>
<li>A second alternative is to have <code>wait_and_pop()</code> call <code>notify_one()</code> if an exception is thrown, so that another thread can attempt to retrieve the stored value.</li>
<li>A third alternative is to move the <code>std::shared_ptr&lt;&gt;</code> initialization to the <code>push()</code> call and store <code>std::shared_ptr&lt;&gt;</code> instances rather than direct data values. Copying the <code>std::shared_ptr&lt;&gt;</code> out of the internal <code>std::queue&lt;&gt;</code> then can’t throw an exception, so <code>wait_and_pop()</code> is safe again.</li>
</ul>
<p>Just like in the stack example, the use of a mutex to protect the entire data structure limits the concurrency supported by this queue; although multiple threads might be blocked on the queue in various member functions, only one thread can be doing any work at a time. <strong>所有的这些不同的成员函数都在访问底层的数据结构 <code>std::queue</code>，都需要加锁，所以所有的不同的线程对这些成员函数的调用实际上都是串行的，在 <code>threadsafe_queue</code> 该数据结构上并没有确保真正的并发。</strong></p>
<p>By using the standard container you now have essentially <strong>one</strong> data item that’s either protected or not. By taking control of the detailed implementation of the data structure, you can <strong>provide more fine-grained locking and thus allow a higher level of concurrency</strong>.</p>
<h3 id="细粒度的锁，更高的并发度"><a href="#细粒度的锁，更高的并发度" class="headerlink" title="细粒度的锁，更高的并发度"></a>细粒度的锁，更高的并发度</h3><p>fine-grained locking and higher level of concurrency</p>
<p>A simple single-threaded queue implementation</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">        T data;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; next;</span><br><span class="line"></span><br><span class="line">        node(T data_) : data(<span class="built_in">std</span>::move(data_)) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; head;</span><br><span class="line">    node* tail;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">queue</span>() : tail(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>(<span class="keyword">const</span> <span class="built_in">queue</span>&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">queue</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">queue</span>&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="keyword">const</span> <span class="title">res</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="built_in">std</span>::make_shared&lt;T&gt;(<span class="built_in">std</span>::move(head-&gt;data)))</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="keyword">const</span> old_head = <span class="built_in">std</span>::move(head);</span><br><span class="line">        head = <span class="built_in">std</span>::move(old_head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;node&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> node(<span class="built_in">std</span>::move(new_value)))</span></span>;</span><br><span class="line">        node* <span class="keyword">const</span> new_tail = p.get();</span><br><span class="line">        <span class="keyword">if</span> (tail) &#123;</span><br><span class="line">            tail-&gt;next = <span class="built_in">std</span>::move(p);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = <span class="built_in">std</span>::move(p);</span><br><span class="line">        &#125;</span><br><span class="line">        tail = new_tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/02/23/C-表达式-vs-statement/" rel="prev" title="C++ 表达式 vs Statement">
      <i class="fa fa-chevron-left"></i> C++ 表达式 vs Statement
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/03/09/MIT-6-006-Heaps-and-Heap-Sort/" rel="next" title="MIT 6.006: Heaps and Heap Sort">
      MIT 6.006: Heaps and Heap Sort <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本的线程管理"><span class="nav-number">1.</span> <span class="nav-text">基本的线程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#启动线程"><span class="nav-number">1.1.</span> <span class="nav-text">启动线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-’s-most-vexing-parse"><span class="nav-number">1.2.</span> <span class="nav-text">C++’s most vexing parse</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#确保线程访问的数据的有效性"><span class="nav-number">1.3.</span> <span class="nav-text">确保线程访问的数据的有效性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#等待线程结束"><span class="nav-number">1.4.</span> <span class="nav-text">等待线程结束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在异常发生时等待线程结束"><span class="nav-number">1.5.</span> <span class="nav-text">在异常发生时等待线程结束</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Try-catch"><span class="nav-number">1.5.1.</span> <span class="nav-text">Try/catch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RAII"><span class="nav-number">1.5.2.</span> <span class="nav-text">RAII</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在后台运行线程"><span class="nav-number">1.6.</span> <span class="nav-text">在后台运行线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#向线程函数传递参数"><span class="nav-number">1.7.</span> <span class="nav-text">向线程函数传递参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#当参数-not-copyable-but-movable"><span class="nav-number">1.7.1.</span> <span class="nav-text">当参数 not copyable but movable</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在线程对象间传递线程的持有权"><span class="nav-number">1.8.</span> <span class="nav-text">在线程对象间传递线程的持有权</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Returning-a-std-thread-from-a-function"><span class="nav-number">1.8.1.</span> <span class="nav-text">Returning a std::thread from a function</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pass-a-std-thread-into-a-function"><span class="nav-number">1.8.2.</span> <span class="nav-text">Pass a std::thread into a function</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#std-vector-lt-std-thread-gt"><span class="nav-number">1.8.3.</span> <span class="nav-text">std::vector&lt;std::thread&gt;</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Choosing-the-number-of-threads-at-runtime"><span class="nav-number">1.9.</span> <span class="nav-text">Choosing the number of threads at runtime</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程间共享数据"><span class="nav-number">2.</span> <span class="nav-text">线程间共享数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用互斥锁来构建一个线程安全的栈"><span class="nav-number">2.1.</span> <span class="nav-text">用互斥锁来构建一个线程安全的栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁"><span class="nav-number">2.2.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Further-guidelines-for-avoiding-deadlock"><span class="nav-number">2.2.1.</span> <span class="nav-text">Further guidelines for avoiding deadlock</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unique-lock"><span class="nav-number">2.3.</span> <span class="nav-text">unique_lock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#被管理的锁的持有权在-std-unique-lock-实例之间流转"><span class="nav-number">2.3.1.</span> <span class="nav-text">被管理的锁的持有权在 std::unique_lock 实例之间流转</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lazy-initialization"><span class="nav-number">2.4.</span> <span class="nav-text">Lazy initialization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#局部静态对象的初始化"><span class="nav-number">2.5.</span> <span class="nav-text">局部静态对象的初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数调用时机及数据段"><span class="nav-number">2.5.1.</span> <span class="nav-text">构造函数调用时机及数据段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Protecting-rarely-updated-data-structures"><span class="nav-number">2.6.</span> <span class="nav-text">Protecting rarely updated data structures</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程同步"><span class="nav-number">3.</span> <span class="nav-text">线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#条件变量"><span class="nav-number">3.1.</span> <span class="nav-text">条件变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用条件变量来构建一个线程安全的队列"><span class="nav-number">3.1.1.</span> <span class="nav-text">用条件变量来构建一个线程安全的队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#future"><span class="nav-number">3.2.</span> <span class="nav-text">future</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将结果或者异常带回到-std-future-所在的本线程"><span class="nav-number">3.2.1.</span> <span class="nav-text">将结果或者异常带回到 std::future 所在的本线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#join"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">join</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#async"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">async</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#std-packaged-task"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">std::packaged_task</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#std-promises"><span class="nav-number">3.2.1.4.</span> <span class="nav-text">std::promises</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设计基于锁的并发数据结构"><span class="nav-number">4.</span> <span class="nav-text">设计基于锁的并发数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#细粒度的锁，更高的并发度"><span class="nav-number">4.1.</span> <span class="nav-text">细粒度的锁，更高的并发度</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fengcun Li"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Fengcun Li</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">123</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fengcun Li</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  











<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
