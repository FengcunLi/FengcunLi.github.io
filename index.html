<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    

    <!--Author-->
    
        <meta name="author" content="Robert Lexis">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="This is Robert Lexis."/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="This is Robert Lexis."/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>This is Robert Lexis.</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">This is Robert Lexis.</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/03/14/Perfect-forward/">
                Perfect forward
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-03-14</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) move(T&amp;&amp; param)</div><div class="line">&#123;</div><div class="line">   <span class="keyword">using</span> return_type = <span class="built_in">std</span>::remove_reference&lt;T&gt;::type&amp;&amp;;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;return_type&gt;(param);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>于是，我们可以看见这里面的逻辑其实是无论你的 param 是何种类型，都会被强制转为右值引用类型。而唯一需要注意的是模版这里的 <code>T&amp;&amp;</code> 类型，Meyers 把这样的类型叫做 Universal Reference。对于 Universal Reference 来说，若你传递的 param 是一个左值，那么 T 将会被 deduce 成 Lvalue Reference（左值引用），Param Type 也是左值引用。若你传递进来的 param 是右值，那么 T 则是正常的 param 类型，如 int 等，其 Param Type 结果是 T&amp;&amp;。</p>
<p>举一个简单的例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(T&amp;&amp; param)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> i = <span class="number">7</span>;</div><div class="line">foo(i);</div><div class="line">foo(<span class="number">47</span>);</div></pre></td></tr></table></figure></p>
<p>i 是一个左值，于是 T 被 deduce 成 int&amp;，于是变为了foo(int&amp; &amp;&amp;); 而整个参数的结果类型，即 Param Type 为 int&amp;，C++不允许 reference to reference，会进行引用折叠，这也是后面谈到的forward的核心。而对于foo(47)，由于47是右值，那么 T 被正常 deduce 成 int，于是变为了 foo(int &amp;&amp;);</p>
<h3 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp; param)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么这里面是如何达到完美转发的呢？举一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(T&amp;&amp; fparam)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">std</span>::forward&lt;T&gt;(fparam);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> i = <span class="number">7</span>;</div><div class="line">foo(i);</div><div class="line">foo(<span class="number">47</span>);</div></pre></td></tr></table></figure></p>
<p>如上文所述，这里的 i 是一个左值，于是，我们在 void foo(T&amp;&amp; fparam) 这里的话，T 将会被 deduce 成 int&amp; 然后 Param Type 为 int&amp;。那么为什么Param Type会是int&amp;呢？因为按照正常的 deduce，我们将会得到 void foo(int&amp; &amp;&amp;fparam); C++不允许 reference to reference，Param Type int&amp; &amp;&amp; 被折叠为左值引用。<br>T 为 int&amp;，经过了 remove_reference 变为了 int，结合后面跟上的 &amp;，则变为了int &amp;。然后我们再次替换 static_cast和return type的T为int&amp;，都得到了 int&amp; &amp;&amp;：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span>&amp; &amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">int</span>&amp; param)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&amp; &amp;&amp;&gt;(param);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>于是再应用引用折叠规则，int&amp; &amp;&amp;都折叠为 int&amp;：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">forward</span><span class="params">(<span class="keyword">int</span>&amp; param)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(param);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>于是，我们可以发现 fparam 变量的左值引用类型被保留了下来。这里也需要注意，我们到达 forward 的时候就已经是左值引用了，所以 forward 并没有改变什么。</p>
<p>如我们这时候是 47 这样的右值，我们知道了 T 会被 deduce 成 int，经过了 remove_reference，变为了 int，跟上后面的 &amp;，成为了 int&amp;，然后再次替换 static_cast 和返回类型的 T 为 int&amp;&amp;:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> &amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">int</span>&amp; param)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&amp;&amp;)(param);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>于是，我们也可以发现，fparam 由右值出发，移动构造变为右值引用（一个左值），传入 forward 做转型，然后得到依然是一个右值，因此这个右值可以接着传入另外一个函数。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp; param)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(param);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>forward 时 <code>forward</code> 的参数类型都是 int &amp;，只不过由于 T 推导出来的类型可能为 int 或者 int &amp;，而导致传出来的是两种不同的引用类型（都是引用，都没有构造函数的调用），int&amp;&amp; 或者 int&amp;。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/03/14/Move-semantic-perfect-forward/">
                Move semantic & perfect forward
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-03-14</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="移动语义（move-semantic）和完美转发（perfect-forward）"><a href="#移动语义（move-semantic）和完美转发（perfect-forward）" class="headerlink" title="移动语义（move semantic）和完美转发（perfect forward）"></a>移动语义（move semantic）和完美转发（perfect forward）</h2><p>新标准重新定义了 <code>lvalue</code>和<code>rvalue</code>，并允许函数依照这两种不同的类型进行重载。通过对于右值的重新定义，语言实现了移动语义和完美转发，通过这种方法，C++在保留原有的语法、不改动已存在的代码的基础上提升了代码的性能。</p>
<h3 id="移动语义解决了什么问题"><a href="#移动语义解决了什么问题" class="headerlink" title="移动语义解决了什么问题"></a>移动语义解决了什么问题</h3><p>我们先看一段代码。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> * arr&#123;<span class="literal">nullptr</span>&#125;;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Test():arr(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5000</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;) &#123;</div><div class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"default constructor"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    Test(<span class="keyword">const</span> Test &amp; t) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"copy constructor"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">if</span> (arr == <span class="literal">nullptr</span>) arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5000</span>];</div><div class="line">        <span class="built_in">memcpy</span>(arr, t.arr, <span class="number">5000</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line">    &#125;</div><div class="line">    ~Test()&#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"destructor"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">delete</span> [] arr;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在类中我们定义了一个整型数组 arr，它一共有 5000 个元素。考虑到我们可以使用一个已有的 Test 对象来初始化一个新的 Test 对象，我们实现了拷贝构造函数。</p>
<p>接下来，我们考虑一个这样的应用场景：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    Test reusable;</div><div class="line">    <span class="comment">// do something to reusable</span></div><div class="line">    <span class="function">Test <span class="title">duplicated</span><span class="params">(reusable)</span></span>;</div><div class="line">    <span class="comment">// do something to reusable</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们创建了一个 reusable 变量并对其做了某一些操作，之后我们使用这个更改过的 reusable 变量初始化一个 duplicated 变量，在对其进行初始化之后，我们依然需要对 reusable 做其他的操作。在这个情境下，reusable 和 duplicated 变量各自有自己的用处，在这个情境下，我们的拷贝构造函数是合情合理的。</p>
<p>现在我们考虑另外一个场景：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">Test <span class="title">createTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Test();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    Test t(createTest());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个场景当中，我们需要使用一个工厂函数来构造 Test 的实例。那么在这个场景下，我们的拷贝构造函数被调用了 2 次。这两次调用相当于复制了 10000 个元素，是一个不小的开销。可是这个开销有意义吗？我们知道，在工厂函数中建立的 Test 实例在函数返回后就会被析构，而用于返回值的 Test 的临时实例也会在将值赋给 t 之后被析构。也就是说，这两个临时对象事实上并没有什么意义。由于构造他们而产生的复制的开销其实完全没有必要（事实上，编译器一般会对这种情况进行 (N)RVO，但不见得每次都能很好的优化）。所以我们就在考虑，有没有可能我们可以将在工厂函数中构造的对象的成员变量的那块内存“偷”过来，而不是重新开辟一块内存，然后再将之前的内容复制过来呢？</p>
<h3 id="移动语义（move-semantic）"><a href="#移动语义（move-semantic）" class="headerlink" title="移动语义（move semantic）"></a>移动语义（move semantic）</h3><p>移动语义就是为了解决上面的这种问题而产生的。通过移动语义，我们可以在没有必要的时候避免复制。那么在接下来，我们就重点来谈一谈移动构造函数（move constructor）。相信到这里你已经意识到了，移动构造函数的出现就是为了解决拷贝构造函数的这个弊病。所以，其实移动构造函数应该和拷贝构造函数实现差不多的功能。那么，它也应该是一种构造函数的重载，所以，我们可以想象出来，其实移动构造函数大概就会是这个样子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Test(&lt;KEYWORD&gt; t):arr(t.arr)&#123;t.arr = <span class="literal">nullptr</span>;&#125;</div></pre></td></tr></table></figure></p>
<p>通过移动构造函数，事实上我们是做了一个浅拷贝（shallow copy）。至于要将之前的指针置为空的原因在于，我们的类会在析构的时候 delete 掉我们的数组。那么我们浅拷贝出来的这个对象的成员变量（arr指针）就变成了一个悬挂指针（dangling pointer）。</p>
<p>现在的问题变成了，这个<keyword>究竟是什么？编译器如何自动判断到底应该调用拷贝构造函数还是移动构造函数呢？</keyword></p>
<h4 id="左值（lvalue）、右值（rvalue）、左值引用（lvalue-reference）和右值引用（rvalue-reference）"><a href="#左值（lvalue）、右值（rvalue）、左值引用（lvalue-reference）和右值引用（rvalue-reference）" class="headerlink" title="左值（lvalue）、右值（rvalue）、左值引用（lvalue reference）和右值引用（rvalue reference）"></a>左值（lvalue）、右值（rvalue）、左值引用（lvalue reference）和右值引用（rvalue reference）</h4><p>C++ 定义了与 C 不相同的左值和右值的判断方法，不过说起来非常简单：凡是真正的存在内存当中，而不是寄存器当中的值就是左值，其余的都是右值。其实更通俗一点的说法就是：凡是取地址（&amp;）操作可以成功的都是左值，其余都是右值。<br>在明确了左值和右值的关系之后，左值引用而右值引用的概念也就显而易见了。对于左值的引用就是左值引用，而对于右值的引用就是右值引用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; i)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"const int &amp; "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> &amp; i)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"int &amp; "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> &amp;&amp; i)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"int &amp;&amp; "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;&amp; i)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"const int &amp;&amp; "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; &#125; <span class="comment">// 这是个奇葩</span></div></pre></td></tr></table></figure></p>
<p>我们在以往使用的时候大多会使用第一种形式。其实，第一种形式是一种神奇的形式，因为 <code>const int &amp;</code> 既可以绑定左值，也可以绑定右值。所以在没有后面三个重载函数的情况下，我们调用一下语句：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</div><div class="line">foo(i);</div><div class="line">foo(<span class="number">2</span>);</div></pre></td></tr></table></figure></p>
<p>他们的输出都是 <code>const int &amp; 2</code>。而如果在只有第二个函数而没有其他函数的时候，第三条语句是违法的。在只有第三个函数没有其它函数的时候，第二条语句是违法的。<br>所以我们总结一下：const reference可以绑定所有的值，而其他类型的引用只能绑定自己类型的值。在这四种函数都存在的情况下，每一种函数都会绑定与自己最接近的那个值。也就是说，在四个函数都存在的情况下，当我们再次运行上面的这段代码，输出的结果就将变成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int &amp; 2</div><div class="line">int &amp;&amp; 2</div></pre></td></tr></table></figure></p>
<p>回到之前的问题，现在我们可以知道上面那个Test类当中的神奇的<keyword>到底是什么了。其实就是 <code>Test &amp;&amp;</code>。由于左值和右值是两种不同的类型，所以可以依照这个类型进行重载。所以我们的Test类就变成了这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> * arr&#123;<span class="literal">nullptr</span>&#125;;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Test():arr(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5000</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;) &#123;</div><div class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"default constructor"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    Test(<span class="keyword">const</span> Test &amp; t) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"copy constructor"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">if</span> (arr == <span class="literal">nullptr</span>) arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5000</span>];</div><div class="line">        <span class="built_in">memcpy</span>(arr, t.arr, <span class="number">5000</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</div><div class="line">    &#125;</div><div class="line">    Test(Test &amp;&amp; t): arr(t.arr) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"move constructor"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        t.arr = <span class="literal">nullptr</span>;</div><div class="line">    &#125;</div><div class="line">    ~Test()&#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"destructor"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">delete</span> [] arr;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></keyword></p>
<p>所以，当我们再次考虑下面这个应用场景的时候：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">Test <span class="title">createTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Test();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    Test t(createTest());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们会发现，打印的结果变成了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">default constructor</div><div class="line">move constructor</div><div class="line">destructor</div><div class="line">move constructor</div><div class="line">destructor</div><div class="line">destructor</div></pre></td></tr></table></figure></p>
<p>也就是说，我们的 Test 实例在工厂函数中使用默认构造函数（default constructor）构造一次之后，调用的全部都是移动构造函数，因为我们发现其实所有的这些值都是右值。这极大地节省了开支。</p>
<p>这里有一个编译器的 trick。gcc是一个丧心病狂的编译器，他会强制进行 (N)RVO。如果你不做任何设置直接用GCC编译运行上面的代码，你将看到的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">default constructor</div></pre></td></tr></table></figure></p>
<p>这个时候不要怀疑我上面说的东西有问题或者你写错了。请直接在 gcc 后面添加编译参数<code>-fno-elide-constructors</code>。所以整个的编译语句应该是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g++ -std=c++11 -fno-elide-constructors test.cpp # for instance</div></pre></td></tr></table></figure></p>
<p>移动语义再多说几句，现在我们再来看看一开始那个reusable的例子。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    Test reusable;</div><div class="line">    <span class="comment">// do something to reusable</span></div><div class="line">    <span class="function">Test <span class="title">duplicated</span><span class="params">(reusable)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果现在我们不想复制 reusable 了，我们想在构造 duplicated 的时候也使用移动构造函数，那么应该怎么做呢？新标准给我们提供了一个解决方案：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Test duplicated(std::move(reusable));</div></pre></td></tr></table></figure></p>
<p>这个 <code>std::move()</code> 的作用是将左值转换为右值。不过这里要注意的一点是，如果我们在这里使用了 move 的话，那么后面我们就不能再对 reusable 进行操作了。因为移动构造函数已经将 reusable 的成员变量 arr 指针置为空了。</p>
<p>讲解完了移动构造函数，其实移动赋值语句（move assignment）与之同理。由于STL已经默认对所有的代码进行了右值引用的改写，所以现在当你运行你之前写过的代码时，你不需要做任何的更改，就会发现似乎更快了一些。</p>
<h3 id="进一步探讨左值和右值"><a href="#进一步探讨左值和右值" class="headerlink" title="进一步探讨左值和右值"></a>进一步探讨左值和右值</h3><p>我们来考虑下面的情景：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(TYPE&amp;&amp; param)</span> </span>&#123;</div><div class="line">    <span class="comment">// ops and expressions using std::move(param)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个代码是从 Scott Meyers 的演讲当中摘取的。现在的问题是：<strong>param是右值吗？</strong> 答案是：不！param是一个左值。</p>
<p>这里牵扯到一个概念，即事实上左值和右值与类型是没有关系的，即 int 既可以是左值，也可以是右值。区别左值和右值的唯一方法就是其定义，即能否取到地址。在这里，我们明显可以对 param 进行取地址操作，所以它是一个左值，只不过它的类型是 <code>TYPE&amp;&amp;</code>。也就是说，但凡有名字的“右值”，其实都是左值。</p>
<h3 id="完美转发（perfect-forward）又是在做什么"><a href="#完美转发（perfect-forward）又是在做什么" class="headerlink" title="完美转发（perfect forward）又是在做什么"></a>完美转发（perfect forward）又是在做什么</h3><p>我们依然考虑一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"in func"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">relay</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"in relay"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    func(t);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    relay(Test());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个例子当中，我们的期待是，我们在main当中调用 relay，Tes t的临时对象作为一个右值传入 relay，在 relay 当中又被转发给了 func，那这时候转发给 func 的参数 t 也应当是一个右值。也就是说，我们希望：当 relay 的参数是右值的时候，func 的参数也是右值；当 relay 的参数是左值的时候，func 的参数也是左值。</p>
<p>那么现在我们来运行一下这个程序，我们会看到，结果与我们预想的似乎并不相同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">default constructor</div><div class="line">in relay</div><div class="line">copy constructor</div><div class="line">in func</div><div class="line">destructor</div><div class="line">destructor</div></pre></td></tr></table></figure></p>
<p>我们看到，在 relay 当中转发的时候，调用了拷贝构造函数，也就是说编译器认为这个参数 t 并不是一个右值，而是左值。这个的原因已经在上一节将结果了，因为它有一个名字。那么如果我们想要实现我们所说的，如果传进来的参数是一个左值，则将它作为左值转发给下一个函数；如果它是右值，则将其作为右值转发给下一个函数，我们应该怎么做呢？</p>
<p>这时，我们需要 <code>std::forward&lt;T&gt;()</code>。与<code>std::move()</code> 相区别的是，<code>move()</code>会无条件的将一个参数转换成右值，而 <code>forward()</code> 则会保留参数的左右值类型。所以我们的代码应该是这样：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"in func "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">relay</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"in relay "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    func(<span class="built_in">std</span>::forward&lt;T&gt;(t));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在运行的结果就成为了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">default constructor</div><div class="line">in relay</div><div class="line">move constructor</div><div class="line">in func</div><div class="line">destructor</div><div class="line">destructor</div></pre></td></tr></table></figure></p>
<p>而如果我们的调用方法变成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    Test t;</div><div class="line">    relay(t);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么输出就会变成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">default constructor</div><div class="line">in relay</div><div class="line">copy constructor</div><div class="line">in func</div><div class="line">destructor</div><div class="line">destructor</div></pre></td></tr></table></figure></p>
<p>完美地实现了我们所要的转发效果。</p>
<h3 id="通用引用（universal-reference）"><a href="#通用引用（universal-reference）" class="headerlink" title="通用引用（universal reference）"></a>通用引用（universal reference）</h3><p>现在一定有同学感到奇怪了，既然我刚才讲的完美转发就是怎么传进来怎么传给别人，那么也就是说在后面这个例子当中我们传进来的这个参数 t 竟然是一个左值！可是我们的参数表里不是写着 T&amp;&amp;，要求接受一个右值吗？其实不是这样的。这里就牵扯到一个新的概念，叫做通用引用。</p>
<p>通用引用（universal reference）是 Scott Meyers 在 C++ and Beyond 2012 演讲中自创的一个词，用来特指一种引用的类型。构成通用引用有两个条件：</p>
<ul>
<li>必须满足 <code>T&amp;&amp;</code> 这种形式</li>
<li>类型T必须是通过推断得到的</li>
</ul>
<p>所以，在我们完美转发这个部分的例子当中，我们所使用的这种引用，其实是通用引用，而不是所谓的单纯的右值引用。因为我们的函数是模板函数，T的类型是推断出来的，而不是指定的。那么相应的，如果有一段这样的代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> &#123;</span></div><div class="line">    <span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;&#125; <span class="comment">//这个T&amp;&amp;是不是一个通用引用呢</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的这个 T 是不是通用引用呢？答案: <strong>不是</strong>。因为当这个类初始化的时候这个 T 就已经被确定了，不需要推断。</p>
<p>所以，可以构成通用引用的有如下几种可能:</p>
<ul>
<li><p>函数模板参数（function template parameters）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</div></pre></td></tr></table></figure>
</li>
<li><p>auto声明（auto declaration）auto &amp;&amp; var = …;</p>
</li>
<li>typedef声明（typedef declaration）</li>
<li>decltype声明（decltype declaration）</li>
</ul>
<p>那么，这个通用引用与其他的引用有什么区别呢？其实最重要的一点就是引用类型折叠（Reference Collapsing Rules）。规则很简单：</p>
<ul>
<li>T&amp; &amp; =&gt; T&amp;</li>
<li>T&amp;&amp; &amp; =&gt; T&amp;</li>
<li>T&amp; &amp;&amp; =&gt; T&amp;</li>
<li>T&amp;&amp; &amp;&amp; =&gt; T&amp;&amp;</li>
</ul>
<p>注意，这个折叠规则用户是不允许使用的，只有编译器才能够使用这种合成规则。这就是为什么上面的通用引用当中有一条要求是类型必须可以自动推导。这个折叠规则其实就是类型推导的规则之一。</p>
<p><strong>这样，我们就可以知道为什么 Scott Meyers 在演讲中建议大家在通用引用的情境下，尽可能使用 forward()了，因为这样可以在不改变语义的情况下提升性能。</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T&amp;&amp; param)</span> </span>&#123;</div><div class="line">	<span class="comment">// ops and expressions using std::forward&lt;T&gt;(param)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>C++0x 通过引入许多新的语言特性来实现了语言性能的提升，使得本来就博大精深的一门语言变得更加的难以学习。但是一旦了解，就会被语言精妙的设计所折服。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/03/14/RAII-smart-pointer/">
                RAII & smart pointer
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-03-14</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h3><p>RAII 全称为 <em>Resource Acquisition Is Initialization</em>，1984-1989 年期间，比雅尼·斯特劳斯特鲁普和安德鲁·柯尼希在设计 C++ 异常时，为解决<strong>资源管理</strong>时的<strong>异常安全性</strong>而使用了 <strong>RAII</strong>。</p>
<p>RAII要求，资源的有效期与持有资源的对象的生命期严格绑定，即由对象的构造函数完成资源的获取，由析构函数完成资源的释放，在这种要求下，只要对象能正确地析构，就不会出现资源泄露问题。</p>
<p>C++ 保证了所有<strong>栈对象</strong>在生命周期结束时都会被销毁，无论是否发生了异常。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_to_file</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; message)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">// 创建关于文件的互斥锁</span></div><div class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mutex mutex;</div><div class="line">    <span class="comment">// 在访问文件前进行加锁</span></div><div class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(mutex);</div><div class="line">    <span class="comment">// 尝试打开文件</span></div><div class="line">    <span class="built_in">std</span>::<span class="function">ofstream <span class="title">file</span><span class="params">(<span class="string">"example.txt"</span>)</span></span>;</div><div class="line">    <span class="keyword">if</span> (!file.is_open())</div><div class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"unable to open file"</span>);</div><div class="line"></div><div class="line">    file &lt;&lt; message &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 当离开作用域时，文件句柄会被首先析构 (不管是否抛出了异常)</span></div><div class="line">    <span class="comment">// lock 也会被析构 (不管是否抛出了异常)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>无论在 <code>write_to_file</code> 函数正常返回，还是在途中抛出了异常，都会引发 <code>write_to_file</code> 函数的<em>栈回退</em>，而此时会<strong>依次</strong>自动调用 <code>file</code> 和 <code>lock</code> 对象的析构函数。此处借由 RAII 思想管理的资源是互斥锁 <code>mutex</code>，<code>lock</code> 的构造和析构保证了互斥锁的获取和释放。</p>
<p>由于 RAII 可以极大地简化资源管理，并有效地保证程序的正确和代码的简洁，所以通常会强烈建议在 C++ 中使用它。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Mutex</span>&gt; <span class="title">class</span> <span class="title">lock_guard</span> &#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    Mutex&amp; mutex_;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    lock_guard(Mutex&amp; mutex) : mutex_(mutex) &#123; mutex_.lock(); &#125;</div><div class="line">    ~lock_guard() &#123; mutex_.unlock(); &#125;</div><div class="line"></div><div class="line">    lock_guard(lock_guard <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</div><div class="line">    lock_guard&amp; <span class="keyword">operator</span>=(lock_guard <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>程序员可以非常方便地使用 <code>lock_guard</code>，而不用担心异常安全性问题<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">unsafe_code</span><span class="params">()</span></span>;  <span class="comment">// 可能抛出异常</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::mutex;</div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::lock_guard;</div><div class="line"></div><div class="line">mutex g_mutex;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">access_critical_section</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    lock_guard&lt;mutex&gt; lock(g_mutex);</div><div class="line">    unsafe_code();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>C++</code> 标准库的实现广泛应用了 RAII，典型的如容器、智能指针等。</p>
<h3 id="Smart-Pointer"><a href="#Smart-Pointer" class="headerlink" title="Smart Pointer"></a>Smart Pointer</h3><p>在内存资源管理中，程序员有义务对动态分配的内存进行释放，即谁申请谁释放，并且 <code>delete</code> 掉一个指针之后，最好马上将其赋值为 <code>NULL</code>（避免使用悬垂指针）。这个过程繁杂极易出错。由 RAII 的思想，可以将资源的有效期和管理对象的生命期进行严格绑定，通过对象的构造和析构完成资源的获取和释放。</p>
<h4 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; ptr_1(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Hello, auto_ptr!"</span>));</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The content is: "</span> &lt;&lt; *ptr_1 &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ptr_1</code> 仅仅就是一个对象，只不过这个对象用起来就像一个指针一样，<code>new string(&quot;Hello, auto_ptr!&quot;)</code> 资源的有效期和管理对象 <code>ptr_1</code> 的生命期进行严格绑定，在 <code>ptr_1</code> 析构时会完成资源的释放。</p>
<p>在 C++11 标准中，<code>auto_ptr</code> 已经被弃用了，这是因为：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; ptr_1(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Hello, auto_ptr!"</span>));</div><div class="line">    <span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; ptr_2;</div><div class="line">    ptr_2 = ptr_1;</div><div class="line"></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr_2: "</span> &lt;&lt; *ptr_2 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// OK</span></div><div class="line">    <span class="comment">// cout &lt;&lt; "ptr_1: " &lt;&lt; *ptr_1 &lt;&lt; endl; // Error</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了避免重复析构问题，当发生<strong>拷贝构造/拷贝赋值</strong>时，源智能指针对象内的指针会被赋值为 <code>NULL</code>; 这就出现了语义冲突，此处的<strong>拷贝语义</strong>实际上发生的是 C++11 新引进的 move 语义对应的操作，这也无可厚非，毕竟在 <code>auto_ptr</code> 引入之时，C++ 中并没有右值引用来支持移动语义，就只能用拷贝语义来错误的将就。</p>
<h4 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h4><p><code>unique_ptr</code> 是 <code>auto_ptr</code> 的替代者，它实现了移动语义，禁止了拷贝语义。被管理的资源的所有权只有一份，可以在 <code>unique_ptr</code> 对象之间转移。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; ptr_1(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Hello, unique_ptr!"</span>));</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr_1 is: "</span> &lt;&lt; *ptr_1 &lt;&lt; <span class="string">", ptr value is: "</span> &lt;&lt; ptr_1.get() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="comment">// unique_ptr&lt;string&gt; ptr_2(ptr_1);     // 编译将会出错！因为禁止拷贝构造</span></div><div class="line">    <span class="comment">// unique_ptr&lt;string&gt; ptr_2</span></div><div class="line">    <span class="comment">// ptr_2 = ptr_1;    // 编译将会出错！因为禁止拷贝赋值</span></div><div class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; ptr_2 = <span class="built_in">std</span>::move(ptr_1); <span class="comment">// 调用移动构造函数</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr_1 is: "</span> &lt;&lt; ptr_1.get() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr_2 is: "</span> &lt;&lt; *ptr_2 &lt;&lt; <span class="string">", ptr value is: "</span> &lt;&lt; ptr_2.get() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ptr_1 is: Hello, unique_ptr!, ptr value is: 0x1d8dc20</div><div class="line">ptr_1 is: 0</div><div class="line">ptr_2 is: Hello, unique_ptr!, ptr value is: 0x1d8dc20</div></pre></td></tr></table></figure></p>
<p>使用 <code>unique_ptr</code>，可以实现以下功能：</p>
<ol>
<li>为动态申请的内存提供异常安全</li>
<li>将动态申请内存的所有权传递给某个函数</li>
<li>从某个函数返回动态申请内存的所有权</li>
</ol>
<h4 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h4><p>引用计数！每次有一个 <code>shared_ptr</code> 关联到某个对象上时，计数值就加上 <code>1</code>；相反，每次有一个 <code>shared_ptr</code> 析构时，相应的计数值就减去 <code>1</code>。当计数值减为 <code>0</code> 的时候，就执行对象的析构函数，此时该对象才真正被析构！多个 <code>shared_ptr</code> 指向同一个动态对象，并维护了一个共享的引用计数器，记录了引用同一对象的 <code>shared_ptr</code> 实例的数量。当最后一个指向动态对象的 <code>shared_ptr</code> 销毁时，会自动销毁其所指对象。<br>基本操作：</p>
<ol>
<li>绑定对象的变更(reset)</li>
<li>shared_ptr 的销毁(手动赋值为 nullptr 或离开作用域)</li>
<li>指定deleter</li>
</ol>
<p><code>shared_ptr</code> 的创建，有两种方式：</p>
<ol>
<li>使用函数 make_shared</li>
<li>使用构造函数(可从原生指针、unique_ptr、另一个 shared_ptr 创建)<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>));</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; ptr_1(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Hello, shared_ptr!"</span>));</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; ptr_2 = ptr_1;</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; ptr_3(ptr_1);</div><div class="line"></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Count is: "</span> &lt;&lt; ptr_1.use_count() &lt;&lt; <span class="string">", "</span></div><div class="line">    &lt;&lt; ptr_2.use_count() &lt;&lt; <span class="string">", "</span> &lt;&lt; ptr_3.use_count() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr_1 is: "</span>  &lt;&lt; ptr_1.get() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr_2 is: "</span> &lt;&lt; ptr_2.get() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr_3 is: "</span> &lt;&lt; ptr_3.get() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; ptr_4 = <span class="built_in">std</span>::move(ptr_1);</div><div class="line"></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Count is: "</span> &lt;&lt; ptr_1.use_count() &lt;&lt; <span class="string">", "</span></div><div class="line">    &lt;&lt; ptr_2.use_count() &lt;&lt; <span class="string">", "</span> &lt;&lt; ptr_3.use_count() &lt;&lt; <span class="string">", "</span> &lt;&lt; ptr_4.use_count() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr_1 is: "</span> &lt;&lt; ptr_1.get() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr_4 is: "</span>  &lt;&lt; ptr_4.get() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Count is: 3, 3, 3</div><div class="line">ptr_1 is: 0x1210c20</div><div class="line">ptr_2 is: 0x1210c20</div><div class="line">ptr_3 is: 0x1210c20</div><div class="line"></div><div class="line">Count is: 0, 3, 3, 3</div><div class="line">ptr_1 is: 0</div><div class="line">ptr_4 is: 0x1210c20</div></pre></td></tr></table></figure></p>
<h4 id="shared-ptr-循环引用"><a href="#shared-ptr-循环引用" class="headerlink" title="shared_ptr 循环引用"></a>shared_ptr 循环引用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; ptr;</div><div class="line"></div><div class="line">    ~A() &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"kill A\n"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; ptr;</div><div class="line"></div><div class="line">    ~B() &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"kill B\n"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; ptr_1(<span class="keyword">new</span> A());</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; ptr_2(<span class="keyword">new</span> B());</div><div class="line">    <span class="keyword">if</span> (ptr_1 &amp;&amp; ptr_2) &#123;</div><div class="line">        ptr_1-&gt;ptr = ptr_2;</div><div class="line">        ptr_2-&gt;ptr = ptr_1;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr_1 use count:"</span> &lt;&lt; ptr_1.use_count() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr_2 use count:"</span> &lt;&lt; ptr_2.use_count() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ptr_1 use count:2</div><div class="line">ptr_2 use count:2</div></pre></td></tr></table></figure></p>
<p>注意没有 kill A 与 kill  B，即动态对象没有被析构。<br><img src="/2019/03/14/RAII-smart-pointer/circular.png" alt="circular"></p>
<h4 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h4><p>结合 <code>shared_ptr</code> 使用的特殊智能指针。<code>weak_ptr</code> 不参与引用计数，不影响动态对象的生命期，即其存在与否并不影响对象的引用计数器。<code>weak_ptr</code> 并没有重载 <code>operator-&gt;</code> 和 <code>operator *</code> 操作符，因此不可直接通过 <code>weak_ptr</code> 使用对象，提供了 <code>expired()</code> 与 <code>lock()</code> 成员函数，前者用于判断 <code>weak_ptr</code> 指向的对象是否已被销毁，后者返回其所指对象的 <code>shared_ptr</code> 智能指针(对象销毁时返回”空” <code>shared_ptr</code>)。循环引用的场景：如二叉树中父节点与子节点的循环引用，容器与元素之间的循环引用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; ptr;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say_hello</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ~B() &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"kill B\n"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    weak_ptr&lt;B&gt; ptr;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="built_in">shared_ptr</span>&lt;B&gt; tmp_ptr = ptr.lock();</div><div class="line">        <span class="keyword">if</span> (tmp_ptr) &#123;</div><div class="line">            tmp_ptr-&gt;say_hello();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ~A() &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"kill A\n"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;A&gt; ptr_1(<span class="keyword">new</span> A());</div><div class="line">    <span class="built_in">shared_ptr</span>&lt;B&gt; ptr_2(<span class="keyword">new</span> B());</div><div class="line">    <span class="keyword">if</span> (ptr_1 &amp;&amp; ptr_2) &#123;</div><div class="line">        ptr_1-&gt;ptr = ptr_2;</div><div class="line">        ptr_2-&gt;ptr = ptr_1;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr_1 use count:"</span> &lt;&lt; ptr_1.use_count() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ptr_2 use count:"</span> &lt;&lt; ptr_2.use_count() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    ptr_1-&gt;do_something();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="/2019/03/14/RAII-smart-pointer/circular-2.png" alt="circular-2"><br>输出为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ptr_1 use count:2</div><div class="line">ptr_2 use count:1</div><div class="line">Hello</div><div class="line">kill B</div><div class="line">kill A</div></pre></td></tr></table></figure></p>
<p>在此种情况下，依次进行如下的析构：</p>
<ol>
<li>ptr_2</li>
<li>B</li>
<li>B.ptr</li>
<li>ptr_1</li>
<li>A</li>
<li>A.ptr</li>
</ol>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/03/13/Leetcode/">
                Leetcode
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-03-13</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="递归、回溯、分治"><a href="#递归、回溯、分治" class="headerlink" title="递归、回溯、分治"></a>递归、回溯、分治</h3><h4 id="Subset"><a href="#Subset" class="headerlink" title="Subset"></a>Subset</h4><ol>
<li>Subset I<ul>
<li>backtracking &amp;path &amp;result</li>
<li>位运算法 000～111 001 010 100</li>
</ul>
</li>
<li>Subset II<ul>
<li>sort、remove duplications</li>
</ul>
</li>
<li>Combination sum II<ul>
<li>剪枝 backtracking &amp;current_sum</li>
</ul>
</li>
<li>Generate parentheses<br> insight：只有在左括号多于右括号的时候才能放置右括号。left_remaining、right_remaining.</li>
<li>N-Queues<br> 二维方向数组在平面搜索问题中可以简化代码，比一堆 if-else 要优雅的多</li>
<li>Count of smaller numbers after self<br> 逆序数<br> O(n**2) 复杂度的算法很容易得出。<br> 得出 O(nlogn) 复杂度的算法：merge sort 或者 binary search tree 构建过程</li>
</ol>
<h3 id="栈、队列、堆"><a href="#栈、队列、堆" class="headerlink" title="栈、队列、堆"></a>栈、队列、堆</h3><ol>
<li>用队列实现栈 <strong>push</strong></li>
<li>用栈实现队列 <strong>push</strong></li>
<li>包含 min 函数的栈</li>
<li>合法的出栈序列</li>
<li>简单的计算器 Basic calculator</li>
<li>Kth largest element in an array 第 K 大的数</li>
<li>数据流中的中位数</li>
</ol>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><ol>
<li>分糖果</li>
<li>摇摆序列</li>
<li>移除 K 个数字</li>
<li>跳跃游戏</li>
<li>跳跃游戏 II</li>
<li>射击气球</li>
<li>最佳加油方法</li>
</ol>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2019/03/13/Move-semantic/">
                Move semantic
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2019-03-13</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>左值和右值是表达式的属性，一些表达式生成或者需要左值，另外一些表达式生成或者需要右值，一般而言，一个左值表达式表示一个对象的身份，一个右值表达式则表示一个对象的值。</p>
<ul>
<li>返回左值引用的函数，赋值、下标、解引用、前置递增、前置递减，这些返回左值</li>
<li>返回非引用的函数，算术、关系、位、后置递增、后置递减，这些返回右值</li>
</ul>
<p>为了支持移动操作，C++11 引入了一种新的引用类型——右值引用（rvalue reference）。所谓右值引用是指<strong>只能</strong>绑定到右值的引用，一个右值引用类似于左值引用，也不过是某个对象的另外一个名字而已，通过 <code>&amp;&amp;</code> 来标识一个右值引用。我们只能将左值引用绑定到左值上（const 左值引用可以绑定到右值上），只能将右值引用绑定到右值上。<br></p>
        </div>
        <a href="/2019/03/13/Move-semantic/" class="read-more">Read More</a>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/11/21/C-Concurrency-In-Action/">
                C++ Concurrency In Action
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-11-21</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="基本的线程管理"><a href="#基本的线程管理" class="headerlink" title="基本的线程管理"></a>基本的线程管理</h2><h4 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h4><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void do_some_work();</div><div class="line">std::thread my_thread(do_some_work);</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class background_task &#123;</div><div class="line">    public:</div><div class="line">        void operator() ()const &#123;</div><div class="line">            do_something();</div><div class="line">            do_something_else();</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line">background_task f;</div><div class="line">std::thread my_thread(f);</div></pre></td></tr></table></figure>
</li>
</ul>
        </div>
        <a href="/2018/11/21/C-Concurrency-In-Action/" class="read-more">Read More</a>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/09/03/Optimizers/">
                Optimizers
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-09-03</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="Batch-vs-mini-batch-gradient-descent"><a href="#Batch-vs-mini-batch-gradient-descent" class="headerlink" title="Batch vs. mini-batch gradient descent"></a>Batch vs. mini-batch gradient descent</h3><p>mini-batch gradient descent 可以加快训练过程，Batch gradient descent 是过一次整个训练集才更新一次参数。Too long per iteration（<br>一次更新就是一次迭代，一次迭代就是一次更新）.<br>one epoch: single pass through training set.</p>
<h5 id="Understanding-mini-batch-gradient-descent"><a href="#Understanding-mini-batch-gradient-descent" class="headerlink" title="Understanding mini-batch gradient descent"></a>Understanding mini-batch gradient descent</h5><ul>
<li>Batch gradient descent cost 一定是单调递减的，如果不是，有可能是学习率太大了，导致发散了。</li>
<li>mini-batch gradient descent noisy</li></ul>
        </div>
        <a href="/2018/09/03/Optimizers/" class="read-more">Read More</a>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/08/28/Tensorflow-模型浮点数计算量和参数量统计/">
                TensorFlow 模型浮点数计算量和参数量统计
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-08-28</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>本博文整理了如何对一个 TensorFlow 模型的浮点数计算量（FLOPs）和参数量进行统计。<br>stats_graph.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">stats_graph</span><span class="params">(graph)</span>:</span></div><div class="line">    flops = tf.profiler.profile(graph, options=tf.profiler.ProfileOptionBuilder.float_operation())</div><div class="line">    params = tf.profiler.profile(graph, options=tf.profiler.ProfileOptionBuilder.trainable_variables_parameter())</div><div class="line">    print(<span class="string">'FLOPs: &#123;&#125;;    Trainable params: &#123;&#125;'</span>.format(flops.total_float_ops, params.total_parameters))</div></pre></td></tr></table></figure></p>
        </div>
        <a href="/2018/08/28/Tensorflow-模型浮点数计算量和参数量统计/" class="read-more">Read More</a>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/08/26/YOLO/">
                YOLO
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-08-26</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="Sliding-Windows-滑动窗口"><a href="#Sliding-Windows-滑动窗口" class="headerlink" title="Sliding Windows 滑动窗口"></a>Sliding Windows 滑动窗口</h3><p>通过滑动窗口的方式在图像上生成一系列的 box，然后利用分类器对每个 box 进行分类，即可完成对图像中目标的检测。<br>基于滑动窗口的目标检测效率很低，因为我们需要对每个区域都进行预测，而且为了获得更加准确的结果，我们需要尝试各种不同尺寸的 box。</p>
<h3 id="Convolutional-Implementation-of-Sliding-Windows"><a href="#Convolutional-Implementation-of-Sliding-Windows" class="headerlink" title="Convolutional Implementation of Sliding Windows"></a>Convolutional Implementation of Sliding Windows</h3><p>这是一个加速的方法，共享计算。<br><img src="/2018/08/26/YOLO/cnn-slide.jpg" alt="cnn-slide"><br></p>
        </div>
        <a href="/2018/08/26/YOLO/" class="read-more">Read More</a>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/08/26/非最大值抑制/">
                非最大值抑制
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-08-26</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>非最大值抑制 Non-max Suppression 是目标检测（object detection）中常用的后处理（post processing）技术。<br>（Fast-， Faster-）RCNN，SSD，YOLO 等目标检测框架会对一个目标产生多个 bounding box 的预测结果，而我们最终需要的仅仅是最“合适”的那一个。<br>非最大值抑制就是用来去除（clean up）多余的 bounding box 的预测结果，确保对一个目标只输出一个检测结果。<br>概率最大的 bounding box 被保留，且该 bounding box 周围的与它有较大交并比的 bounding box 会被抑制。<br>Each output prediction is:<br>\[<br>    \left[<br>    \begin{matrix}<br>    p_c \\\\<br>    b_x \\\\<br>    b_y \\\\<br>    b_w \\\\<br>    b_h<br>    \end{matrix}<br>    \right]<br>\]<br></p>
        </div>
        <a href="/2018/08/26/非最大值抑制/" class="read-more">Read More</a>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="disabled" href="/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/2/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This is Robert Lexis (FengCun Li). To see the world, things dangerous to come to, to see behind walls, to draw closer, to find each other and to feel. That is the purpose of LIFE.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2019/03/14/Perfect-forward/">Perfect forward</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/03/14/Move-semantic-perfect-forward/">Move semantic &amp; perfect f</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/03/14/RAII-smart-pointer/">RAII &amp; smart pointer</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/03/13/Leetcode/">Leetcode</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/RobertLexis">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:robert_lexis@163.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Robert Lexis Loves Wenny
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>