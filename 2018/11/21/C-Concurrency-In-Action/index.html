<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="基本的线程管理启动线程
12void do_some_work();std::thread my_thread(do_some_work);

123456789class background_task &amp;#123;    public:        void operator() ()const &amp;#123;            do_something();            do_something_else();        &amp;#125;&amp;#125;;background_task f;std::thread my_thread(f);">
    

    <!--Author-->
    
        <meta name="author" content="Robert Lexis">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="C++ Concurrency In Action"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="This is Robert Lexis."/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>C++ Concurrency In Action - This is Robert Lexis.</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
    </div>
</header>

        <section class="main">
            
<div class="post">

    <div class="post-header">
        <h1 class="title">
            <a href="/2018/11/21/C-Concurrency-In-Action/">
                C++ Concurrency In Action
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-11-21</span>
            
            
            
        </div>
    </div>

    <div class="content">

        <!-- Gallery -->
        

        <!-- Post Content -->
        <h2 id="基本的线程管理"><a href="#基本的线程管理" class="headerlink" title="基本的线程管理"></a>基本的线程管理</h2><h4 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h4><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void do_some_work();</div><div class="line">std::thread my_thread(do_some_work);</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class background_task &#123;</div><div class="line">    public:</div><div class="line">        void operator() ()const &#123;</div><div class="line">            do_something();</div><div class="line">            do_something_else();</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line">background_task f;</div><div class="line">std::thread my_thread(f);</div></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<h5 id="C-’s-most-vexing-parse"><a href="#C-’s-most-vexing-parse" class="headerlink" title="C++’s most vexing parse"></a>C++’s most vexing parse</h5><p><code>std::thread my_thread(background_task());</code> 会被视为函数声明，而不是对象的定义。<br>可以通过两种方式进行避免</p>
<ol>
<li><code>std::thread my_thread((background_task()))</code></li>
<li>Using new uniform initialization syntax <code>std::thread my_thread{background_task()}</code></li>
</ol>
<p>一旦启动一个线程，需要显式地指定 wait for it (by joining with it) 或者 leave it to run on its own (by detaching it)。如果在 <code>std::thread</code> 对象被销毁之前，没有进行任何指定，则程序会被终止(std::thread destructor 会调用 std::terminate())。需要注意的是，你仅仅需要在 <code>std::thread</code> 对象被销毁之前进行指定即可，在你指定 join 或者 detach 之前，线程本身可能已经结束，或者如果你决定 detach it，线程可能在 <code>std::thread</code> 对象销毁之后仍然继续运行很长时间。</p>
<h5 id="确保线程访问的数据的有效性"><a href="#确保线程访问的数据的有效性" class="headerlink" title="确保线程访问的数据的有效性"></a>确保线程访问的数据的有效性</h5><p>If you don’t wait for your thread to finish, then you need to ensure that the data accessed by the thread is valid until the thread has finished with it.如果线程持有指向局部变量的指针或者引用，并且在函数退出时线程仍未结束，就会出现问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">struct func &#123;</div><div class="line">    int &amp; i;</div><div class="line">    func(int &amp; i_):i(i_) &#123;&#125;</div><div class="line">    void operator() () &#123;</div><div class="line">        for (unsinged j=0;j&lt;100000;++j) &#123;</div><div class="line">            do_something(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">void oops() &#123;</div><div class="line">    int som_local_state = 0;</div><div class="line">    func my_func(som_local_state);</div><div class="line">   std::thread my_thread(my_func);</div><div class="line">   my_thread.detach();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="等待线程结束"><a href="#等待线程结束" class="headerlink" title="等待线程结束"></a>等待线程结束</h4><p>In real code the original thread would either have work to do itself or it would have launched sev- eral threads to do useful work before waiting for all of them to complete.<br><code>join</code> 是一个简单粗暴的方式。If you need more fine-grained control over waiting for a thread, such as to check whether a thread is finished, or to wait only a certain period of time, then you have to use alternative mechanisms such as condition variables and futures.<br><strong>The act of calling join() also cleans up any storage associ- ated with the thread, so the std::thread object is no longer associated with the now- finished thread; it isn’t associated with any thread. This means that you can call join() only once for a given thread; once you’ve called join(), the std::thread object is no longer joinable, and joinable() will return false.</strong></p>
<h4 id="在异常发生时等待线程结束"><a href="#在异常发生时等待线程结束" class="headerlink" title="在异常发生时等待线程结束"></a>在异常发生时等待线程结束</h4><p>需要在代码中选择合适的地方对线程进行 join，如果异常发生在线程启动之后、<code>join</code> 的调用之前，<code>join</code> 的调用则有可能会被 skipped，这样的话你的应用就会被 terminated。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">struct func;</div><div class="line">void f() &#123;</div><div class="line">    int som_local_state=0;</div><div class="line">    func my_func(som_local_state);</div><div class="line">    std::thread my_thread(my_func);</div><div class="line">    try &#123;</div><div class="line">        do_something_in_current_thread();</div><div class="line">    &#125;</div><div class="line">    catch(...) &#123;</div><div class="line">        my_thread.join();</div><div class="line">        throw;</div><div class="line">    &#125;</div><div class="line">    my_thread.join();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过 try/catch 的方式会显得 verbose，下面使用 RAII (Resource Acquisition Is Initialization) 来确保无论函数是 normal 或者 exceptional 退出，都会对线程进行 join。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">class thread_guard &#123;</div><div class="line">    std::thread&amp; t;</div><div class="line">    public:</div><div class="line">        explicit thread_guard(std::thread&amp; t_):t(t_) &#123;&#125;</div><div class="line">        thread_guard(const thread_guard &amp;) = delete;</div><div class="line">        thread_guard&amp; operator= (const thread_guard&amp;) = delete;</div><div class="line">        ~thread_guard() &#123;</div><div class="line">            if (t.joinable()) &#123;</div><div class="line">                t.join();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">&#125;;</div><div class="line">struct func;</div><div class="line">void f() &#123;</div><div class="line">    int som_local_state = 0;</div><div class="line">    func my_func(som_local_state);</div><div class="line">    std::thread my_thread(my_func);</div><div class="line">    thread_guard guard(my_thread);</div><div class="line"></div><div class="line">    do_something_in_current_thread();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>When the execution of the current thread reaches the end of f , the local objects are destroyed in reverse order of construction. Consequently, the thread_guard object guard is destroyed first, and the thread is joined with in the destructor.</strong> 确保在线程对象销毁之前被 join。<br>If you don’t need to wait for a thread to finish, you can avoid this exception-safety issue by detaching it. This breaks the association of the thread with the std::thread object and ensures that std::terminate() won’t be called when the std::thread object is destroyed, even though the thread is still running in the background.</p>
<h4 id="在后台运行线程"><a href="#在后台运行线程" class="headerlink" title="在后台运行线程"></a>在后台运行线程</h4><p>Detached 线程是在后台运行的，ownership 和 control 会被传递给 C++ Runtime Library，它会确保在线程退出时与该线程相关联的资源会被正确释放。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void edit_document(std::string const &amp; filename) &#123;</div><div class="line">    open_document_and_display_gui(filename);</div><div class="line">    while(!done_editing()) &#123;</div><div class="line">        user_command cmd  = get_user_input();</div><div class="line">        if (cmd.type == open_new_document) &#123;</div><div class="line">            std::string const new_name = get_filename_from_user();</div><div class="line">            std:thread t(edit_document, new_name);</div><div class="line">            t.detach();</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            process_user_input(cmd);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="向线程函数传递参数"><a href="#向线程函数传递参数" class="headerlink" title="向线程函数传递参数"></a>向线程函数传递参数</h4><p>默认情况下，参数是被拷贝进线程内部存储 (internal storage) 的，在那里它们可以被新创建的线程访问，即使线程函数相对应的参数期望的是一个引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void f(int i, std::string const &amp; s);</div><div class="line">std::thread t(f, 3, &quot;hello world&quot;);</div></pre></td></tr></table></figure></p>
<p>这会创建一个与线程对象 <code>t</code> 相关联的新线程，这个新线程会调用 <code>f(3, &quot;hello world&quot;)</code>。需要注意的是，即使线程函数的第二个参数类型是 std::string const &amp;，字符串字面常量以 char const * 方式传递进入线程内部存储，并在线程内部被转化成 std::string。This is particularly important when the argument supplied is a pointer to an automatic variable, as follows:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void f(int i, std::string const &amp; s);</div><div class="line">void oops(int some_param) &#123;</div><div class="line">    char buffer[1024];</div><div class="line">    sprintf(buffer, &quot;%i&quot;, some_param);</div><div class="line">    std::thread t(f, 3, buffer);</div><div class="line">    t.detach();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>In this case, it’s the pointer to the local variable buffer that’s passed through to the new thread, and there’s a significant chance that the function oops will exit before the buffer has been converted to a std::string on the new thread, thus leading to undefined behavior. 这里的 dangling pointer 问题在于依赖了char * 到 std::string 的隐式类型转换，而这个隐式类型转换是发生在新线程中的 f(3, buffer) 处。<br>The solution is to cast to std::string before passing the buffer to the std::thread constructor:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void f(int i, std::string const &amp; s);</div><div class="line">void not_oops(int some_param) &#123;</div><div class="line">    char buffer[1024];</div><div class="line">    sprintf(buffer, &quot;%i&quot;, some_param);</div><div class="line">    std::thread t(f, 3, std::string(buffer));</div><div class="line">    t.detach();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>The std::thread constructor copies the supplied values as is, without converting to the expected argument type.</strong><br>考虑下面的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void update_data_for_widget(widget_id w, widget_data&amp; data);</div><div class="line">void oops_again(widget_id w) &#123;</div><div class="line">    widget_data data;</div><div class="line">    std::thread t(update_data_for_widget, w, data);</div><div class="line">    display_status();</div><div class="line">    t.join();</div><div class="line">    process_widget_data(data);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Although <code>update_data_for_widget</code> expects the second parameter to be passed by reference, the <code>std::thread</code> constructor doesn’t know that; it’s oblivious to the types of the arguments expected by the function and blindly copies the supplied values. When it calls <code>update_data_for_widget</code>, it will end up passing a reference to the internal copy of data and not a reference to data itself. Consequently, when the thread finishes, these updates will be discarded as the internal copies of the supplied arguments are destroyed, and <code>process_widget_data</code> will be passed an unchanged data rather than a correctly updated version.<br>The solution is:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">std::thread t(update_data_for_widget, w, std::ref(data));</div></pre></td></tr></table></figure></p>
<p>then <code>update_data_for_widget</code> will be correctly passed a reference to data rather than a reference to a copy of data.<br>Both the operation of the <code>std::thread</code> constructor and the operation of <code>std::bind</code> are defined in terms of the same mechanism. This means that, for example, you can pass a member function pointer as the function, provided you supply a suitable object pointer as the first argument:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class X &#123;</div><div class="line">    public:</div><div class="line">        void do_lengthy_work();</div><div class="line">&#125;;</div><div class="line">X my_x;</div><div class="line">std::thread(&amp;X::do_lengthy_work, &amp;my_x);</div></pre></td></tr></table></figure></p>
<h6 id="当参数-not-copyable-but-movable"><a href="#当参数-not-copyable-but-movable" class="headerlink" title="当参数 not copyable but movable"></a>当参数 not copyable but movable</h6><p>moved: The data held within one object is transferred over to another, leaving the original object “empty”.<br>An example of such a type is <code>std::unique_ptr</code>, which provides automatic memory management for dynamically allocated objects. Only one <code>std::unique_ptr</code> instance can point to a given object at a time, and when that instance is destroyed, the pointed-to object is deleted. The move constructor and move assignment operator allow the ownership of an object to be transferred around between <code>std::unique_ptr</code> instances. Such a transfer leaves the source object with a NULL pointer. This moving of values allows objects of this type to be accepted as function parameters or returned from functions. 在 <code>std::unique_ptr</code> 中 move 的应用倒不是主要出于效率的考虑，而是出于 unique 的考虑，move 的主要用武之地还是大型对象之间资源的 transfer。<br>Where the source object is a temporary, the move is automatic, but where the source is a named value, the transfer must be requested directly by invoking <code>std::move()</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void process_big_object(std::unique_ptr&lt;big_object&gt;);</div><div class="line">std::unique_ptr&lt;big_object&gt; p(new big_object);</div><div class="line">p-&gt;prepare_data(42);</div><div class="line">std::thread t(process_big_object, std::move(p));</div></pre></td></tr></table></figure></p>
<p>By specifying <code>std::move(p)</code> in the <code>std::thread</code> constructor, the ownership of the big_object is transferred first into internal storage for the newly created thread (否则的话默认就是拷贝了，而不是 move) and then into <code>process_big_object</code>.<br>Several of the classes in the Standard Thread Library exhibit the same ownership semantics as <code>std::unique_ptr</code>, and <code>std::thread</code> is one of them. Though <code>std::thread</code> instances don’t own a dynamic object in the same way as <code>std::unique_ptr</code> does, they do own a resource: each instance is responsible for managing a thread of execution. This ownership can be transferred between instances, because instances of <code>std::thread</code> are movable, even though they aren’t copyable. This ensures that only one object is associated with a particular thread of execution at any one time while allowing programmers the option of transferring that ownership between objects.</p>
<h4 id="在线程对象间传递线程的所有权"><a href="#在线程对象间传递线程的所有权" class="headerlink" title="在线程对象间传递线程的所有权"></a>在线程对象间传递线程的所有权</h4><p>在函数的内外传递线程的所有权是很常见的，即函数的参数或者返回值是线程对象。像 <code>std::ifstream</code> 和 <code>std::unique_ptr</code> 一样，<code>std::thread</code> 是 movable but not copyable。这意味着，一个线程的所有权可以在线程对象间传递。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void some_function();</div><div class="line">void som_other_function();</div><div class="line">std::thread t1(some_function);</div><div class="line">std::thread t2 = std::move(t1);</div><div class="line">t1 = std::thread(som_other_function);</div><div class="line">std::thread t3;</div><div class="line">t3 = std::move(t2);</div><div class="line">t1 = std::move(t3); // This assignment will terminate program!</div></pre></td></tr></table></figure></p>
<p>In the last assignment, <code>t1</code> already had an associated thread (which was running <code>some_other_function</code>), so <code>std::terminate()</code> is called to terminate the program. This is done for consistency with the <code>std::thread</code> destructor. As you must explicitly wait for a thread to complete or detach it before destruction, and the same applies to assignment: you can’t just “drop” a thread by assigning a new value to the <code>std::thread</code> object that manages it.</p>
<h6 id="Returning-a-std-thread-from-a-function"><a href="#Returning-a-std-thread-from-a-function" class="headerlink" title="Returning a std::thread from a function"></a>Returning a std::thread from a function</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">std::thread f() &#123;</div><div class="line">    void some_function();</div><div class="line">    return std::thread(some_function); // 临时对象，不用显式地调用 std::move。</div><div class="line">&#125;</div><div class="line">std::thread g() &#123;</div><div class="line">    void som_other_function(int);</div><div class="line">    std::thread t(some_other_function, 42);</div><div class="line">    return t; // 局部变量，不是临时对象，但是这个对象即将被销毁，因此可以不用显式地调用 std::move，自动发生 move。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="Pass-a-std-thread-into-a-function"><a href="#Pass-a-std-thread-into-a-function" class="headerlink" title="Pass a std::thread into a function"></a>Pass a std::thread into a function</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void f(std::thread);</div><div class="line">void g() &#123;</div><div class="line">    void some_function();</div><div class="line">    f(std::thread(some_function));</div><div class="line">    std::thread t(some_function);</div><div class="line">    f(std::move(t));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以利用 <code>std::thread</code> 对于 move 的支持来修改 <code>thread_guard</code>，让 <code>thread_guard</code> 实际持有线程，而不是通过持有一个线程对象的引用来间接管理线程。去掉了引用，带来的好处是，<code>thread_guard</code> 可以在线程对象所在的作用域之外生存（引用的存在会让 <code>thread_guard</code> 和 线程对象牢牢绑在同一个作用域内）。同时带来的另一个好处是，由于把线程的所有权转移进了 <code>thread_guard</code> 对象，外部的线程对象没有了线程的所有权，避免了其他人对线程对象调用 <code>join</code> 或者 <code>detach</code>，因为此时外部的线程对象已经 not joinable。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class scoped_thread &#123;</div><div class="line">    std::thread t;</div><div class="line">    public:</div><div class="line">        explicit scoped_thread(std::thread t_):t(std::move(t_)) &#123;</div><div class="line">            if (!t.joinable()) &#123;</div><div class="line">                throw std::logic_error(&quot;No thread.&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        ~scoped_thread() &#123;</div><div class="line">            t.join();</div><div class="line">        &#125;</div><div class="line">        scoped_thread(const scoped_thread &amp;) = delete;</div><div class="line">        scoped_thread&amp; operator= (const scoped_thread &amp;) = delete;</div><div class="line">&#125;;</div><div class="line">struct func;</div><div class="line">void f() &#123;</div><div class="line">    int som_local_state;</div><div class="line">    scoped_thread t(std::thread(func(som_local_state)));</div><div class="line">    do_something_in_current_thread();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>The move support in <code>std::thread</code> also allows for containers of <code>std::thread</code> objects, if those containers are move aware (like the updated <code>std::vector&lt;&gt;</code>). This means that you can write code like that in the following listing, which spawns a number of threads and then waits for them to finish.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">void do_work(unsinged int id);</div><div class="line">void f() &#123;</div><div class="line">    std::vector&lt;std::thread&gt; threads;</div><div class="line">    for (unsinged int i=0;i&lt;20;i++) &#123;</div><div class="line">        threads.push_back(std::thread(do_work, i));</div><div class="line">    &#125;</div><div class="line">    std::for_each(threads.begin(), threads.end(), std::mem_fn(&amp;std::thread::join));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Putting <code>std::thread</code> objects in a <code>std::vector</code> is a step toward automating the management of those threads: rather than creating separate variables for those threads and joining with them directly, they can be treated as a group.</p>
<h4 id="Choosing-the-number-of-threads-at-runtime"><a href="#Choosing-the-number-of-threads-at-runtime" class="headerlink" title="Choosing the number of threads at runtime"></a>Choosing the number of threads at runtime</h4><p>在运行时通过 <code>std::thread::hardware_concurrency()</code> 来获得可以真正并发的线程数目，在一个多核系统上，返回值可能是 CPU 的核心数目。返回值仅仅是一个 hint，在这个信息不可用时，返回 0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;numeric&gt;</div><div class="line">#include &lt;thread&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line"></div><div class="line">template&lt;typename Iterator, typename T&gt;</div><div class="line">struct accumulate_block &#123;</div><div class="line">    void operator() (Iterator first, Iterator last, T&amp; result) &#123;</div><div class="line">        result = std::accumulate(first, last, result);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">template &lt;typename Iterator, typename T&gt;</div><div class="line">T parallel_accumulate(Iterator first, Iterator last, T init) &#123;</div><div class="line">    const unsigned long length = std::distance(first, last);</div><div class="line">    if (!length) &#123;</div><div class="line">        return init;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    const unsigned long min_per_thread = 2;</div><div class="line">    const unsigned long max_threads = (length + min_per_thread - 1) / min_per_thread;</div><div class="line">    const unsigned long hardware_threads = std::thread::hardware_concurrency();</div><div class="line">    const unsigned long num_threads = std::min(hardware_threads!=0 ? hardware_threads: 2, max_threads);</div><div class="line">    std::vector&lt;std::thread&gt; threads(num_threads - 1);</div><div class="line">    std::vector&lt;T&gt; results(num_threads);</div><div class="line">    std::cout &lt;&lt; &quot;max_threads: &quot; &lt;&lt; max_threads &lt;&lt; std::endl</div><div class="line">    &lt;&lt; &quot;hardware_threads: &quot; &lt;&lt; hardware_threads &lt;&lt; std::endl</div><div class="line">    &lt;&lt; &quot;num_threads: &quot; &lt;&lt; num_threads &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    const unsigned long block_size = (length + num_threads - 1) / num_threads;</div><div class="line">    Iterator block_start = first;</div><div class="line">    Iterator block_end = first;</div><div class="line"></div><div class="line">    for (int i=0;i&lt;num_threads-1;i++) &#123;</div><div class="line">        std::advance(block_end, block_size);</div><div class="line">        threads[i] = std::thread(accumulate_block&lt;Iterator, T&gt;(), block_start, block_end, std::ref(results[i]));</div><div class="line">        std::cout &lt;&lt; &quot;Thread #&quot; &lt;&lt; i &lt;&lt; &quot; will process &quot; &lt;&lt; block_size &lt;&lt; &quot; elements&quot; &lt;&lt; std::endl;</div><div class="line">        block_start = block_end;</div><div class="line">    &#125;</div><div class="line">    std::cout &lt;&lt; &quot;The main Thread will process &quot; &lt;&lt; std::distance(block_end, last) &lt;&lt; &quot; elements&quot; &lt;&lt; std::endl;</div><div class="line">    accumulate_block&lt;Iterator, T&gt;()(block_end, last, std::ref(results.back()));</div><div class="line">    std::for_each(threads.begin(), threads.end(), std::mem_fn(&amp;std::thread::join));</div><div class="line">    return std::accumulate(results.begin(), results.end(), init);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    std::vector&lt;int&gt; v = &#123;1, 2, 3, 4, 5&#125;;</div><div class="line">    int result = parallel_accumulate(v.begin(), v.end(), 0);</div><div class="line">    std::cout &lt;&lt; &quot;Result is &quot; &lt;&lt; result &lt;&lt; std::endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">max_threads: 3</div><div class="line">hardware_threads: 8</div><div class="line">num_threads: 3</div><div class="line">Thread #0 will process 2 elements</div><div class="line">Thread #1 will process 2 elements</div><div class="line">The main Thread will process 1 elements</div><div class="line">Result is 15</div><div class="line">Program ended with exit code: 0</div></pre></td></tr></table></figure></p>

    </div>

    

    
        <div class="post-tags">
            <i class="fa fa-tags" aria-hidden="true"></i>
            <a href="/tags/C/">#C++</a>
        </div>
    

    <!-- Comments -->
    

</div>
        </section>

    </div>
</div>


</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This is Robert Lexis (FengCun Li). To see the world, things dangerous to come to, to see behind walls, to draw closer, to find each other and to feel. That is the purpose of LIFE.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2019/07/12/Unnamed-namespace/">Unnamed namespace</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/05/08/Static-variable-in-inlined-function/">Static variable in inline</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/04/23/Iterator-invalidation-rules/">Iterator invalidation rul</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/03/18/Emplace-back/">Emplace back</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/RobertLexis">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:robert_lexis@163.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Robert Lexis Loves Wenny
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>