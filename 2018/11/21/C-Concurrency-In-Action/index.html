<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="基本的线程管理启动线程 12void do_some_work();std::thread my_thread(do_some_work);  123456789class background_task &amp;#123;    public:        void operator() ()const &amp;#123;            do_something();            do_">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Concurrency in Action">
<meta property="og:url" content="http://yoursite.com/2018/11/21/C-Concurrency-In-Action/index.html">
<meta property="og:site_name" content="The next stop - Antarctica">
<meta property="og:description" content="基本的线程管理启动线程 12void do_some_work();std::thread my_thread(do_some_work);  123456789class background_task &amp;#123;    public:        void operator() ()const &amp;#123;            do_something();            do_">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-12-03T14:46:55.600Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ Concurrency in Action">
<meta name="twitter:description" content="基本的线程管理启动线程 12void do_some_work();std::thread my_thread(do_some_work);  123456789class background_task &amp;#123;    public:        void operator() ()const &amp;#123;            do_something();            do_">

<link rel="canonical" href="http://yoursite.com/2018/11/21/C-Concurrency-In-Action/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++ Concurrency in Action | The next stop - Antarctica</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">The next stop - Antarctica</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">To see behind walls. To draw closer.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/21/C-Concurrency-In-Action/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fengcun Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The next stop - Antarctica">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ Concurrency in Action
        </h1>

        <div class="post-meta">
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-12-03 22:46:55" itemprop="dateModified" datetime="2018-12-03T22:46:55+08:00">2018-12-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="基本的线程管理"><a href="#基本的线程管理" class="headerlink" title="基本的线程管理"></a>基本的线程管理</h2><h4 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h4><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void do_some_work();</span><br><span class="line">std::thread my_thread(do_some_work);</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class background_task &#123;</span><br><span class="line">    public:</span><br><span class="line">        void operator() ()const &#123;</span><br><span class="line">            do_something();</span><br><span class="line">            do_something_else();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">background_task f;</span><br><span class="line">std::thread my_thread(f);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<a id="more"></a>
<h5 id="C-’s-most-vexing-parse"><a href="#C-’s-most-vexing-parse" class="headerlink" title="C++’s most vexing parse"></a>C++’s most vexing parse</h5><p><code>std::thread my_thread(background_task());</code> 会被视为函数声明，而不是对象的定义。<br>可以通过两种方式进行避免</p>
<ol>
<li><code>std::thread my_thread((background_task()))</code></li>
<li>Using new uniform initialization syntax <code>std::thread my_thread{background_task()}</code></li>
</ol>
<p>一旦启动一个线程，需要显式地指定 wait for it (by joining with it) 或者 leave it to run on its own (by detaching it)。如果在 <code>std::thread</code> 对象被销毁之前，没有进行任何指定，则程序会被终止(std::thread destructor 会调用 std::terminate())。需要注意的是，你仅仅需要在 <code>std::thread</code> 对象被销毁之前进行指定即可，在你指定 join 或者 detach 之前，线程本身可能已经结束，或者如果你决定 detach it，线程可能在 <code>std::thread</code> 对象销毁之后仍然继续运行很长时间。</p>
<h5 id="确保线程访问的数据的有效性"><a href="#确保线程访问的数据的有效性" class="headerlink" title="确保线程访问的数据的有效性"></a>确保线程访问的数据的有效性</h5><p>If you don’t wait for your thread to finish, then you need to ensure that the data accessed by the thread is valid until the thread has finished with it.如果线程持有指向局部变量的指针或者引用，并且在函数退出时线程仍未结束，就会出现问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct func &#123;</span><br><span class="line">    int &amp; i;</span><br><span class="line">    func(int &amp; i_):i(i_) &#123;&#125;</span><br><span class="line">    void operator() () &#123;</span><br><span class="line">        for (unsinged j=0;j&lt;100000;++j) &#123;</span><br><span class="line">            do_something(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void oops() &#123;</span><br><span class="line">    int som_local_state = 0;</span><br><span class="line">    func my_func(som_local_state);</span><br><span class="line">   std::thread my_thread(my_func);</span><br><span class="line">   my_thread.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="等待线程结束"><a href="#等待线程结束" class="headerlink" title="等待线程结束"></a>等待线程结束</h4><p>In real code the original thread would either have work to do itself or it would have launched sev- eral threads to do useful work before waiting for all of them to complete.<br><code>join</code> 是一个简单粗暴的方式。If you need more fine-grained control over waiting for a thread, such as to check whether a thread is finished, or to wait only a certain period of time, then you have to use alternative mechanisms such as condition variables and futures.<br><strong>The act of calling join() also cleans up any storage associ- ated with the thread, so the std::thread object is no longer associated with the now- finished thread; it isn’t associated with any thread. This means that you can call join() only once for a given thread; once you’ve called join(), the std::thread object is no longer joinable, and joinable() will return false.</strong></p>
<h4 id="在异常发生时等待线程结束"><a href="#在异常发生时等待线程结束" class="headerlink" title="在异常发生时等待线程结束"></a>在异常发生时等待线程结束</h4><p>需要在代码中选择合适的地方对线程进行 join，如果异常发生在线程启动之后、<code>join</code> 的调用之前，<code>join</code> 的调用则有可能会被 skipped，这样的话你的应用就会被 terminated。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct func;</span><br><span class="line">void f() &#123;</span><br><span class="line">    int som_local_state=0;</span><br><span class="line">    func my_func(som_local_state);</span><br><span class="line">    std::thread my_thread(my_func);</span><br><span class="line">    try &#123;</span><br><span class="line">        do_something_in_current_thread();</span><br><span class="line">    &#125;</span><br><span class="line">    catch(...) &#123;</span><br><span class="line">        my_thread.join();</span><br><span class="line">        throw;</span><br><span class="line">    &#125;</span><br><span class="line">    my_thread.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过 try/catch 的方式会显得 verbose，下面使用 RAII (Resource Acquisition Is Initialization) 来确保无论函数是 normal 或者 exceptional 退出，都会对线程进行 join。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class thread_guard &#123;</span><br><span class="line">    std::thread&amp; t;</span><br><span class="line">    public:</span><br><span class="line">        explicit thread_guard(std::thread&amp; t_):t(t_) &#123;&#125;</span><br><span class="line">        thread_guard(const thread_guard &amp;) = delete;</span><br><span class="line">        thread_guard&amp; operator= (const thread_guard&amp;) = delete;</span><br><span class="line">        ~thread_guard() &#123;</span><br><span class="line">            if (t.joinable()) &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">struct func;</span><br><span class="line">void f() &#123;</span><br><span class="line">    int som_local_state = 0;</span><br><span class="line">    func my_func(som_local_state);</span><br><span class="line">    std::thread my_thread(my_func);</span><br><span class="line">    thread_guard guard(my_thread);</span><br><span class="line"></span><br><span class="line">    do_something_in_current_thread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>When the execution of the current thread reaches the end of f , the local objects are destroyed in reverse order of construction. Consequently, the thread_guard object guard is destroyed first, and the thread is joined with in the destructor.</strong> 确保在线程对象销毁之前被 join。<br>If you don’t need to wait for a thread to finish, you can avoid this exception-safety issue by detaching it. This breaks the association of the thread with the std::thread object and ensures that std::terminate() won’t be called when the std::thread object is destroyed, even though the thread is still running in the background.</p>
<h4 id="在后台运行线程"><a href="#在后台运行线程" class="headerlink" title="在后台运行线程"></a>在后台运行线程</h4><p>Detached 线程是在后台运行的，ownership 和 control 会被传递给 C++ Runtime Library，它会确保在线程退出时与该线程相关联的资源会被正确释放。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void edit_document(std::string const &amp; filename) &#123;</span><br><span class="line">    open_document_and_display_gui(filename);</span><br><span class="line">    while(!done_editing()) &#123;</span><br><span class="line">        user_command cmd  = get_user_input();</span><br><span class="line">        if (cmd.type == open_new_document) &#123;</span><br><span class="line">            std::string const new_name = get_filename_from_user();</span><br><span class="line">            std:thread t(edit_document, new_name);</span><br><span class="line">            t.detach();</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            process_user_input(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="向线程函数传递参数"><a href="#向线程函数传递参数" class="headerlink" title="向线程函数传递参数"></a>向线程函数传递参数</h4><p>默认情况下，参数是被拷贝进线程内部存储 (internal storage) 的，在那里它们可以被新创建的线程访问，即使线程函数相对应的参数期望的是一个引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void f(int i, std::string const &amp; s);</span><br><span class="line">std::thread t(f, 3, &quot;hello world&quot;);</span><br></pre></td></tr></table></figure></p>
<p>这会创建一个与线程对象 <code>t</code> 相关联的新线程，这个新线程会调用 <code>f(3, &quot;hello world&quot;)</code>。需要注意的是，即使线程函数的第二个参数类型是 std::string const &amp;，字符串字面常量以 char const * 方式传递进入线程内部存储，并在线程内部被转化成 std::string。This is particularly important when the argument supplied is a pointer to an automatic variable, as follows:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void f(int i, std::string const &amp; s);</span><br><span class="line">void oops(int some_param) &#123;</span><br><span class="line">    char buffer[1024];</span><br><span class="line">    sprintf(buffer, &quot;%i&quot;, some_param);</span><br><span class="line">    std::thread t(f, 3, buffer);</span><br><span class="line">    t.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>In this case, it’s the pointer to the local variable buffer that’s passed through to the new thread, and there’s a significant chance that the function oops will exit before the buffer has been converted to a std::string on the new thread, thus leading to undefined behavior. 这里的 dangling pointer 问题在于依赖了char * 到 std::string 的隐式类型转换，而这个隐式类型转换是发生在新线程中的 f(3, buffer) 处。<br>The solution is to cast to std::string before passing the buffer to the std::thread constructor:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void f(int i, std::string const &amp; s);</span><br><span class="line">void not_oops(int some_param) &#123;</span><br><span class="line">    char buffer[1024];</span><br><span class="line">    sprintf(buffer, &quot;%i&quot;, some_param);</span><br><span class="line">    std::thread t(f, 3, std::string(buffer));</span><br><span class="line">    t.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>The std::thread constructor copies the supplied values as is, without converting to the expected argument type.</strong><br>考虑下面的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void update_data_for_widget(widget_id w, widget_data&amp; data);</span><br><span class="line">void oops_again(widget_id w) &#123;</span><br><span class="line">    widget_data data;</span><br><span class="line">    std::thread t(update_data_for_widget, w, data);</span><br><span class="line">    display_status();</span><br><span class="line">    t.join();</span><br><span class="line">    process_widget_data(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Although <code>update_data_for_widget</code> expects the second parameter to be passed by reference, the <code>std::thread</code> constructor doesn’t know that; it’s oblivious to the types of the arguments expected by the function and blindly copies the supplied values. When it calls <code>update_data_for_widget</code>, it will end up passing a reference to the internal copy of data and not a reference to data itself. Consequently, when the thread finishes, these updates will be discarded as the internal copies of the supplied arguments are destroyed, and <code>process_widget_data</code> will be passed an unchanged data rather than a correctly updated version.<br>The solution is:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::thread t(update_data_for_widget, w, std::ref(data));</span><br></pre></td></tr></table></figure></p>
<p>then <code>update_data_for_widget</code> will be correctly passed a reference to data rather than a reference to a copy of data.<br>Both the operation of the <code>std::thread</code> constructor and the operation of <code>std::bind</code> are defined in terms of the same mechanism. This means that, for example, you can pass a member function pointer as the function, provided you supply a suitable object pointer as the first argument:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class X &#123;</span><br><span class="line">    public:</span><br><span class="line">        void do_lengthy_work();</span><br><span class="line">&#125;;</span><br><span class="line">X my_x;</span><br><span class="line">std::thread(&amp;X::do_lengthy_work, &amp;my_x);</span><br></pre></td></tr></table></figure></p>
<h6 id="当参数-not-copyable-but-movable"><a href="#当参数-not-copyable-but-movable" class="headerlink" title="当参数 not copyable but movable"></a>当参数 not copyable but movable</h6><p>moved: The data held within one object is transferred over to another, leaving the original object “empty”.<br>An example of such a type is <code>std::unique_ptr</code>, which provides automatic memory management for dynamically allocated objects. Only one <code>std::unique_ptr</code> instance can point to a given object at a time, and when that instance is destroyed, the pointed-to object is deleted. The move constructor and move assignment operator allow the ownership of an object to be transferred around between <code>std::unique_ptr</code> instances. Such a transfer leaves the source object with a NULL pointer. This moving of values allows objects of this type to be accepted as function parameters or returned from functions. 在 <code>std::unique_ptr</code> 中 move 的应用倒不是主要出于效率的考虑，而是出于 unique 的考虑，move 的主要用武之地还是大型对象之间资源的 transfer。<br>Where the source object is a temporary, the move is automatic, but where the source is a named value, the transfer must be requested directly by invoking <code>std::move()</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void process_big_object(std::unique_ptr&lt;big_object&gt;);</span><br><span class="line">std::unique_ptr&lt;big_object&gt; p(new big_object);</span><br><span class="line">p-&gt;prepare_data(42);</span><br><span class="line">std::thread t(process_big_object, std::move(p));</span><br></pre></td></tr></table></figure></p>
<p>By specifying <code>std::move(p)</code> in the <code>std::thread</code> constructor, the ownership of the big_object is transferred first into internal storage for the newly created thread (否则的话默认就是拷贝了，而不是 move) and then into <code>process_big_object</code>.<br>Several of the classes in the Standard Thread Library exhibit the same ownership semantics as <code>std::unique_ptr</code>, and <code>std::thread</code> is one of them. Though <code>std::thread</code> instances don’t own a dynamic object in the same way as <code>std::unique_ptr</code> does, they do own a resource: each instance is responsible for managing a thread of execution. This ownership can be transferred between instances, because instances of <code>std::thread</code> are movable, even though they aren’t copyable. This ensures that only one object is associated with a particular thread of execution at any one time while allowing programmers the option of transferring that ownership between objects.</p>
<h4 id="在线程对象间传递线程的所有权"><a href="#在线程对象间传递线程的所有权" class="headerlink" title="在线程对象间传递线程的所有权"></a>在线程对象间传递线程的所有权</h4><p>在函数的内外传递线程的所有权是很常见的，即函数的参数或者返回值是线程对象。像 <code>std::ifstream</code> 和 <code>std::unique_ptr</code> 一样，<code>std::thread</code> 是 movable but not copyable。这意味着，一个线程的所有权可以在线程对象间传递。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void some_function();</span><br><span class="line">void som_other_function();</span><br><span class="line">std::thread t1(some_function);</span><br><span class="line">std::thread t2 = std::move(t1);</span><br><span class="line">t1 = std::thread(som_other_function);</span><br><span class="line">std::thread t3;</span><br><span class="line">t3 = std::move(t2);</span><br><span class="line">t1 = std::move(t3); // This assignment will terminate program!</span><br></pre></td></tr></table></figure></p>
<p>In the last assignment, <code>t1</code> already had an associated thread (which was running <code>some_other_function</code>), so <code>std::terminate()</code> is called to terminate the program. This is done for consistency with the <code>std::thread</code> destructor. As you must explicitly wait for a thread to complete or detach it before destruction, and the same applies to assignment: you can’t just “drop” a thread by assigning a new value to the <code>std::thread</code> object that manages it.</p>
<h6 id="Returning-a-std-thread-from-a-function"><a href="#Returning-a-std-thread-from-a-function" class="headerlink" title="Returning a std::thread from a function"></a>Returning a std::thread from a function</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::thread f() &#123;</span><br><span class="line">    void some_function();</span><br><span class="line">    return std::thread(some_function); // 临时对象，不用显式地调用 std::move。</span><br><span class="line">&#125;</span><br><span class="line">std::thread g() &#123;</span><br><span class="line">    void som_other_function(int);</span><br><span class="line">    std::thread t(some_other_function, 42);</span><br><span class="line">    return t; // 局部变量，不是临时对象，但是这个对象即将被销毁，因此可以不用显式地调用 std::move，自动发生 move。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Pass-a-std-thread-into-a-function"><a href="#Pass-a-std-thread-into-a-function" class="headerlink" title="Pass a std::thread into a function"></a>Pass a std::thread into a function</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void f(std::thread);</span><br><span class="line">void g() &#123;</span><br><span class="line">    void some_function();</span><br><span class="line">    f(std::thread(some_function));</span><br><span class="line">    std::thread t(some_function);</span><br><span class="line">    f(std::move(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以利用 <code>std::thread</code> 对于 move 的支持来修改 <code>thread_guard</code>，让 <code>thread_guard</code> 实际持有线程，而不是通过持有一个线程对象的引用来间接管理线程。去掉了引用，带来的好处是，<code>thread_guard</code> 可以在线程对象所在的作用域之外生存（引用的存在会让 <code>thread_guard</code> 和 线程对象牢牢绑在同一个作用域内）。同时带来的另一个好处是，由于把线程的所有权转移进了 <code>thread_guard</code> 对象，外部的线程对象没有了线程的所有权，避免了其他人对线程对象调用 <code>join</code> 或者 <code>detach</code>，因为此时外部的线程对象已经 not joinable。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class scoped_thread &#123;</span><br><span class="line">    std::thread t;</span><br><span class="line">    public:</span><br><span class="line">        explicit scoped_thread(std::thread t_):t(std::move(t_)) &#123;</span><br><span class="line">            if (!t.joinable()) &#123;</span><br><span class="line">                throw std::logic_error(&quot;No thread.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ~scoped_thread() &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125;</span><br><span class="line">        scoped_thread(const scoped_thread &amp;) = delete;</span><br><span class="line">        scoped_thread&amp; operator= (const scoped_thread &amp;) = delete;</span><br><span class="line">&#125;;</span><br><span class="line">struct func;</span><br><span class="line">void f() &#123;</span><br><span class="line">    int som_local_state;</span><br><span class="line">    scoped_thread t(std::thread(func(som_local_state)));</span><br><span class="line">    do_something_in_current_thread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>The move support in <code>std::thread</code> also allows for containers of <code>std::thread</code> objects, if those containers are move aware (like the updated <code>std::vector&lt;&gt;</code>). This means that you can write code like that in the following listing, which spawns a number of threads and then waits for them to finish.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void do_work(unsinged int id);</span><br><span class="line">void f() &#123;</span><br><span class="line">    std::vector&lt;std::thread&gt; threads;</span><br><span class="line">    for (unsinged int i=0;i&lt;20;i++) &#123;</span><br><span class="line">        threads.push_back(std::thread(do_work, i));</span><br><span class="line">    &#125;</span><br><span class="line">    std::for_each(threads.begin(), threads.end(), std::mem_fn(&amp;std::thread::join));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Putting <code>std::thread</code> objects in a <code>std::vector</code> is a step toward automating the management of those threads: rather than creating separate variables for those threads and joining with them directly, they can be treated as a group.</p>
<h4 id="Choosing-the-number-of-threads-at-runtime"><a href="#Choosing-the-number-of-threads-at-runtime" class="headerlink" title="Choosing the number of threads at runtime"></a>Choosing the number of threads at runtime</h4><p>在运行时通过 <code>std::thread::hardware_concurrency()</code> 来获得可以真正并发的线程数目，在一个多核系统上，返回值可能是 CPU 的核心数目。返回值仅仅是一个 hint，在这个信息不可用时，返回 0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;numeric&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">template&lt;typename Iterator, typename T&gt;</span><br><span class="line">struct accumulate_block &#123;</span><br><span class="line">    void operator() (Iterator first, Iterator last, T&amp; result) &#123;</span><br><span class="line">        result = std::accumulate(first, last, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;typename Iterator, typename T&gt;</span><br><span class="line">T parallel_accumulate(Iterator first, Iterator last, T init) &#123;</span><br><span class="line">    const unsigned long length = std::distance(first, last);</span><br><span class="line">    if (!length) &#123;</span><br><span class="line">        return init;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const unsigned long min_per_thread = 2;</span><br><span class="line">    const unsigned long max_threads = (length + min_per_thread - 1) / min_per_thread;</span><br><span class="line">    const unsigned long hardware_threads = std::thread::hardware_concurrency();</span><br><span class="line">    const unsigned long num_threads = std::min(hardware_threads!=0 ? hardware_threads: 2, max_threads);</span><br><span class="line">    std::vector&lt;std::thread&gt; threads(num_threads - 1);</span><br><span class="line">    std::vector&lt;T&gt; results(num_threads);</span><br><span class="line">    std::cout &lt;&lt; &quot;max_threads: &quot; &lt;&lt; max_threads &lt;&lt; std::endl</span><br><span class="line">    &lt;&lt; &quot;hardware_threads: &quot; &lt;&lt; hardware_threads &lt;&lt; std::endl</span><br><span class="line">    &lt;&lt; &quot;num_threads: &quot; &lt;&lt; num_threads &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    const unsigned long block_size = (length + num_threads - 1) / num_threads;</span><br><span class="line">    Iterator block_start = first;</span><br><span class="line">    Iterator block_end = first;</span><br><span class="line"></span><br><span class="line">    for (int i=0;i&lt;num_threads-1;i++) &#123;</span><br><span class="line">        std::advance(block_end, block_size);</span><br><span class="line">        threads[i] = std::thread(accumulate_block&lt;Iterator, T&gt;(), block_start, block_end, std::ref(results[i]));</span><br><span class="line">        std::cout &lt;&lt; &quot;Thread #&quot; &lt;&lt; i &lt;&lt; &quot; will process &quot; &lt;&lt; block_size &lt;&lt; &quot; elements&quot; &lt;&lt; std::endl;</span><br><span class="line">        block_start = block_end;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; &quot;The main Thread will process &quot; &lt;&lt; std::distance(block_end, last) &lt;&lt; &quot; elements&quot; &lt;&lt; std::endl;</span><br><span class="line">    accumulate_block&lt;Iterator, T&gt;()(block_end, last, std::ref(results.back()));</span><br><span class="line">    std::for_each(threads.begin(), threads.end(), std::mem_fn(&amp;std::thread::join));</span><br><span class="line">    return std::accumulate(results.begin(), results.end(), init);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    std::vector&lt;int&gt; v = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">    int result = parallel_accumulate(v.begin(), v.end(), 0);</span><br><span class="line">    std::cout &lt;&lt; &quot;Result is &quot; &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">max_threads: 3</span><br><span class="line">hardware_threads: 8</span><br><span class="line">num_threads: 3</span><br><span class="line">Thread #0 will process 2 elements</span><br><span class="line">Thread #1 will process 2 elements</span><br><span class="line">The main Thread will process 1 elements</span><br><span class="line">Result is 15</span><br><span class="line">Program ended with exit code: 0</span><br></pre></td></tr></table></figure></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/09/03/Optimizers/" rel="prev" title="Optimizers">
      <i class="fa fa-chevron-left"></i> Optimizers
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/03/13/Move-semantic/" rel="next" title="Move Semantic">
      Move Semantic <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本的线程管理"><span class="nav-number">1.</span> <span class="nav-text">基本的线程管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#启动线程"><span class="nav-number">1.0.1.</span> <span class="nav-text">启动线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#C-’s-most-vexing-parse"><span class="nav-number">1.0.1.1.</span> <span class="nav-text">C++’s most vexing parse</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#确保线程访问的数据的有效性"><span class="nav-number">1.0.1.2.</span> <span class="nav-text">确保线程访问的数据的有效性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#等待线程结束"><span class="nav-number">1.0.2.</span> <span class="nav-text">等待线程结束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在异常发生时等待线程结束"><span class="nav-number">1.0.3.</span> <span class="nav-text">在异常发生时等待线程结束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在后台运行线程"><span class="nav-number">1.0.4.</span> <span class="nav-text">在后台运行线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#向线程函数传递参数"><span class="nav-number">1.0.5.</span> <span class="nav-text">向线程函数传递参数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#当参数-not-copyable-but-movable"><span class="nav-number">1.0.5.0.1.</span> <span class="nav-text">当参数 not copyable but movable</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在线程对象间传递线程的所有权"><span class="nav-number">1.0.6.</span> <span class="nav-text">在线程对象间传递线程的所有权</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Returning-a-std-thread-from-a-function"><span class="nav-number">1.0.6.0.1.</span> <span class="nav-text">Returning a std::thread from a function</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Pass-a-std-thread-into-a-function"><span class="nav-number">1.0.6.0.2.</span> <span class="nav-text">Pass a std::thread into a function</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Choosing-the-number-of-threads-at-runtime"><span class="nav-number">1.0.7.</span> <span class="nav-text">Choosing the number of threads at runtime</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fengcun Li"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Fengcun Li</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">106</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fengcun Li</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  











<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
