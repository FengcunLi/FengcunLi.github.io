<!DOCTYPE html>
<html lang="zh-CN">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="递归的前两个基本法则：

基准情形（base cases），必须总有某些基准情形，它们不用递归就能求解。
不断推进（making progress），对于那些要被递归求解的情形，递归调用必须总能够朝着一个基准情形推进。递归程序不仅简化了算法设计而且有助于给出更加简洁的代码，但是递归绝不应该作为简单f">
    

    <!--Author-->
    
        <meta name="author" content="Robert Lexis">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="数据结构与算法分析C++"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="This is WHY."/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

        <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>数据结构与算法分析C++ - This is WHY.</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


    <!-- favicon -->
    
	
</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">This is WHY.</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/RobertLexis">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>数据结构与算法分析C++</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2018-01-23
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <p>递归的前两个基本法则：</p>
<ol>
<li>基准情形（base cases），必须总有某些基准情形，它们不用递归就能求解。</li>
<li>不断推进（making progress），对于那些要被递归求解的情形，递归调用必须总能够朝着一个基准情形推进。<br>递归程序不仅简化了算法设计而且有助于给出更加简洁的代码，但是递归绝不应该作为简单for循环的代替物。<br>另外的两个法则是：</li>
<li>设计法则。假设所有的递归调用都能运行。</li>
<li>合成效益法则，在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。</li>
</ol>
<h4 id="接口与实现的分离"><a href="#接口与实现的分离" class="headerlink" title="接口与实现的分离"></a>接口与实现的分离</h4><p>接口列出了类及其成员（属性和方法），而实现则提供了函数的具体实现。<br>接口通常都放在以 .h 结尾的文件中，需要接口信息的源代码必须 #include 接口文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#ifndef IntCell_H</div><div class="line">#define IntCell_H</div><div class="line"></div><div class="line">class IntCell &#123;</div><div class="line">    public:</div><div class="line">        explicit IntCell(int initialValue = 0);</div><div class="line">        int read() const;</div><div class="line">        void write(int x);</div><div class="line">    private:</div><div class="line">        int storedValue;</div><div class="line">&#125;;</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>注意的一点是：默认参数仅在接口中被定义，在实现中则被忽略。<br>在 C++ 中有两种使用零参数构造函数创建对象的方式，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">m = new IntCell();</div><div class="line">m = new IntCell;</div></pre></td></tr></table></figure></p>
<p>C++ 没有自动的垃圾收集。<br>C 和 Java 都是值传递，而 Python 是对象传递。<br>C++ 提供了三种传参方式，值传递，引用传递，常量引用传递。<br>C++ 也提供了三种返回传递方式，值传递，引用传递，常量引用传递。尽量不要使用引用传递。<br>值传递一般来说是最安全的。使用常量引用传递或者引用传递只有在确保返回语句中的表达式在函数返回之后依然有效时才是安全的。<br>如果编译器没有注意到这个问题，对于局部变量的引用传递返回既可能是正确的，也可能是错误的，这会取决于编译器释放局部变量所使用的内存的速度。<br>复制构造函数 用于构造新的对象，并被初始化为相同类型对象的一个副本。<br>在以下三个情形下会被调用：</p>
<ol>
<li><p>声明的同时初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">IntCell B = C;</div><div class="line">IntCell B(C);</div><div class="line">而不是</div><div class="line">B = C; // 赋值运算符</div></pre></td></tr></table></figure>
</li>
<li><p>值传递传参</p>
</li>
<li>值传递返回<br>对于简单数据类型的数据成员，进行简单的赋值就可以了。对于对象数据成员，对象数据成员的复制构造函数依次被调用。<br>当 = 应用于两个已经构造的对象时，就会调用复制赋值运算符 operator=，默认情况下通过将其应用于每个数据成员的方式来实现。</li>
</ol>
<p>默认的析构函数、复制构造函数、operator= 都不会对指针指向的对象做任何的操作。<br>对于 IntCell，这些运算的签名是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">~IntCell();</div><div class="line">IntCell(const IntCell &amp; rhs);</div><div class="line">const IntCell &amp; operator=(const IntCell &amp; rhs);</div></pre></td></tr></table></figure></p>
<p>其中 operator= 的返回值类型和参数类型是一样的，是为了 a=b=c 这样的连续复制赋值运算符的调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">IntCell::~IntCell()&#123;</div><div class="line">    // Does nothing;</div><div class="line">    // If IntCell contained any class objects, their destructors would be called.</div><div class="line">&#125;</div><div class="line">IntCell::IntCell(const IntCell &amp; rhs):storedValue(rhs.storedValue)&#123;</div><div class="line">&#125;</div><div class="line">const IntCell &amp; operator=(const IntCell &amp; rhs)&#123;</div><div class="line">    // Standard alias test</div><div class="line">    if (this != &amp;rhs)&#123;</div><div class="line">        storedValue = rhs.storedValue;</div><div class="line">    &#125;</div><div class="line">    return *this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="C-风格的数组和字符串"><a href="#C-风格的数组和字符串" class="headerlink" title="C 风格的数组和字符串"></a>C 风格的数组和字符串</h4><p><code>int arr[10];</code> 中 <code>arr</code> 实际上是一个指向足够存储10 个int的内存空间的指针，而且是常量指针。当 <code>arr</code> 传递给一个函数时，只有指针的值被传递，而数组的大小信息则丢失了，因此数组的大小必须作为一个附加参数进行传递，由于数组的大小未知，也就没有关于索引范围的检查。<br>在上面的定义中，在编译的时候数组的大小就必须被指定，如果数组的大小位置，就必须显式地声明一个指针，并用 new int[] 来分配内存。<br><code>int *arr = new int[n];</code>，<code>arr</code> 不再是常量指针，由于内存是动态分配地，需要使用 delete [] 进行释放，如果不释放，当数组很大时，泄露就会很严重。<br>内置的C风格字符串，就是字符数组来实现的，特殊的终止符’\0’用以标识字符串逻辑上的结束，以避免传递字符串的长度值。字符串可以使用’strcpy’，’strcmp’，’strlen’，这些字符串具有数组具有的所有问题，困难的内存管理问题。譬如当字符串进行复制的时候，总是假设目标数组数据空间是足够大的，如果空间不够大，常常会因为没有存储字符串终止符的空间而导致调试的极大困难。</p>
<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>这本书描述的算法和数据结构都是类型无关的，当编写 C++ 代码的类型无关的算法或者数据结构时，我们更愿意只写一次，而不是为不同的类型都写一遍。在 C++ 中使用模板来写类型无关的算法，即泛型编程。<br>函数模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Return the maximum item in array a.</div><div class="line"> * Assumes a.size() &gt; 0.</div><div class="line"> * Comparable objects must provide operator &gt; and operator =</div><div class="line">*/</div><div class="line">template &lt;typename Comparable&gt;</div><div class="line">const Comparable &amp; findMax(vector&lt;Comparable&gt; &amp; a)&#123;</div><div class="line">    int maxIndex = 0;</div><div class="line"></div><div class="line">    for(int i=1;i&lt;a.size();i++)&#123;</div><div class="line">        if(a[maxIndex] &lt; a[i])&#123;</div><div class="line">            maxIndex = i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return a[maxIndex];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int main()&#123;</div><div class="line">    vector&lt;int&gt; v1(37);</div><div class="line">    vector&lt;double&gt; v2(37);</div><div class="line">    vector&lt;string&gt; v3(37);</div><div class="line">    vector&lt;IntCell&gt; v4(37);</div><div class="line"></div><div class="line">    // Additional code to fill in the  vectors not shown;</div><div class="line"></div><div class="line">    cout &lt;&lt; findMax(v1) &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; findMax(v2) &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; findMax(v3) &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; findMax(v4) &lt;&lt; endl; // Illegal; operator &lt; undefined;</div><div class="line"></div><div class="line">    return 0;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类模板</p>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/RobertLexis" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2018 Robert Lexis<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>