<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="epollepoll is a Linux kernel system call for a scalable I/O event notification mechanism. Its function is to monitor multiple file descriptors to see if I/O is possible on any of them. It is meant to">
<meta property="og:type" content="article">
<meta property="og:title" content="For FreeWheel">
<meta property="og:url" content="http://yoursite.com/2018/05/17/For-FreeWheel/index.html">
<meta property="og:site_name" content="The next stop - Antarctica">
<meta property="og:description" content="epollepoll is a Linux kernel system call for a scalable I/O event notification mechanism. Its function is to monitor multiple file descriptors to see if I/O is possible on any of them. It is meant to">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-08-26T11:03:49.401Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="For FreeWheel">
<meta name="twitter:description" content="epollepoll is a Linux kernel system call for a scalable I/O event notification mechanism. Its function is to monitor multiple file descriptors to see if I/O is possible on any of them. It is meant to">

<link rel="canonical" href="http://yoursite.com/2018/05/17/For-FreeWheel/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>For FreeWheel | The next stop - Antarctica</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">The next stop - Antarctica</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">To see behind walls. To draw closer.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/17/For-FreeWheel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fengcun Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The next stop - Antarctica">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          For FreeWheel
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-05-17 18:52:29" itemprop="dateCreated datePublished" datetime="2018-05-17T18:52:29+08:00">2018-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-08-26 19:03:49" itemprop="dateModified" datetime="2018-08-26T19:03:49+08:00">2018-08-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll is a Linux kernel <strong>system call</strong> for a scalable <strong>I/O event notification mechanism</strong>. Its function is to monitor multiple file descriptors to see if I/O is possible on any of them. It is meant to replace the older POSIX select(2) and poll(2) system calls, to achieve better performance in more demanding applications, where the number of watched file descriptors is large (unlike the older system calls, which operate in O(n) time, epoll operates in O(1) time).<br><a id="more"></a></p>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create1(int flags);</span><br></pre></td></tr></table></figure>
<p>Creates an epoll object and returns its file descriptor(标识内核事件表). The flags parameter allows epoll behavior to be modified. It has only one valid value, EPOLL_CLOEXEC. epoll_create() is an older variant of epoll_create1() and is deprecated as of Linux kernel version 2.6.27 and glibc version 2.9.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br></pre></td></tr></table></figure></p>
<p>Controls (configures) which file descriptors are watched by this object, and for which events. op can be ADD, MODIFY or DELETE.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure></p>
<p>Waits for any of the events registered for with epoll_ctl, until at least one occurs or the timeout elapses. Returns the occurred events in events, up to maxevents at once.</p>
<h4 id="Triggering-modes"><a href="#Triggering-modes" class="headerlink" title="Triggering modes"></a>Triggering modes</h4><p>epoll provides both edge-triggered and level-triggered modes. In edge-triggered mode, a call to epoll_wait will return only when a new event is enqueued with the epoll object, while in level-triggered mode, epoll_wait will return as long as the condition holds（可读）.</p>
<p>For instance, if a pipe registered with epoll has received data, a call to epoll_wait will return, signaling the presence of data to be read. Suppose the reader only consumed part of data from the buffer. In level-triggered mode, further calls to epoll_wait will return immediately, as long as the pipe’s buffer contains data to be read. （每次读一部分就可以了，因为会不断地触发）In edge-triggered mode, however, epoll_wait will return only once new data is written to the pipe.（因此需要一次性读完）<br>ET 是高效工作模式，很大程度上降低同一个事件被重复触发的次数。</p>
<h2 id="HTTP-Hypertext-Transfer-Protocol"><a href="#HTTP-Hypertext-Transfer-Protocol" class="headerlink" title="HTTP Hypertext Transfer Protocol"></a>HTTP Hypertext Transfer Protocol</h2><p>Client request<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br></pre></td></tr></table></figure></p>
<p>Server response<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 23 May 2005 22:38:34 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Content-Encoding: UTF-8</span><br><span class="line">Content-Length: 138</span><br><span class="line">Last-Modified: Wed, 08 Jan 2003 23:11:55 GMT</span><br><span class="line">Server: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)</span><br><span class="line">ETag: &quot;3f80f-1b6-3e1cb03b&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Connection: close</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;An Example Page&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  Hello World, this is a very simple HTML document.</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>Status codes<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Informational 1XX</span><br><span class="line">Successful 2XX</span><br><span class="line">Redirection 3XX</span><br><span class="line">Client Error 4XX</span><br><span class="line">Server Error 5XX</span><br></pre></td></tr></table></figure></p>
<p>The <strong>ETag (entity tag)</strong> header field is used to determine if a cached version of the requested resource is identical to the current version of the resource on the server.<br>Content-Type specifies the Internet media type of the data conveyed by the HTTP message, while Content-Length indicates its length in bytes. The HTTP/1.1 webserver publishes its ability to respond to requests for certain byte ranges of the document by setting the field Accept-Ranges: bytes. This is useful, if the client needs to have only certain portions of a resource sent by the server, which is called <strong>byte serving</strong>.<br>When Connection: close is sent, it means that the web server will close the TCP connection immediately after the transfer of this response.<br>A Content-Encoding like gzip can be used to compress the transmitted data.</p>
<h4 id="Message-format"><a href="#Message-format" class="headerlink" title="Message format"></a>Message format</h4><p>The client and server communicate by sending plain-text (ASCII) messages. The client sends requests to the server and the server sends responses.</p>
<h6 id="Request-message"><a href="#Request-message" class="headerlink" title="Request message"></a>Request message</h6><p>The request message consists of the following:<br><strong>A request line</strong> (e.g., GET /images/logo.png HTTP/1.1, which requests a resource called /images/logo.png from the server).<br><strong>Request header fields</strong> (e.g., Accept-Language: en).<br>An empty line.<br>An optional message body.<br>The request line and other header fields must each end with <cr><lf>. The empty line must consist of only <cr><lf> and no other whitespace. In the HTTP/1.1 protocol, all header fields except Host are optional.</lf></cr></lf></cr></p>
<h6 id="Response-message"><a href="#Response-message" class="headerlink" title="Response message"></a>Response message</h6><p>The response message consists of the following:<br><strong>A status line</strong> which includes the status code and reason message (e.g., HTTP/1.1 200 OK, which indicates that the client’s request succeeded).<br><strong>Response header fields</strong> (e.g., Content-Type: text/html).<br>An empty line.<br>An optional message body.<br>The status line and other header fields must all end with <cr><lf>. The empty line must consist of only <cr><lf> and no other whitespace.</lf></cr></lf></cr></p>
<h2 id="C-内存布局"><a href="#C-内存布局" class="headerlink" title="C++ 内存布局"></a>C++ 内存布局</h2><p>在 C++ 中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。</p>
<ol>
<li>栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li>
<li>堆，就是那些由 new 分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</li>
<li>自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。</li>
<li>全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。</li>
<li>常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。</li>
</ol>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>Fork (system call)<br>In computing, particularly in the context of the Unix operating system, fork is an operation whereby a process creates a copy of itself. It is usually a system call, implemented in the kernel. Fork is the primary (and historically, only) method of process creation on Unix-like operating systems.</p>
<h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><p>In multitasking operating systems, processes (running programs) need a way to create new processes, e.g. to run other programs. Fork and its variants are typically the only way of doing so in Unix-like systems. For a process to start the execution of a different program, it first forks to create a copy of itself. Then, the copy, called the “child process”, calls the <strong>exec system call</strong> to overlay itself with the other program: it ceases execution of its former program in favor of the other.</p>
<p>The fork operation creates a separate <strong>address space</strong> for the child. The child process has an exact copy of all the memory segments of the parent process. In modern UNIX variants that follow the <strong>virtual memory model</strong> from SunOS-4.0, <strong>copy-on-write</strong> semantics are implemented and the physical memory need not be actually copied. Instead, <strong>virtual memory pages in both processes may refer to the same pages of physical memory until one of them writes to such a page: then it is copied</strong>. This optimization is important in the common case where fork is used in conjunction with exec to execute a new program: typically, the child process performs only a small set of actions before it ceases execution of its program in favour of the program to be started, and it requires very few, if any, of its parent’s data structures.<br>堆、栈、全局/静态存储区均被复制成独立的两份，但打开的文件等是同一个，总不能因为 fork 复制进程映像就去拷贝文件吧。</p>
<h2 id="strcpy-memcpy-memset"><a href="#strcpy-memcpy-memset" class="headerlink" title="strcpy/memcpy/memset"></a>strcpy/memcpy/memset</h2><p>都是标准 C 库函数。</p>
<h4 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h4><p>strcpy 提供了字符串的复制。即 strcpy 只用于字符串复制，并且它不仅复制字符串内容，还会复制字符串的结束符。<br>strcpy 函数的原型是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char* strcpy(char* dest, const char* src);</span><br></pre></td></tr></table></figure></p>
<p>实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char * strcpy(char * dest, const char * src) // 实现src到dest的复制 </span><br><span class="line">&#123; </span><br><span class="line">　　if ((src == NULL) || (dest == NULL)) // 判断参数src和dest的有效性 </span><br><span class="line">　　&#123;</span><br><span class="line"></span><br><span class="line">　　　　　　return NULL; </span><br><span class="line">　　&#125; </span><br><span class="line">　　char *strdest = dest; // 保存目标字符串的首地址 </span><br><span class="line">　　while ((*dest++ = *src++)!=’\0’); // 把src字符串的内容复制到dest下 </span><br><span class="line">　　return strdest; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h4><p>memcpy 提供了一般内存的复制。即 memcpy 对于需要复制的内容没有限制，因此用途更广。<br>函数的原型是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void *memcpy( void *dest, const void *src, size_t count );</span><br></pre></td></tr></table></figure></p>
<p>实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void *memcpy(void *memTo, const void *memFrom, size_t size) </span><br><span class="line">&#123; </span><br><span class="line">　　if((memTo == NULL) || (memFrom == NULL)) // memTo和memFrom必须有效 </span><br><span class="line">        return NULL; </span><br><span class="line">　　char* tempFrom = (char* )memFrom; // 保存memFrom首地址 </span><br><span class="line">　　char* tempTo = (char* )memTo; // 保存memTo首地址 </span><br><span class="line">　　while(size-–&gt;0) // 循环size次，复制memFrom的值到memTo中 </span><br><span class="line">        *tempTo++ = *tempFrom++ ; </span><br><span class="line">　　return memTo; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>说明： memTo 和 memFrom 所指内存区域不能重叠，函数返回指向 memTo 的指针.可以拿它拷贝任何数据类型的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char a[10],b[5];              </span><br><span class="line">memcpy(b, a, sizeof(b)); /*注意如果用sizeof(a)，会造成b的内存地址溢出*/</span><br></pre></td></tr></table></figure></p>
<h4 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h4><p>把 buffer 所指内存区域的前 count 个字节设置成字符 c，主要用于初始化某个内存空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern void *memset(void *buffer, int c, int count);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char a[10];                        </span><br><span class="line">memset(a, &apos;\0&apos;, sizeof(a));</span><br></pre></td></tr></table></figure>
<h4 id="strcpy-和-memcpy-主要有以下3方面的区别。"><a href="#strcpy-和-memcpy-主要有以下3方面的区别。" class="headerlink" title="strcpy 和 memcpy 主要有以下3方面的区别。"></a>strcpy 和 memcpy 主要有以下3方面的区别。</h4><p>1、复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。<br>2、复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。<br>3、用途不同。<br>emcpy和strcpy区别以及它们的效率分析<br>2015年08月13日 17:46:21<br>阅读数：3457<br>1、首先介绍这两个函数的原型：</p>
<p> #include <cstring><br>char <em>strcpy( char </em>to, const char *from );</cstring></p>
<p> #include <cstring><br>  void <em>memcpy( void </em>to, const void *from, size_t count );<br>从以上两个函数的参数类型和返回类型，可以看出两个函数的第一个不同点：<br>a、strcpy只能应用字符类型的复制，而memcpy应用范围更广，任何类型都可以；</cstring></p>
<p>其次，函数memcpy多了一个count参数，用于拷贝指定字节大小的数据。从这可以得出它们的第二个不同点，</p>
<p>b、memcpy相比使用strcpy会更加的安全，当然也可以使用strcpy的安全板本strncpy函数；</p>
<p>从表面我们还是不能看到这两个函数更加深入的异同，以及它们到底哪个效率更高。下面从它们的源码出发，期望可以解决问题。</p>
<p>2、strcpy函数和memcpy的源码的windows版本</p>
<p>strcpy函数源码：</p>
<p>[cpp] view plain copy<br>char <em> __cdecl strcpy(char </em> dst, const char <em> src)<br>{<br>        char </em> cp = dst;  </p>
<pre><code>while( *cp++ = *src++ )  
        ;               /* Copy src over dst */  

return( dst );  
</code></pre><p>}  </p>
<p>memcpy函数源码：<br>[cpp] view plain copy<br>void <em> __cdecl memcpy (<br>        void </em> dst,<br>        const void <em> src,<br>        size_t count<br>        )<br>{<br>        void </em> ret = dst;  </p>
<p>#if defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC)<br>        {<br>        extern void RtlMoveMemory( void <em>, const void </em>, size_t count );  </p>
<pre><code>RtlMoveMemory( dst, src, count );  
}  
</code></pre><p>#else  /<em> defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) </em>/<br>        /* </p>
<pre><code> * copy from lower addresses to higher addresses 
 */  
while (count--) {  
        *(char *)dst = *(char *)src;  
        dst = (char *)dst + 1;  
        src = (char *)src + 1;  
}  
</code></pre><p>#endif  /<em> defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) </em>/  </p>
<pre><code>return(ret);  
</code></pre><p>}  </p>
<p>memcpy中的预定义不用考虑，现在都不支持了，先分析strcpy源码中关键代码：<br>[cpp] view plain copy<br>while( <em>cp++ = </em>src++ )<br>可以看出该循环退出的条件是*cp = ‘\0’，也就是说，源字符串中的结尾‘\0’也被拷贝到目的字符串中，这个很关键。<br>而memcpy中退出循环是count为0,也就是按照用户的要求，拷贝count个字节。</p>
<p>所以从这可以得出两个函数的第3个不同点：</p>
<p>C、strcpy一定会拷贝字符串结尾符’\0’，memcpy在拷贝字符串的时候，根据指定拷贝字节数拷贝字符串，是否拷贝‘\0’结束符，根据count的大小。</p>
<p>最后，从两个函数的源码中，可以分析出哪个函数的效率更快（当然是都拷贝相同的字符串），比较它们的关键代码，也就是循环，可以看出，memcpy函数中，有3个变量在变化，分别是count, dst, src，而strcpy只有两个变量变化，分别是cp和src，从这可以看出strcpy更胜一筹。再者，</p>
<p>[cpp] view plain copy<br><em>cp++ = </em>src++   和   <pre name="code" class="cpp"><em>(char </em>)dst = <em>(char </em>)src;<br>dst = (char <em>)dst + 1;<br>src = (char </em>)src + 1;<br>效果是一样，但下面耗费更大，它有类型转换的花费，在上面中没有的，从这也可以看出strcpy更胜一筹。</pre></p>
<p>综上两点，我认为在拷贝相同字符串，相同字节的情况下，strcpy的效率比memcpy效率更高。</p>
<p>3、下面再实践证明下，如下图。</p>
<p>测试代码：</p>
<p>[cpp] view plain copy</p>
<p>#include &lt;stdio.h&gt;  </p>
<p>#include &lt;string.h&gt;<br>int main()<br>{<br>    char src[] = “hello,memcpy and strcpy!”;<br>    char dest[32];<br>    memcpy(dest, src, 25);<br>    //strcpy(dest, src);<br>    return 0;<br>}  </p>
<p>运行上面代码用时如下：</p>
<p>将memcpy(dest, src, 25);注释，取消下面strcpy(dest, src）运行代码用时如下：</p>
<p>从上可以看出，strcpy以微弱的优势，相比memcpy效率更快。</p>
<p>所以memcpy和strcpy的第四个不同点是：</p>
<p>d、在拷贝相同的字符串，且字节数相同(包括‘]0’)的情况下，strcpy效率比memcpy效率更快。</p>
<p>4、总结，memcpy和strcpy的区别与比较</p>
<p>a、strcpy只能应用字符类型的复制，而memcpy应用范围更广，任何类型都可以；</p>
<p>b、memcpy相比使用strcpy会更加的安全，当然也可以使用strcpy的安全板本strncpy函数；</p>
<p>c、strcpy一定会拷贝字符串结尾符’\0’，memcpy在拷贝字符串的时候，根据指定拷贝字节数拷贝字符串，是否拷贝‘\0’结束符，根据count的大小;</p>
<p>d、在拷贝相同的字符串，且字节数相同(包括‘]0’)的情况下，strcpy效率比memcpy效率更快。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/05/17/ssd-源码分析/" rel="prev" title="Ssd 源码分析">
      <i class="fa fa-chevron-left"></i> Ssd 源码分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/05/28/Deep-learning-资料汇总/" rel="next" title="Deep Learning 资料汇总">
      Deep Learning 资料汇总 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll"><span class="nav-number">1.</span> <span class="nav-text">epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#API"><span class="nav-number">1.0.1.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Triggering-modes"><span class="nav-number">1.0.2.</span> <span class="nav-text">Triggering modes</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-Hypertext-Transfer-Protocol"><span class="nav-number">2.</span> <span class="nav-text">HTTP Hypertext Transfer Protocol</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Message-format"><span class="nav-number">2.0.1.</span> <span class="nav-text">Message format</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Request-message"><span class="nav-number">2.0.1.0.1.</span> <span class="nav-text">Request message</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Response-message"><span class="nav-number">2.0.1.0.2.</span> <span class="nav-text">Response message</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-内存布局"><span class="nav-number">3.</span> <span class="nav-text">C++ 内存布局</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fork"><span class="nav-number">4.</span> <span class="nav-text">fork</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Overview"><span class="nav-number">4.0.1.</span> <span class="nav-text">Overview</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#strcpy-memcpy-memset"><span class="nav-number">5.</span> <span class="nav-text">strcpy/memcpy/memset</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#strcpy"><span class="nav-number">5.0.1.</span> <span class="nav-text">strcpy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#memcpy"><span class="nav-number">5.0.2.</span> <span class="nav-text">memcpy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#memset"><span class="nav-number">5.0.3.</span> <span class="nav-text">memset</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#strcpy-和-memcpy-主要有以下3方面的区别。"><span class="nav-number">5.0.4.</span> <span class="nav-text">strcpy 和 memcpy 主要有以下3方面的区别。</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fengcun Li"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Fengcun Li</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fengcun Li</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
