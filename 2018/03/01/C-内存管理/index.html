<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="C++内存管理内存管理在C++中无处不在，内存泄漏几乎在每个C++程序中都会发生，因此要想成为C++高手，内存管理一关是必须要过的，除非放弃C++，转到Java或者.NET，他们的内存管理基本是自动的，当然你也放弃了自由和对内存的支配权，还放弃了C++超绝的性能。本期专题将从内存管理、内存泄漏、内存">
    

    <!--Author-->
    
        <meta name="author" content="Robert Lexis">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="C++内存管理"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="This is WHY."/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>C++内存管理 - This is WHY.</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
    </div>
</header>

        <section class="main">
            
<div class="post">

    <div class="post-header">
        <h1 class="title">
            <a href="/2018/03/01/C-内存管理/">
                C++内存管理
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-03-01</span>
            
            
            
        </div>
    </div>

    <div class="content">

        <!-- Gallery -->
        

        <!-- Post Content -->
        <h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h2><p>内存管理在C++中无处不在，内存泄漏几乎在每个C++程序中都会发生，因此要想成为C++高手，内存管理一关是必须要过的，除非放弃C++，转到Java或者.NET，他们的内存管理基本是自动的，当然你也放弃了自由和对内存的支配权，还放弃了C++超绝的性能。<br>本期专题将从内存管理、内存泄漏、内存回收这三个方面来探讨C++内存管理问题。</p>
<h3 id="1-内存管理"><a href="#1-内存管理" class="headerlink" title="1. 内存管理"></a>1. 内存管理</h3><h4 id="1-1-C-内存管理详解"><a href="#1-1-C-内存管理详解" class="headerlink" title="1.1 C++内存管理详解"></a>1.1 C++内存管理详解</h4><h5 id="1-1-1-内存分配方式"><a href="#1-1-1-内存分配方式" class="headerlink" title="1.1.1 内存分配方式"></a>1.1.1 内存分配方式</h5><h5 id="1-1-1-1-分配方式简介"><a href="#1-1-1-1-分配方式简介" class="headerlink" title="1.1.1.1 分配方式简介"></a>1.1.1.1 分配方式简介</h5><p>　　在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。</p>
<p>　　栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>
<p>　　堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p>
<p>　　自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。</p>
<p>　　全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。</p>
<p>　　常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。</p>
<h6 id="1-1-1-2-明确区分堆与栈"><a href="#1-1-1-2-明确区分堆与栈" class="headerlink" title="1.1.1.2 明确区分堆与栈"></a>1.1.1.2 明确区分堆与栈</h6><p>首先，我们举一个例子：</p>
<p>void f() { int* p=new int[5]; }</p>
<p>　　这条短短的一句话就包含了堆与栈，看到new，我们首先就应该想到，我们分配了一块堆内存，那么指针p呢？他分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针p。在程序会先确定在堆中分配内存的大小，然后调用operator new分配内存，然后返回这块内存的首地址，放入栈中，他在VC6下的汇编代码如下：</p>
<p>00401028 push 14h</p>
<p>0040102A call operator new (00401060)</p>
<p>0040102F add esp,4</p>
<p>00401032 mov dword ptr [ebp-8],eax</p>
<p>00401035 mov eax,dword ptr [ebp-8]</p>
<p>00401038 mov dword ptr [ebp-4],eax</p>
<p>　　这里，我们为了简单并没有释放内存，那么该怎么去释放呢？是delete p么？澳，错了，应该是delete []p，这是为了告诉编译器：我删除的是一个数组，VC6就会根据相应的Cookie信息去进行释放内存的工作。</p>
<h6 id="1-1-1-3-堆和栈究竟有什么区别？"><a href="#1-1-1-3-堆和栈究竟有什么区别？" class="headerlink" title="1.1.1.3 堆和栈究竟有什么区别？"></a>1.1.1.3 堆和栈究竟有什么区别？</h6><p>堆和栈究竟有什么区别？<br>主要的区别由以下几点：</p>
<ol>
<li>管理方式不同；</li>
<li>空间大小不同；</li>
<li>能否产生碎片不同；</li>
<li>生长方向不同；</li>
<li>分配方式不同；</li>
<li>分配效率不同；<br>管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。<br>空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改：<br>打开工程，依次操作菜单如下：Project-&gt;Setting-&gt;Link，在Category 中选中Output，然后在Reserve中设定堆栈的最大值和commit。<br>注意：reserve最小值为4Byte；commit是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。<br>碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。<br>生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。<br>分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 alloca 函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。<br>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。<br>从这里我们可以看到，堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP(扩展基址指针寄存器(extended base pointer) 其内存放一个指针，该指针指向系统栈最上面一个栈帧的底部)和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。<br>虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。<br>无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果。</li>
</ol>
<h5 id="1-1-2-控制C-的内存分配"><a href="#1-1-2-控制C-的内存分配" class="headerlink" title="1.1.2 控制C++的内存分配"></a>1.1.2 控制C++的内存分配</h5><p>在嵌入式系统中使用C++的一个常见问题是内存分配，即对 new 和 delete 操作符的失控。<br>具有讽刺意味的是，问题的根源却是C++对内存的管理非常的容易而且安全。具体地说，当一个对象被消除时，它的析构函数能够安全的释放所分配的内存。这当然是个好事情，但是这种使用的简单性使得程序员们过度使用new 和 delete，而不注意在嵌入式C++环境中的因果关系。并且，在嵌入式系统中，由于内存的限制，频繁的动态分配不定大小的内存会引起很大的问题以及堆破碎的风险。<br>作为忠告，保守的使用内存分配是嵌入式环境中的第一原则。但当你必须要使用new 和delete时，你不得不控制C++中的内存分配。<strong>你需要用一个全局的new 和delete来代替系统的内存分配符，并且一个类一个类的重载new 和delete。<br>一个防止堆破碎的通用方法是从不同固定大小的内存池中分配不同类型的对象。对每个类重载new 和delete就提供了这样的控制。</strong></p>
<h6 id="1-1-2-1-重载全局的new和delete操作符"><a href="#1-1-2-1-重载全局的new和delete操作符" class="headerlink" title="1.1.2.1 重载全局的new和delete操作符"></a>1.1.2.1 重载全局的new和delete操作符</h6><p>可以很容易地重载new 和 delete 操作符，如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void * operator new(size_t size)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">void *p = malloc(size);</div><div class="line"></div><div class="line">return (p);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">void operator delete(void *p);</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">free(p);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码可以代替默认的操作符来满足内存分配的请求。<br>也可以对单个类的new 和 delete 操作符重载。这是你能灵活的控制对象的内存分配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">class A</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    A(): name(&quot;Jasmine&quot;) &#123;&#125;;</div><div class="line">    ~A()&#123;&#125;;</div><div class="line">    void * operator new(size_t);</div><div class="line">    void operator delete(void*);</div><div class="line">    string name;</div><div class="line">&#125;;</div><div class="line">void * A::operator new(size_t size) &#123;</div><div class="line">    cout &lt;&lt; &quot;Newing&quot; &lt;&lt; endl;</div><div class="line">    void * p = malloc(size);</div><div class="line">    return p;</div><div class="line">&#125;</div><div class="line">void A::operator delete(void *p) &#123;</div><div class="line">    cout &lt;&lt; &quot;Deleting&quot; &lt;&lt; endl;</div><div class="line">    free(p);</div><div class="line">&#125;</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    A * a = new A;</div><div class="line">    cout &lt;&lt; a-&gt;name &lt;&lt; endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Newing</div><div class="line">Jasmine</div></pre></td></tr></table></figure></p>
<p>所有A 对象的内存分配都采用这段代码。更进一步，任何从A 继承的类也都采用这一方式，除非它自己也重载了new 和 delete 操作符。通过重载new 和 delete 操作符的方法，你可以自由地采用不同的分配策略，从不同的内存池中分配不同的类对象。</p>
<h6 id="1-1-2-2-为单个的类重载-new-和delete"><a href="#1-1-2-2-为单个的类重载-new-和delete" class="headerlink" title="1.1.2.2 为单个的类重载 new[ ]和delete[ ]"></a>1.1.2.2 为单个的类重载 new[ ]和delete[ ]</h6><p>必须小心对象数组的分配。你可能希望调用到被你重载过的new 和 delete 操作符，但并不如此。内存的请求被定向到全局的new[ ]和delete[ ] 操作符，而这些内存来自于系统堆。<br>C++将对象数组的内存分配作为一个单独的操作，而不同于单个对象的内存分配。为了改变这种方式，你同样需要重载new[ ] 和 delete[ ]操作符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class TestClass &#123;</div><div class="line">public:</div><div class="line">void * operator new[ ](size_t size);</div><div class="line">void operator delete[ ](void *p);</div><div class="line">// .. other members here ..</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void *TestClass::operator new[ ](size_t size)</div><div class="line">&#123;</div><div class="line">void *p = malloc(size);</div><div class="line">return (p);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void TestClass::operator delete[ ](void *p)</div><div class="line">&#123;</div><div class="line">free(p);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">TestClass *p = new TestClass[10];</div><div class="line">// ... etc ...</div><div class="line">delete[ ] p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是注意，对于多数C++的实现，new[]操作符中的个数参数是数组的大小加上额外的存储对象数目的一些字节。在你的内存分配机制中要考虑的这一点。你应该尽量避免分配对象数组，从而使你的内存分配策略简单。</p>
<h5 id="1-1-3-常见的内存错误及其对策"><a href="#1-1-3-常见的内存错误及其对策" class="headerlink" title="1.1.3 常见的内存错误及其对策"></a>1.1.3 常见的内存错误及其对策</h5><p>发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。有时用户怒气冲冲地把你找来，程序却没有发生任何问题，你一走，错误又发作了。 常见的内存错误及其对策如下：</p>
<ol>
<li>内存分配未成功，却使用了它。<br>编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。</li>
<li>内存分配虽然成功，但是尚未初始化就引用它。<br>犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。</li>
<li>内存分配成功并且已经初始化，但操作越过了内存的边界。<br>例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。</li>
<li>忘记了释放内存，造成内存泄露。<br>含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。</li>
<li>释放了内存却继续使用它。<br>有三种情况：<ul>
<li>程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。</li>
<li>函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。</li>
<li>使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。<br>　　【规则1】用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。<br>　　【规则2】不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。<br>　　【规则3】避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。<br>　　【规则4】动态内存的申请与释放必须配对，防止内存泄漏。<br>　　【规则5】用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。</li>
</ul>
</li>
</ol>
<h5 id="1-1-4-指针与数组的对比"><a href="#1-1-4-指针与数组的对比" class="headerlink" title="1.1.4 指针与数组的对比"></a>1.1.4 指针与数组的对比</h5><p>C++/C程序中，指针和数组在不少地方可以相互替换着用，让人产生一种错觉，以为两者是等价的。<br>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而不是指向）一块内存，其地址与容量在生命期内保持不变，只有数组的内容可以改变。<br>指针可以随时指向任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。<br>下面以字符串为例比较指针与数组的特性。</p>
<h6 id="1-1-4-1-修改内容"><a href="#1-1-4-1-修改内容" class="headerlink" title="1.1.4.1 修改内容"></a>1.1.4.1 修改内容</h6><p>下面示例中，字符数组a的容量是6个字符，其内容为hello。a的内容可以改变，如a[0]= ‘X’。指针p指向常量字符串“world”（位于静态存储区，内容为world），常量字符串的内容是不可以被修改的。从语法上看，编译器并不觉得语句p[0]= ‘X’有什么不妥，但是该语句企图修改常量字符串的内容而导致运行错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">char a[] = &quot;hello&quot;;</div><div class="line">a[0] = &apos;X&apos;;</div><div class="line">cout &lt;&lt; a &lt;&lt; endl;</div><div class="line">char *p = &quot;world&quot;; // 注意p指向常量字符串</div><div class="line">p[0] = &apos;X&apos;; // 编译器不能发现该错误，有的编译器会报出警告：</div><div class="line">// warning: ISO C++ forbids converting a string constant to &apos;char*&apos; [-Wwrite-strings]</div><div class="line">// 编译能够通过，但是会导致运行时错误。</div><div class="line">cout &lt;&lt; p &lt;&lt; endl;</div></pre></td></tr></table></figure></p>
<h6 id="1-1-4-2-内容复制与比较"><a href="#1-1-4-2-内容复制与比较" class="headerlink" title="1.1.4.2 内容复制与比较"></a>1.1.4.2 内容复制与比较</h6><p>不能对数组名进行直接复制与比较。若想把数组a的内容复制给数组b，不能用语句 b = a ，否则将产生编译错误。应该用标准库函数strcpy进行复制。同理，比较b和a的内容是否相同，不能用if(b==a) 来判断，应该用标准库函数strcmp进行比较。<br>语句p = a 并不能把a的内容复制指针p，而是把a的地址赋给了p。要想复制a的内容，可以先用库函数malloc为p申请一块容量为strlen(a)+1个字符的内存，再用strcpy进行字符串复制。同理，语句if(p==a) 比较的不是内容而是地址，应该用库函数strcmp来比较。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 数组</div><div class="line">char a[] = &quot;hello&quot;;</div><div class="line">char b[10];</div><div class="line">strcpy(b, a); // 不能用 b = a;</div><div class="line">if(strcmp(b, a) == 0) // 不能用 if (b == a)</div><div class="line"></div><div class="line">// 指针</div><div class="line">int len = strlen(a);</div><div class="line">char *p = (char *)malloc(sizeof(char)*(len+1));</div><div class="line">strcpy(p,a); // 不要用 p = a;</div><div class="line">if(strcmp(p, a) == 0) // 不要用 if (p == a)</div></pre></td></tr></table></figure></p>
<h6 id="1-1-4-3-计算内存容量"><a href="#1-1-4-3-计算内存容量" class="headerlink" title="1.1.4.3 计算内存容量"></a>1.1.4.3 计算内存容量</h6><p>用运算符sizeof可以计算出数组的容量（字节数）。如下示例中，sizeof(a)的值是12（注意别忘了’’）。指针p指向a，但是sizeof(p)的值却是4。这是因为sizeof(p)得到的是一个指针变量的字节数，相当于sizeof(char*)，而不是p所指的内存容量。C++/C语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">char a[] = &quot;hello world&quot;;</div><div class="line">char *p = a;</div><div class="line">cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12字节</div><div class="line">cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4字节</div></pre></td></tr></table></figure></p>
<p>注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。如下示例中，不论数组a的容量是多少，sizeof(a)始终等于sizeof(char *)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void Func(char a[100])</div><div class="line">&#123;</div><div class="line">　cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4字节而不是100字节</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="1-1-5-杜绝“野指针”"><a href="#1-1-5-杜绝“野指针”" class="headerlink" title="1.1.5 杜绝“野指针”"></a>1.1.5 杜绝“野指针”</h5><p>“野指针”不是NULL指针，是指向“垃圾”内存的指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，if语句对它不起作用。 “野指针”的成因主要有两种：</p>
<ol>
<li><p>指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">char *p = NULL;</div><div class="line">char *str = (char *) malloc(100);</div></pre></td></tr></table></figure>
</li>
<li><p>指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。</p>
</li>
<li>指针操作超越了变量的作用域范围。这种情况让人防不胜防，示例程序如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">class A</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    void Func(void)&#123; cout &lt;&lt; &quot;Func of class A&quot; &lt;&lt; endl; &#125;</div><div class="line">&#125;;</div><div class="line">void Test(void)</div><div class="line">&#123;</div><div class="line">    A *p;</div><div class="line">    &#123;</div><div class="line">        A a;</div><div class="line">        p = &amp;a; // 注意 a 的生命期</div><div class="line">    &#125;</div><div class="line">    p-&gt;Func(); // p是“野指针”</div><div class="line">&#125;</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    Test();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>函数Test在执行语句p-&gt;Func()时，对象a已经消失，而p是指向a的，所以p就成了“野指针”。但奇怪的是我运行这个程序时居然没有出错，这可能与编译器有关。</p>
<h5 id="1-1-7-有了malloc-free为什么还要new-delete？"><a href="#1-1-7-有了malloc-free为什么还要new-delete？" class="headerlink" title="1.1.7 有了malloc/free为什么还要new/delete？"></a>1.1.7 有了malloc/free为什么还要new/delete？</h5><p>malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。<br>对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不能够把执行构造函数和析构函数的任务强加于malloc/free。</p>
<p>因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。我们先看一看malloc/free和new/delete如何实现对象的动态内存管理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Obj</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Obj(void)&#123; cout &lt;&lt; &quot;Initialization&quot; &lt;&lt; endl; &#125;</div><div class="line">    ~Obj(void)&#123; cout &lt;&lt; &quot;Destroy&quot; &lt;&lt; endl; &#125;</div><div class="line">    void Initialize(void)&#123; cout &lt;&lt; &quot;Initialization&quot; &lt;&lt; endl; &#125;</div><div class="line">    void Destroy(void)&#123; cout &lt;&lt; &quot;Destroy&quot; &lt;&lt; endl; &#125;</div><div class="line">&#125;;</div><div class="line">void UseMallocFree(void)</div><div class="line">&#123;</div><div class="line">    Obj *a = (Obj *)malloc(sizeof(Obj)); // 申请动态内存</div><div class="line">    a-&gt;Initialize(); // 初始化</div><div class="line">    //…</div><div class="line">    a-&gt;Destroy(); // 清除工作</div><div class="line">    free(a); // 释放内存</div><div class="line">&#125;</div><div class="line">void UseNewDelete(void)</div><div class="line">&#123;</div><div class="line">    Obj *a = new Obj; // 申请动态内存并且初始化</div><div class="line">    //…</div><div class="line">    delete a; // 清除并且释放内存</div><div class="line">&#125;</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    UseNewDelete();</div><div class="line">    UseMallocFree();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="1-1-8-内存耗尽怎么办？"><a href="#1-1-8-内存耗尽怎么办？" class="headerlink" title="1.1.8 内存耗尽怎么办？"></a>1.1.8 内存耗尽怎么办？</h5><p>如果在申请动态内存时找不到足够大的内存块，malloc和new将返回NULL指针，宣告内存申请失败。通常有三种方式处理“内存耗尽”问题。</p>
<ol>
<li>判断指针是否为NULL，如果是则马上用return语句终止本函数。</li>
<li>判断指针是否为NULL，如果是则马上用exit(1)终止整个程序的运行。</li>
<li>为new和malloc设置异常处理函数。例如Visual C++可以用_set_new_hander函数为new设置用户自己定义的异常处理函数，也可以让malloc享用与new相同的异常处理函数。</li>
</ol>
<h5 id="1-1-9-new-delete的使用要点"><a href="#1-1-9-new-delete的使用要点" class="headerlink" title="1.1.9 new/delete的使用要点"></a>1.1.9 new/delete的使用要点</h5><p>如果用new创建对象数组，那么只能使用对象的无参数构造函数。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Obj *objects = new Obj[100]; // 创建100个动态对象</div><div class="line">不能写成：</div><div class="line">Obj *objects = new Obj[100](1);// 创建100个动态对象的同时赋初值1</div></pre></td></tr></table></figure></p>
<h4 id="1-2-C-中的健壮指针和资源管理"><a href="#1-2-C-中的健壮指针和资源管理" class="headerlink" title="1.2 C++中的健壮指针和资源管理"></a>1.2 C++中的健壮指针和资源管理</h4><h4 id="2-3浅谈C-C-内存泄漏及其检测工具"><a href="#2-3浅谈C-C-内存泄漏及其检测工具" class="headerlink" title="2.3浅谈C/C++内存泄漏及其检测工具"></a>2.3浅谈C/C++内存泄漏及其检测工具</h4><h5 id="2-3-1-内存泄漏的定义"><a href="#2-3-1-内存泄漏的定义" class="headerlink" title="2.3.1 内存泄漏的定义"></a>2.3.1 内存泄漏的定义</h5><p>一般我们常说的内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的，大小任意的（内存块的大小可以在程序运行期决定），使用完后必须显示释放的内存。应用程序一般使用malloc，realloc，new等函数从堆中分配到一块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了。<br>广义的说，内存泄漏不仅仅包含堆内存的泄漏，还包含系统资源的泄漏(resource leak)，比如核心态HANDLE，GDI Object，SOCKET， Interface等，从根本上说这些由操作系统分配的对象也消耗内存，如果这些对象发生泄漏最终也会导致内存的泄漏。而且，某些对象消耗的是核心态内存，这些对象严重泄漏时会导致整个操作系统不稳定。所以相比之下，系统资源的泄漏比堆内存的泄漏更为严重。</p>
<h5 id="2-3-3-检测内存泄漏"><a href="#2-3-3-检测内存泄漏" class="headerlink" title="2.3.3 检测内存泄漏"></a>2.3.3 检测内存泄漏</h5><p>　　检测内存泄漏的关键是要能截获住对分配内存和释放内存的函数的调用。截获住这两个函数，我们就能跟踪每一块内存的生命周期，比如，每当成功的分配一块内存后，就把它的指针加入一个全局的list中；每当释放一块内存，再把它的指针从list中删除。这样，当程序结束的时候，list中剩余的指针就是指向那些没有被释放的内存。这里只是简单的描述了检测内存泄漏的基本原理，详细的算法可以参见Steve Maguire的&lt;<writing solid="" code="">&gt;。<br>　　如果要检测堆内存的泄漏，那么需要截获住malloc/realloc/free和new/delete就可以了（其实new/delete最终也是用malloc/free的，所以只要截获前面一组即可）。对于其他的泄漏，可以采用类似的方法，截获住相应的分配和释放函数。比如，要检测BSTR的泄漏，就需要截获SysAllocString/SysFreeString；要检测HMENU的泄漏，就需要截获CreateMenu/ DestroyMenu。（有的资源的分配函数有多个，释放函数只有一个，比如，SysAllocStringLen也可以用来分配BSTR，这时就需要截获多个分配函数）<br>　　在Windows平台下，检测内存泄漏的工具常用的一般有三种，MS C-Runtime Library内建的检测功能；外挂式的检测工具，诸如，Purify，BoundsChecker等；利用Windows NT自带的Performance Monitor。这三种工具各有优缺点，MS C-Runtime Library虽然功能上较之外挂式的工具要弱，但是它是免费的；Performance Monitor虽然无法标示出发生问题的代码，但是它能检测出隐式的内存泄漏的存在，这是其他两类工具无能为力的地方。</writing></p>
<h6 id="2-3-3-1-VC下内存泄漏的检测方法"><a href="#2-3-3-1-VC下内存泄漏的检测方法" class="headerlink" title="2.3.3.1 VC下内存泄漏的检测方法"></a>2.3.3.1 VC下内存泄漏的检测方法</h6><p>用 MFC 开发的应用程序，在DEBUG版模式下编译后，都会自动加入内存泄漏的检测代码。在程序结束后，如果发生了内存泄漏，在Debug窗口中会显示出所有发生泄漏的内存块的信息，以下两行显示了一块被泄漏的内存块的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">E:&quot;TestMemLeak&quot;TestDlg.cpp(70) : &#123;59&#125; normal block at 0x00881710, 200 bytes long.</div><div class="line"></div><div class="line">Data: &lt;abcdefghijklmnop&gt; 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F 70</div></pre></td></tr></table></figure></p>
<p>第一行显示该内存块由TestDlg.cpp文件，第70行代码分配，地址在0x00881710，大小为200字节，{59}是指调用内存分配函数的Request Order，关于它的详细信息可以参见MSDN中_CrtSetBreakAlloc()的帮助。第二行显示该内存块前16个字节的内容，尖括号内是以ASCII方式显示，接着的是以16进制方式显示。<br>一般大家都误以为这些内存泄漏的检测功能是由MFC提供的，其实不然。MFC只是封装和利用了MS C-Runtime Library的Debug Function。非MFC程序也可以利用MS C-Runtime Library的Debug Function加入内存泄漏的检测功能。MS C-Runtime Library在实现malloc/free，strdup等函数时已经内建了内存泄漏的检测功能。</p>
<p>注意观察一下由MFC Application Wizard生成的项目，在每一个cpp文件的头部都有这样一段宏定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#ifdef _DEBUG</div><div class="line"></div><div class="line">#define new DEBUG_NEW</div><div class="line"></div><div class="line">#undef THIS_FILE</div><div class="line"></div><div class="line">static char THIS_FILE[] = __FILE__;</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>注：这里的 static 是很有意义的，仅限于此编译单元的语义使得，每个实现文件即调用new的文件中的代码都能正确的知道各自所在的不同文件名。<br>有了这样的定义，在编译DEBUG版时，出现在这个cpp文件中的所有new都被替换成DEBUG_NEW了。那么DEBUG_NEW是什么呢？DEBUG_NEW也是一个宏，以下摘自afx.h，1632行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define DEBUG_NEW new(THIS_FILE, __LINE__)</div></pre></td></tr></table></figure></p>
<p>所以如果有这样一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">char* p = new char[200];</div></pre></td></tr></table></figure></p>
<p>经过宏替换就变成了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">char* p = new( THIS_FILE, __LINE__)char[200];</div></pre></td></tr></table></figure></p>
<p>根据C++的标准，对于以上的new的使用方法，编译器会去找这样定义的operator new：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void* operator new(size_t, LPCSTR, int)</div></pre></td></tr></table></figure></p>
<p>我们在afxmem.cpp 63行找到了一个这样的operator new 的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">void* AFX_CDECL operator new(size_t nSize, LPCSTR lpszFileName, int nLine)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">　return ::operator new(nSize, _NORMAL_BLOCK, lpszFileName, nLine);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">void* __cdecl operator new(size_t nSize, int nType, LPCSTR lpszFileName, int nLine)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">　…</div><div class="line"></div><div class="line">　pResult = _malloc_dbg(nSize, nType, lpszFileName, nLine);</div><div class="line"></div><div class="line">　if (pResult != NULL)</div><div class="line"></div><div class="line">　　return pResult;</div><div class="line"></div><div class="line">　…</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二个 operator new 函数比较长，为了简单期间，我只摘录了部分。很显然最后的内存分配还是通过_malloc_dbg函数实现的，这个函数属于MS C-Runtime Library 的Debug Function。这个函数不但要求传入内存的大小，另外还有文件名和行号两个参数。文件名和行号就是用来记录此次分配是由哪一段代码造成的。如果这块内存在程序结束之前没有被释放，那么这些信息就会输出到Debug窗口里。<br>这里顺便提一下<code>THIS_FILE</code>，<code>__FILE</code>和<code>__LINE__</code>。<code>__FILE__</code>和<code>__LINE__</code>都是编译器定义的宏。当碰到<code>__FILE__</code>时，编译器会把<code>__FILE__</code>替换成一个字符串，这个字符串就是当前在编译的文件的路径名。当碰到<code>__LINE__</code>时，编译器会把<code>__LINE__</code>替换成一个数字，这个数字就是当前这行代码的行号。在DEBUG_NEW的定义中没有直接使用<code>__FILE__</code>，而是用了<code>THIS_FILE</code>，其目的是为了减小目标文件的大小。假设在某个cpp文件中有100处使用了new，如果直接使用<code>__FILE__</code>，那编译器会产生100个常量字符串，这100个字符串都是文件的路径名，显然十分冗余。如果使用<code>THIS_FILE</code>，编译器只会产生一个常量字符串，那100处new的调用使用的都是指向常量字符串的指针。<br>再次观察一下由MFC Application Wizard生成的项目，我们会发现在cpp文件中只对new做了映射，如果你在程序中直接使用malloc函数分配内存，调用malloc的文件名和行号是不会被记录下来的。如果这块内存发生了泄漏，MS C-Runtime Library仍然能检测到，但是当输出这块内存块的信息，不会包含分配它的的文件名和行号。<br>要在非MFC程序中打开内存泄漏的检测功能非常容易，你只要在程序的入口处加入以下几行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );</div><div class="line"></div><div class="line">tmpFlag |= _CRTDBG_LEAK_CHECK_DF;</div><div class="line"></div><div class="line">_CrtSetDbgFlag( tmpFlag );</div></pre></td></tr></table></figure></p>
<p>这样，在程序结束的时候，也就是winmain，main或dllmain函数返回之后，如果还有内存块没有释放，它们的信息会被打印到Debug窗口里。<br>如果你试着创建了一个非MFC应用程序，而且在程序的入口处加入了以上代码，并且故意在程序中不释放某些内存块，你会在Debug窗口里看到以下的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;47&#125; normal block at 0x00C91C90, 200 bytes long.</div><div class="line"></div><div class="line">Data: &lt; &gt; 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F</div></pre></td></tr></table></figure></p>
<p>内存泄漏的确检测到了，但是和上面MFC程序的例子相比，缺少了文件名和行号。对于一个比较大的程序，没有这些信息，解决问题将变得十分困难。<br>为了能够知道泄漏的内存块是在哪里分配的，你需要实现类似MFC的映射功能，把new，maolloc等函数映射到_malloc_dbg函数上。这里我不再赘述，你可以参考MFC的源代码。<br>由于Debug Function实现在MS C-RuntimeLibrary中，所以它只能检测到堆内存的泄漏，而且只限于malloc，realloc或strdup等分配的内存，而那些系统资源，比如HANDLE，GDI Object，或是不通过C-Runtime Library分配的内存，比如VARIANT，BSTR的泄漏，它是无法检测到的，这是这种检测法的一个重大的局限性。另外，为了能记录内存块是在哪里分配的，源代码必须相应的配合，这在调试一些老的程序非常麻烦，毕竟修改源代码不是一件省心的事，这是这种检测法的另一个局限性。<br>对于开发一个大型的程序，MS C-Runtime Library提供的检测功能是远远不够的。接下来我们就看看外挂式的检测工具。我用的比较多的是BoundsChecker，一则因为它的功能比较全面，更重要的是它的稳定性。这类工具如果不稳定，反而会忙里添乱。到底是出自鼎鼎大名的NuMega，我用下来基本上没有什么大问题。</p>
<h6 id="2-3-3-2-使用BoundsChecker检测内存泄漏"><a href="#2-3-3-2-使用BoundsChecker检测内存泄漏" class="headerlink" title="2.3.3.2 使用BoundsChecker检测内存泄漏"></a>2.3.3.2 使用BoundsChecker检测内存泄漏</h6><p>BoundsChecker采用一种被称为 Code Injection的技术，来截获对分配内存和释放内存的函数的调用。简单地说，当你的程序开始运行时，BoundsChecker的DLL被自动载入进程的地址空间（这可以通过system-level的Hook实现），然后它会修改进程中对内存分配和释放的函数调用，让这些调用首先转入它的代码，然后再执行原来的代码。BoundsChecker在做这些动作的时，无须修改被调试程序的源代码或工程配置文件，这使得使用它非常的简便、直接。<br>这里我们以malloc函数为例，截获其他的函数方法与此类似。<br>需要被截获的函数可能在DLL中，也可能在程序的代码里。比如，如果静态连结C-Runtime Library，那么malloc函数的代码会被连结到程序里。为了截获住对这类函数的调用，BoundsChecker会动态修改这些函数的指令。<br>以下两段汇编代码，一段没有BoundsChecker介入，另一段则有BoundsChecker的介入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">126: _CRTIMP void * __cdecl malloc (</div><div class="line"></div><div class="line">127: size_t nSize</div><div class="line"></div><div class="line">128: )</div><div class="line"></div><div class="line">129: &#123;</div><div class="line"></div><div class="line">00403C10 push ebp</div><div class="line"></div><div class="line">00403C11 mov ebp,esp</div><div class="line"></div><div class="line">130: return _nh_malloc_dbg(nSize, _newmode, _NORMAL_BLOCK, NULL, 0);</div><div class="line"></div><div class="line">00403C13 push 0</div><div class="line"></div><div class="line">00403C15 push 0</div><div class="line"></div><div class="line">00403C17 push 1</div><div class="line"></div><div class="line">00403C19 mov eax,[__newmode (0042376c)]</div><div class="line"></div><div class="line">00403C1E push eax</div><div class="line"></div><div class="line">00403C1F mov ecx,dword ptr [nSize]</div><div class="line"></div><div class="line">00403C22 push ecx</div><div class="line"></div><div class="line">00403C23 call _nh_malloc_dbg (00403c80)</div><div class="line"></div><div class="line">00403C28 add esp,14h</div><div class="line"></div><div class="line">131: &#125;</div></pre></td></tr></table></figure></p>
<p>以下这一段代码有BoundsChecker介入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">126: _CRTIMP void * __cdecl malloc (</div><div class="line"></div><div class="line">127: size_t nSize</div><div class="line"></div><div class="line">128: )</div><div class="line"></div><div class="line">129: &#123;</div><div class="line"></div><div class="line">00403C10 jmp 01F41EC8</div><div class="line"></div><div class="line">00403C15 push 0</div><div class="line"></div><div class="line">00403C17 push 1</div><div class="line"></div><div class="line">00403C19 mov eax,[__newmode (0042376c)]</div><div class="line"></div><div class="line">00403C1E push eax</div><div class="line"></div><div class="line">00403C1F mov ecx,dword ptr [nSize]</div><div class="line"></div><div class="line">00403C22 push ecx</div><div class="line"></div><div class="line">00403C23 call _nh_malloc_dbg (00403c80)</div><div class="line"></div><div class="line">00403C28 add esp,14h</div><div class="line"></div><div class="line">131: &#125;</div></pre></td></tr></table></figure></p>
<p>当BoundsChecker介入后，函数malloc的前三条汇编指令被替换成一条jmp指令，原来的三条指令被搬到地址01F41EC8处了。当程序进入malloc后先jmp到01F41EC8，执行原来的三条指令，然后就是BoundsChecker的天下了。大致上它会先记录函数的返回地址（函数的返回地址在stack上，所以很容易修改），然后把返回地址指向属于BoundsChecker的代码，接着跳到malloc函数原来的指令，也就是在00403c15的地方。当malloc函数结束的时候，由于返回地址被修改，它会返回到BoundsChecker的代码中，此时BoundsChecker会记录由malloc分配的内存的指针，然后再跳转到到原来的返回地址去。<br>如果内存分配/释放函数在DLL中，BoundsChecker则采用另一种方法来截获对这些函数的调用。BoundsChecker通过修改程序的DLL Import Table让table中的函数地址指向自己的地址，以达到截获的目的。<br>截获住这些分配和释放函数，BoundsChecker就能记录被分配的内存或资源的生命周期。接下来的问题是如何与源代码相关，也就是说当BoundsChecker检测到内存泄漏，它如何报告这块内存块是哪段代码分配的。答案是调试信息（Debug Information）。当我们编译一个Debug版的程序时，编译器会把源代码和二进制代码之间的对应关系记录下来，放到一个单独的文件里(.pdb)或者直接连结进目标程序，通过直接读取调试信息就能得到分配某块内存的源代码在哪个文件，哪一行上。使用Code Injection和Debug Information，使BoundsChecker不但能记录呼叫分配函数的源代码的位置，而且还能记录分配时的Call Stack，以及Call Stack上的函数的源代码位置。</p>
<h4 id="3-1-4-禁止产生堆对象"><a href="#3-1-4-禁止产生堆对象" class="headerlink" title="3.1.4 禁止产生堆对象"></a>3.1.4 禁止产生堆对象</h4><p>禁止堆对象的产生就是禁止 new 表达式正常执行，new 表达式和 delete 表达式我们根本就不能自定义它们的行为。但是由于 new表达式实际执行的动作有三个，delete 实际执行的动作有两个，我们可以通过禁止 new 表达式的第一个动作 operator new 和 delete 的第二个动作 operator delete 来禁止 new 表达式和delete 表达式的执行。对于 operator new 运算符和 operator delete 运算符我们是可以重载的。通过将其声明为类的私有方法，我们可以组织 new 表达式和 delete表达式从外部对它们的访问，从而禁止 new 表达式和 delete表达式的正确执行，禁止堆对象的产生。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Resource</div><div class="line">&#123;</div><div class="line">&#125;;</div><div class="line">class ResourceManager</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    ResourceManager() &#123;</div><div class="line">        ptr = new Resource;</div><div class="line">    &#125;;</div><div class="line">    ~ResourceManager() &#123;</div><div class="line">        delete ptr;</div><div class="line">    &#125;;</div><div class="line">private:</div><div class="line">    Resource* ptr;</div><div class="line">    void* operator new(size_t size)&#123;&#125;;</div><div class="line">    void operator delete(void *p)&#123;&#125;;</div><div class="line">&#125;;</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    // ResourceManager* rm = new ResourceManager;</div><div class="line">    ResourceManager rm;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-1-5-禁止产生栈对象"><a href="#3-1-5-禁止产生栈对象" class="headerlink" title="3.1.5 禁止产生栈对象"></a>3.1.5 禁止产生栈对象</h4><p>禁止栈对象的产生，允许堆对象的产生，就只能通过将类的构造函数和析构函数声明为私有或者受保护，这样就不能直接通过外部代码实例化一个栈对象了，但同时也禁止了new 表达式和 delete表达式的正常执行，不能通过外部的new 表达式和delete表达式调用到私有或者受保护的构造函数和析构函数。解决这一个问题的方式是将 new 和 delete 表达式放到类的方法（静态方法和普通方法）中进行调用，这样就可以访问到类的私有或者受保护的构造函数或者析构函数了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Resource</div><div class="line">&#123;</div><div class="line">&#125;;</div><div class="line">class ResourceManager</div><div class="line">&#123;</div><div class="line">protected:</div><div class="line">    ResourceManager() &#123;</div><div class="line">        ptr = new Resource;</div><div class="line">    &#125;;</div><div class="line">    ~ResourceManager() &#123;</div><div class="line">        delete ptr;</div><div class="line">    &#125;;</div><div class="line">public:</div><div class="line">    static ResourceManager* create_instance();</div><div class="line">    void destory() &#123;</div><div class="line">        // 这样就可以访问到 ~ResourceManager() 析构函数了</div><div class="line">        delete this;</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    Resource* ptr;</div><div class="line">&#125;;</div><div class="line">ResourceManager* ResourceManager::create_instance()</div><div class="line">&#123;</div><div class="line">    // 这样就可以访问到 ResourceManager() 构造函数了</div><div class="line">    return new ResourceManager;</div><div class="line">&#125;</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    // ResourceManager* rm = new ResourceManager;</div><div class="line">    // ResourceManager rm;</div><div class="line">    ResourceManager* rm_ptr = ResourceManager::create_instance();</div><div class="line">    /*code*/</div><div class="line">    rm_ptr-&gt;destory();</div><div class="line">    // 防止悬挂指针的出现</div><div class="line">    rm_ptr = nullptr;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

    </div>

    

    
        <div class="post-tags">
            <i class="fa fa-tags" aria-hidden="true"></i>
            <a href="/tags/C/">#C++</a>
        </div>
    

    <!-- Comments -->
    

</div>
        </section>

    </div>
</div>


</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a href="https://github.com/klugjo">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2018/08/13/消失的梯度/">消失的梯度</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/11/MobileNet-V1-and-V2-带来的卷积结构革命/">MobileNet V1 and V2 带来的卷积</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/09/卷积转置卷积关系在-TensorFLow-中的验证/">卷积转置卷积关系在 TensorFLow 中的验证</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/08/转置卷积-Transposed-Convolution/">转置卷积 Transposed Convoluti</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/klugjo/hexo-theme-alpha-dust">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://twitter.com/?lang=en">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.facebook.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.instagram.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://dribbble.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://plus.google.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-google-plus"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.behance.net/">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://500px.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>