<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Chapter 1">
<meta name="keywords" content="MySQL">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL Crash Course 读书笔记">
<meta property="og:url" content="http://yoursite.com/2018/03/15/MySQL-Crash-Course-读书笔记/index.html">
<meta property="og:site_name" content="The next stop - Antarctica">
<meta property="og:description" content="Chapter 1">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-12-23T04:24:17.451Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MySQL Crash Course 读书笔记">
<meta name="twitter:description" content="Chapter 1">

<link rel="canonical" href="http://yoursite.com/2018/03/15/MySQL-Crash-Course-读书笔记/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MySQL Crash Course 读书笔记 | The next stop - Antarctica</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">The next stop - Antarctica</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">To see behind walls. To draw closer.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/15/MySQL-Crash-Course-读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fengcun Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The next stop - Antarctica">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL Crash Course 读书笔记
        </h1>

        <div class="post-meta">
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-23 12:24:17" itemprop="dateModified" datetime="2020-12-23T12:24:17+08:00">2020-12-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><a id="more"></a>
<p>数据库就是数据库管理系统创建和操纵的容器。<br>模式(schema) 可以用来描述数据库中特定的表以及整个数据库（和其中表的关系），即关于数据库和表的布局及特性信息。</p>
<p>数据类型限制可存储在列中的数据类型，帮助正确的排序数据，并在优化磁盘使用方面起重要的作用。<br>主键：一列或者一组列，其值可以唯一区分表中的每行。没有主键，更新或者删除表中特定行是困难的，因为没有安全的方式保证只涉及相关的行。虽然并不总是需要主键，但是大多数数据库设计人员应该保证他们创建额每个表具有一个主键，以便于以后的数据操纵和管理。<br>表中的任何列都可以作为主键，只要满足两个条件：</p>
<ol>
<li>任意两行不具有相同的主键</li>
<li>每个行都必须具有一个主键值，主键列不允许 NULL 值。</li>
</ol>
<p>主键的最佳实践：</p>
<ol>
<li>不更新主键列的值</li>
<li>不重用主键列的值</li>
<li>不在主键列中使用可能会更改的值。</li>
</ol>
<h2 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h2><p>DBMS 可以分为两类</p>
<ol>
<li>基于共享文件系统， Microsoft Access， FileMaker，桌面用途。</li>
<li>基于客户机-服务器， MySQL， Oracle，Microsoft SQL Server。</li>
</ol>
<p>注意：</p>
<ol>
<li>命令用;或者\g 结束，换句话说，仅按 Enter 不执行命令。</li>
<li>help or \h</li>
<li>quit or exit</li>
</ol>
<h2 id="Chapter-3-使用-MySQL"><a href="#Chapter-3-使用-MySQL" class="headerlink" title="Chapter 3 使用 MySQL"></a>Chapter 3 使用 MySQL</h2><p>默认端口 3306</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use crashcourse;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure>
<p>数据库、表、列、用户、权限等的信息被存储在数据库和表中，MySQL 使用 MySQL 来存储这些信息。不过，内部的表一般不直接访问，可使用 MySQL 的 show 命令来显示这些信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure>
<p>包含在结果列表中的可能是 MySQL 内部使用的数据库，如 mysql， information_schema。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show columns from customers;</span><br></pre></td></tr></table></figure>
<p>什么是自动增量？<br>某些表列需要唯一值，例如订单编号，在每个行添加至表中时，MySQL 可以自动地为每个行分配下一个可用编号，不用在添加一行时手动分配唯一值（这样必须记住最后一次使用的值）。<br>describe 语句， MySQL 支持用 describe 作为 show columns from 的一种快捷方式。<br>所支持的其他 show 语句还有：</p>
<ul>
<li>show status, 用于显示广泛的服务器状态信息</li>
<li>show create database, show create table，用来显示创建特定数据库或表的 MySQL 语句。</li>
<li>show grants, 用来显示授予用户（所有用户或特定用户）的安全权限。</li>
<li>show errors, show warnings 用来显示服务器错误或者警告信息。</li>
</ul>
<h3 id="Chapter-4-检索数据"><a href="#Chapter-4-检索数据" class="headerlink" title="Chapter 4 检索数据"></a>Chapter 4 检索数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_name from products;</span><br></pre></td></tr></table></figure>
<p>如果没有明确排序查询结果，则返回的数据的顺序并没有特殊意义，返回数据的顺序可能是数据被添加到表中的顺序，也可能不是。<br>多条 SQL 语句必须以分号分隔，MySQL 如同多数 DBMS 一样，不需要在单条 SQL 语句后加分号，但是在 mysql 命令行，必须加上分号来结束 SQL 语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from products;</span><br><span class="line">select distinct vend_id from products;</span><br></pre></td></tr></table></figure>
<p>不能部分使用 distinct, distinct 关键字应用于所有列而不仅仅是前置它的列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select prod_name from products limit 5;</span><br><span class="line">select prod_name from products limit 6, 5;</span><br></pre></td></tr></table></figure>
<p>limit 6, 5 返回从行 6 开始的 5 行。包前。<br>如果没有足够的行，只返回它能返回的行数。<br>由于这两位数字的混淆，MySQL 5 支持 limit 的另一种替代语法，<code>limit 4 offset 3</code>。<br>表名和列名可以是完全限定的，<code>select products.prod_name from crashcourse.products</code>，在一些情形下是需要完全限定名的。</p>
<h3 id="Chapter-5-排序检索数据"><a href="#Chapter-5-排序检索数据" class="headerlink" title="Chapter 5 排序检索数据"></a>Chapter 5 排序检索数据</h3><p>select 语句的 order by 子句。<br>子句 clause，SQL 语句由子句构成，有些子句是必须的，有些子句是可选的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_name from products order by prod_name;</span><br></pre></td></tr></table></figure>
<p>用非检索的列排序数据是完全合法的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_id, prod_price, prod_name from products order by prod_price, prod_name;</span><br></pre></td></tr></table></figure>
<p>指定排序方向</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_id, prod_price, prod_name from products order by prod_price desc, prod_name;</span><br></pre></td></tr></table></figure>
<p>desc 关键字只应用于直接位于其前面的列名。<br>在给出 order by 子句时，应该保证它位于 from 子句之后，如果使用 limit 子句，它必须位于 order by 子句之后，使用的子句顺序不对将产生错误信息。</p>
<h3 id="Chapter-6-过滤数据"><a href="#Chapter-6-过滤数据" class="headerlink" title="Chapter 6 过滤数据"></a>Chapter 6 过滤数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_name, prod_price from products where prod_price = 2.50;</span><br></pre></td></tr></table></figure>
<p>SQL 过滤与应用过滤：SQL 过滤快速且节省带宽。<br>在同时使用 order by 和 where 时，应该让 order by 位于 where 之后。<br>where 子句操作符：</p>
<ul>
<li>= 等于</li>
<li>&lt;&gt; 不等于</li>
<li>!= 不等于</li>
<li>&lt;, &lt;=, &gt;, &gt;=</li>
<li>between</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_name, prod_price from products where prod_name = &apos;fuses&apos;;</span><br></pre></td></tr></table></figure>
<p>何时使用括号？<br>单引号用来限定字符串，如果将值与串类型的列进行比较，则需要引号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_name, prod_price from products where prod_price between 5 and 10;</span><br></pre></td></tr></table></figure>
<p>包前包后。<br>NULL 与 0，空字符串或者仅仅包含空格不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_name from products where prod_name is null;</span><br></pre></td></tr></table></figure>
<h3 id="Chapter-7-数据过滤"><a href="#Chapter-7-数据过滤" class="headerlink" title="Chapter 7 数据过滤"></a>Chapter 7 数据过滤</h3><p>MySQL 允许给出多个 where 子句，并用 and 或者 or 进行连接。<br>计算次序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_name, prod_price from products where vend_id = 1002 or vend_id = 1003 and prod_price &gt;= 10;</span><br></pre></td></tr></table></figure>
<p>SQL 在处理 or 操作符之前，优先处理 and 操作符，当 MySQL 看到上面的句子时，它理解为由供应商 1003 制造的价格 10 美元（含）以上的产品，或者由供应商 1002 制造的任何产品，而不管其价格如何。<br>换句话说，and 在计算次序中优先级更高。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_name, prod_price from products where (vend_id = 1003 or vend_id = 1002) and prod_price &gt;= 10;</span><br></pre></td></tr></table></figure>
<p>圆括号在 where 子句中除了用于明确计算顺序，还能用来指定 in 操作符的范围，合法值由逗号分隔，全部都在圆括号中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_name, prod_price from products where vend_id in (1002, 1003, 1004) order by prod_name;</span><br></pre></td></tr></table></figure>
<p>in 操作符与 or 操作符完成相同的功能，那为什么使用 in 操作符呢？</p>
<ol>
<li>直观</li>
<li>计算次序更加容易管理</li>
<li>比 or 更快</li>
<li>in 的最大优点是可以包含其他的 select 语句，使得能够动态地建立 where 子句。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_name, prod_price from products where vend_id not in (1002, 1003, 1004) order by prod_name;</span><br></pre></td></tr></table></figure>
<p>MySQL 支持使用 not 对 in，between，exists 子句取反。</p>
<h3 id="Chapter-8-用通配符进行过滤"><a href="#Chapter-8-用通配符进行过滤" class="headerlink" title="Chapter 8 用通配符进行过滤"></a>Chapter 8 用通配符进行过滤</h3><p>like 操作符<br>为在搜索子句中使用通配符，必须使用 like 操作符，like 指示 MySQL 后跟的搜索模式利用通配符匹配而不是直接相等比较。<br>%表示任意字符出现任意次数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_id, prod_name from products where prod_name like &apos;jet%&apos;;</span><br></pre></td></tr></table></figure>
<p><strong>根据 MySQL 的配置方式，搜索可以是区分大小写的，如果区分大小写，’jet%’ 与 JetPack 1000 将不匹配。</strong><br>注意尾空格，例如，在保存词 anvil 时，如果它后面有一个或者多个空格，则子句 where prod<em>name like ‘%anvil’ 将不会匹配它们，解决这个问题的一个简单办法是在搜索模式（search pattern）的最后附加一个%，一个更好的方式是使用函数去掉尾空格。<br><strong>% 似乎可以匹配任何东西，但是 NULL 除外。</strong><br>`</em>` 通配符，只匹配单个字符。<br>通配符的使用技巧：</p>
<ol>
<li>不要过度使用通配符。</li>
<li>在确实需要使用通配符时，除非有必要，否则不要将通配符放在搜索模式的开始处，放在开始处搜索起来是最慢的。</li>
</ol>
<h3 id="Chapter-9-使用正则表达式"><a href="#Chapter-9-使用正则表达式" class="headerlink" title="Chapter 9 使用正则表达式"></a>Chapter 9 使用正则表达式</h3><p>MySQL 仅支持正则表达式的一个很小的子集。<br>基本字符匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_name from products where prod_name regexp &apos;1000&apos; order by prod_name;</span><br></pre></td></tr></table></figure>
<p>返回列 prod_name 包含 ‘1000’ 的所有行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_name from products where prod_name regexp &apos;.000&apos; order by prod_name;</span><br></pre></td></tr></table></figure>
<p>MySQL 的正则表达式匹配不区分大小写，为了区分大小写可以用 binary 关键字，如 <code>where prod_name regexp binary &#39;JetPack .000&#39;</code><br>进行 or 匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_name from products where prod_name regexp &apos;1000|2000|3000&apos; order by prod_name;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prod_name</span><br><span class="line">JetPack 1000</span><br><span class="line">JetPack 2000</span><br><span class="line">JetPack 3000</span><br></pre></td></tr></table></figure>
<p>匹配几个字符之一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_name from products where prod_name regexp &apos;[123] Ton&apos; order by prod_name;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prod_name</span><br><span class="line">1 ton anvil</span><br><span class="line">2 ton anvil</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_name from products where prod_name regexp &apos;[^123] Ton&apos; order by prod_name;</span><br></pre></td></tr></table></figure>
<p>匹配除这些字符外的任何东西。<br>匹配范围[1-9]，[a-z]。<br>匹配特殊字符，必须以<code>\\</code>为前导。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select prod_name from products where</span><br><span class="line">prod_name regexp &apos;\\([0-9] sticks?\\)&apos;</span><br><span class="line">order by prod_name;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prod_name</span><br><span class="line">TNT (1 stick)</span><br><span class="line">TNT (7, sticks)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select prod_name from products where</span><br><span class="line">prod_name regexp &apos;[[:digit:]]&#123;4&#125;&apos; order by prod_name;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prod_name</span><br><span class="line">JetPack 1000</span><br><span class="line">JetPack 2000</span><br></pre></td></tr></table></figure>
<p>定位符 <code>^, $, [[:&lt;:]], [[:&gt;:]]</code>。</p>
<h3 id="Chapter-10-创建计算字段"><a href="#Chapter-10-创建计算字段" class="headerlink" title="Chapter 10 创建计算字段"></a>Chapter 10 创建计算字段</h3><p>计算字段，比如城市、州、邮编的拼接，单价乘以数量，根据表数据进行总数、平均数或者其他的计算。计算字段也是一个字段，但是它并不存在于实际的数据库表中，计算字段是在运行时在 select 语句内创建出来的。</p>
<h4 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h4><p>concatenate 将值连起来一起构成单个值。<br>MySQL 的不同之处，多数 DBMS 使用 <code>+</code> 或 <code>||</code> 实现拼接，而 MySQL 则使用 <code>Concat()</code> 函数来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(vend_name, &apos; (&apos;, vend_county, &apos;)&apos;) from vendors order by vend_name;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">concat(vend_name, &apos; (&apos;, vend_county, &apos;)&apos;)</span><br><span class="line">ACME (USA)</span><br><span class="line">Anvil R us (USA)</span><br></pre></td></tr></table></figure>
<p>通过使用 <code>rtrim()</code> 函数来删除数据右侧多余的空格整理数据。<br>ltrim，trim。<br>使用别名，上面的语句工作得很好，但是在 select 语句内创建出来的计算字段并没有名称，不能被后续使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(rtrim(vend_name), &apos; (&apos;, rtrim(vend_county), &apos;)&apos;) as vend_title from vendors order by vend_name;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vend_title</span><br><span class="line">ACME (USA)</span><br><span class="line">Anvil R us (USA)</span><br></pre></td></tr></table></figure>
<p>如今就像一个实际的表列一样。<br>别名还有其他的用处，包括在实际的表列名包含不符合规定的字符（如空格）时重新命名它，在原来的名字含混或者容易误解时扩充它。</p>
<h4 id="执行算术运算"><a href="#执行算术运算" class="headerlink" title="执行算术运算"></a>执行算术运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select prod_id, quantity, item_price from orderitems where order_num = 2005;</span><br></pre></td></tr></table></figure>
<p>检索出订单号为 2005 的订单包含的所有物品。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select prod_id, quantity, item_price, quantity * item_price as expanded_price</span><br><span class="line">from orderitems</span><br><span class="line">where order_num = 2005;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select 3*2; 6</span><br><span class="line">select trim(&apos; abc &apos;); abc</span><br><span class="line">select now(); 当前的日期与时间</span><br></pre></td></tr></table></figure>
<h3 id="Chapter-11-使用数据处理函数"><a href="#Chapter-11-使用数据处理函数" class="headerlink" title="Chapter 11 使用数据处理函数"></a>Chapter 11 使用数据处理函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select vend_name, upper(vend_name) as vend_name_uppercase from vendors order by vend_name;</span><br></pre></td></tr></table></figure>
<h4 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h4><ul>
<li>left</li>
<li>right</li>
<li>length</li>
<li>locate</li>
<li>lower</li>
<li>upper</li>
<li>ltrim</li>
<li>rtrim</li>
<li>trim</li>
<li>substring</li>
<li>soundex</li>
</ul>
<h4 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h4><p>日期和时间采用相应的数据类型和特殊的格式存储，以便能够快速和有效地排序或过滤，并节省物理存储空间。<br>一般地，应用程序并不直接处理、使用这样的格式，因此就需要日期和时间处理函数来读取、统计和处理这些值。由于这个原因，日期和时间处理函数在 MySQL 中具有重要的作用。<br>常用的函数：</p>
<ul>
<li>adddate</li>
<li>addtime</li>
<li>curdate</li>
<li>curtime</li>
<li>date 返回日期时间的日期部分</li>
<li>datediff 计算两个日期之差</li>
<li>date_add</li>
<li>date_format 返回一个格式化的日期或者时间字符串</li>
<li>day</li>
<li>dayofweek</li>
<li>hour</li>
<li>minute</li>
<li>month</li>
<li>now</li>
<li>second</li>
<li>time</li>
<li>year</li>
</ul>
<p>首先需要注意的是 MySQL 使用的日期格式，无论你什么时候指定一个日期，不管是插入或者更新表值还是使用 <code>where</code> 子句进行过滤，日期都必须为 <code>yyyy-mm-dd</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cust_id, order_num from orders where order_date = &apos;2015-09-01&apos;;</span><br></pre></td></tr></table></figure>
<p>order_date 的数据类型是 datetime，这种类型存储日期及时间，因此 <code>&#39;2015-09-01&#39;</code> 匹配的是 <code>&#39;2015-09-01 00:00:00&#39;</code>。<br>如果是要日期请使用 <code>date()</code> 函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cust_id, order_num from orders where date(order_date) = &apos;2015-09-01&apos;;</span><br></pre></td></tr></table></figure>
<p>使用 date 是一个良好的习惯，即使你知道相应的列只包含日期也是如此，这样由于某种原因表中以后有日期和时间值，你的 SQL 代码也不用修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cust_id, order_num from orders where date(order_date) between &apos;2015-09-01&apos; and &apos;2005-09-30&apos;;</span><br></pre></td></tr></table></figure>
<h4 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h4><ul>
<li>abs</li>
<li>cos</li>
<li>exp</li>
<li>mod</li>
<li>pi</li>
<li>rand</li>
<li>sin</li>
<li>sqrt</li>
<li>tan</li>
</ul>
<h3 id="Chapter-12-汇总数据"><a href="#Chapter-12-汇总数据" class="headerlink" title="Chapter 12 汇总数据"></a>Chapter 12 汇总数据</h3><p>聚集函数<br>我们经常需要汇总数据而不用把它们实际检索出来，当需要的是对表中数据汇总而不是实际数据本身时，返回实际数据是对处理时间和处理资源的一种浪费，更不用说带宽了。<br>MySQL 给出了 5 个聚集函数（aggregate function），聚集函数是运行在行组上，计算和返回单个值的函数。</p>
<ul>
<li>avg 返回某列的平均值</li>
<li>count 返回某列的行数</li>
<li>max 返回某列的最大值</li>
<li>min 返回某列的最小值</li>
<li>sum 返回某列值之和</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select avg(prod_price) as avg_price from products where vend_id = 1003;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">avg_price</span><br><span class="line">16.133571</span><br></pre></td></tr></table></figure>
<p><code>avg</code> 只能用于单个列，为了获得多个列的平均值，必须使用多个 <code>avg</code> 函数，<code>avg</code> 函数会自动忽略 <code>null</code> 的行。<br>count 函数有两种使用方式：</p>
<ol>
<li>使用 <code>count(*)</code> 对表中行的数目进行计数，不管表列中包含的是空值还是非空值。</li>
<li>使用 <code>count(column)</code> 对特定列中具有值的行进行计数，忽略 <code>null</code> 值。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) as num_cust from customers;</span><br></pre></td></tr></table></figure>
<p>sum 函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sum(item_price*quantity) as total_price from orderitems where order_num = 2005;</span><br></pre></td></tr></table></figure>
<p>聚集不同值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select avg(distinct prod_price) as avg_price from products where vend_id = 1003;</span><br></pre></td></tr></table></figure>
<p>all 为默认值。<br>聚集函数组合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select count(*) as num_items,</span><br><span class="line">    min(prod_price) as price_min,</span><br><span class="line">    max(prod_price) as price_max,</span><br><span class="line">    avg(prod_price) as price_avg</span><br><span class="line">from products;</span><br></pre></td></tr></table></figure>
<h3 id="Chapter-13-分组数据"><a href="#Chapter-13-分组数据" class="headerlink" title="Chapter 13 分组数据"></a>Chapter 13 分组数据</h3><p>这涉及到两个 <code>select</code> 语句子句，分别是 <code>group by</code> 和 <code>having</code>。<br>在上一章汇总数据时，是在表的所有数据或匹配特定的 <code>where</code> 子句的数据上进行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select vend_id, count(*) as num_prods from products group by vend_id;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vend_id num_prods</span><br><span class="line">1001 3</span><br><span class="line">1002 2</span><br><span class="line">1003 7</span><br><span class="line">1005 2</span><br></pre></td></tr></table></figure>
<p>group by 的注意：</p>
<ol>
<li>可以嵌套</li>
<li><strong>除了聚集计算语句外，select 语句中的每个列都必须在 group by 子句中给出</strong></li>
<li>如果分组列中有 <code>null</code> 值，则 <code>null</code> 将作为一个分组返回。</li>
<li><code>group by</code> 子句必须出现在 <code>where</code> 子句之后，<code>order by</code> 子句之前。</li>
</ol>
<h4 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h4><p>MySQL 允许过滤分组，规定包括哪些分组，排除哪些分组，例如，可能想要列出至少有两个订单的所有顾客，为了得到这个结果，必须基于用户分组进行计数并过滤而不是个别的行进行过滤。<br>where 可以基于行而不是分组进行过滤，事实上，where 没有分组的概念。<br>使用 having， having 非常类似 where，事实上，目前为止所学的所有类型的 where 子句都用在 having 中来，唯一的差别是 having 是过滤分组。<br>having 支持所有 where 操作符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select cust_id, count(*) as orders from orders group by cust_id having count(*) &gt;= 2;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select vend_id, count(*) as num_prods from products where prod_price &gt;= 10</span><br><span class="line">group by vend_id having count(*) &gt;= 2;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select order_num, sum(quantity*item_price) as ordertotal</span><br><span class="line">from orderitems</span><br><span class="line">group by order_num</span><br><span class="line">having sum(quantity*item_price) &gt;= 50</span><br><span class="line">order by ordertotal;</span><br></pre></td></tr></table></figure>
<p>having 子句中使用 <code>sum(quantity*item_price)</code>，而 order by 子句中使用 ordertotal ，这是因为这两个子句分别运行于 as 子句之前和之后。</p>
<h3 id="Chapter-14-使用子查询"><a href="#Chapter-14-使用子查询" class="headerlink" title="Chapter 14 使用子查询"></a>Chapter 14 使用子查询</h3><p>子查询嵌套在其他查询中的查询。<br>orderitems<-orders->customers<br>要求列出订购物品 TNT2 的所有客户：<br>需要三条查询语句</-orders-></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> order_num <span class="keyword">from</span> orderitems <span class="keyword">where</span> prod_id = <span class="string">'TNT2'</span>;</span><br><span class="line">order_num</span><br><span class="line">20005</span><br><span class="line">20007</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_id <span class="keyword">from</span> orders <span class="keyword">where</span> order_num <span class="keyword">in</span> (<span class="number">20005</span>, <span class="number">20007</span>);</span><br><span class="line">cust_id</span><br><span class="line">10001</span><br><span class="line">10004</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_name, cust_contact <span class="keyword">from</span> customers <span class="keyword">where</span> cust_id <span class="keyword">in</span> (<span class="number">10001</span>, <span class="number">10004</span>);</span><br></pre></td></tr></table></figure>
<p>也可以使用一条语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cust_name, cust_contact <span class="keyword">from</span> customers <span class="keyword">where</span> cust_id <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> cust_id <span class="keyword">from</span> orders <span class="keyword">where</span> order_num <span class="keyword">in</span> (</span><br><span class="line">        <span class="keyword">select</span> order_num <span class="keyword">from</span> orderitems <span class="keyword">where</span> prod_id = <span class="string">'TNT2'</span></span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>列必须匹配： 在 where 子句中使用子查询， 应该保证 select 语句具有与 where 子句中相同数目的列，通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列。</strong><br>子查询及其性能，这里给出的代码有效并获得了所需的结果，但是，使用子查询并不总是执行这种类型的数据检索的最有效的方法。</p>
<h4 id="子查询结果作为计算字段使用"><a href="#子查询结果作为计算字段使用" class="headerlink" title="子查询结果作为计算字段使用"></a>子查询结果作为计算字段使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select cust_name, cust_state,</span><br><span class="line">(select count(\*) from orders where orders.cust_id = customers.cust_id) as orders</span><br><span class="line">from customers order by cust_name;</span><br></pre></td></tr></table></figure>
<p>子查询及其性能，这里给出的代码有效并获得了所需的结果，但是，使用子查询并不总是执行这种类型的数据检索的最有效的方法。<br>逐渐增加子查询来建立查询，首先，建立和测试最内层的查询，然后，用硬编码数据建立和测试外层查询，并且仅在确认它正常后才嵌入子查询，这时再次测试它。</p>
<h3 id="Chapter-15-联结表"><a href="#Chapter-15-联结表" class="headerlink" title="Chapter 15 联结表"></a>Chapter 15 联结表</h3><p>SQL 最强大的功能之一就是能在数据检索查询的执行中联结 (join) 表。<br>外键 (foreign key)，外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系：<br>这样做的好处是：</p>
<ol>
<li>数据不重复，节省空间。</li>
<li>信息变动时，可以只更新一个表中的单个记录，相关表中的数据不用改动。</li>
<li>数据的一致性好。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select vend_name, prod_name, prod_price</span><br><span class="line">from vendors, products</span><br><span class="line">where vendors.vend_id = products.vend_id</span><br><span class="line">order by vend_name, prod_name;</span><br></pre></td></tr></table></figure>
<p>笛卡儿积 由没有联结条件的表关系返回的结果为笛卡儿积，检索出的行的数目为第一个表中的行数乘以第二个表中的行数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select vend_name, prod_name, prod_price</span><br><span class="line">from vendors, products</span><br><span class="line">order by vend_name, prod_name;</span><br></pre></td></tr></table></figure>
<p>因此应该确保所有的联结都有 where 子句。</p>
<h4 id="内部联结"><a href="#内部联结" class="headerlink" title="内部联结"></a>内部联结</h4><p>目前为止所用的联结称为等值联结，它基于两个表之间的相等测试，这种联结也成为内部联结，其实这种联结可以使用稍微不同的语法来明确指定联结的类型，下面的语句与前面的例子返回完全相同的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select vend_name, prod_name, prod_price</span><br><span class="line">from vendors inner join products</span><br><span class="line">on vendors.vend_id = products.vend_id</span><br><span class="line">order by vend_name, prod_name;</span><br></pre></td></tr></table></figure>
<h4 id="联结多个表"><a href="#联结多个表" class="headerlink" title="联结多个表"></a>联结多个表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select prod_name, vend_name, prod_price, quantity</span><br><span class="line">from orderitems, products, vendors</span><br><span class="line">where products.vend_id = vendors.vend_id</span><br><span class="line">and orderitems.prod_id = products.prod_id</span><br><span class="line">and order_num = 2005;</span><br></pre></td></tr></table></figure>
<p>正如第 14 章所述，子查询并不总是执行复杂 select 操作的最有效的方法，下面是使用联结的相同查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select cust_name, cust_contact</span><br><span class="line">from customers, orders, orderitems</span><br><span class="line">where customers.cust_id = order.cust_id</span><br><span class="line">and order.order_num = orderitems.order_num</span><br><span class="line">and prod_id = &apos;TNT2&apos;;</span><br></pre></td></tr></table></figure>
<h3 id="Chapter-16-创建高级联结"><a href="#Chapter-16-创建高级联结" class="headerlink" title="Chapter 16 创建高级联结"></a>Chapter 16 创建高级联结</h3><h4 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h4><p>SQL 的别名除了用于列名和计算字段外，SQL 还允许给表名起别名，这样做主要有两个主要理由：</p>
<ol>
<li>缩短 SQL 语句</li>
<li>允许在单条 select 语句中多次使用相同的表</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select cust_name, cust_contact</span><br><span class="line">from customers as c, orders as o, orderitems as oi</span><br><span class="line">where c.cust_id = o.cust_id</span><br><span class="line">and o.order_num = oi.order_num</span><br><span class="line">and prod_id = &apos;TNT2&apos;;</span><br></pre></td></tr></table></figure>
<h4 id="使用不同类型的联结"><a href="#使用不同类型的联结" class="headerlink" title="使用不同类型的联结"></a>使用不同类型的联结</h4><p>迄今为止，使用的仅是称为内部联结或等值联结的简单联结。<br>现在看其他三种联结，分别为自联结，自然联结，外部联结。<br>自联结，如前所述，使用表别名的主要原因是能在单条 select 语句中不止一次引用相同的表。<br>假设发现某物品 id 为 DTNTR 存在问题，想知道生产该物品的供应商的其他物品是否也存在这些问题。即在同一个表中。<br>一种解决方式是使用子查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select prod_id, prod_name</span><br><span class="line">from products</span><br><span class="line">where vend_id = (select vend_id from products where prod_id = &apos;DTNTR&apos;);</span><br></pre></td></tr></table></figure>
<p>现在看使用联结的相同查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select p1.prod_id, p1.prod_name</span><br><span class="line">from products as p1, products as p2</span><br><span class="line">where p1.vend_id = p2.vend_id</span><br><span class="line">and p2.prod_id = &apos;DTNTR&apos;;</span><br></pre></td></tr></table></figure>
<p>p1.prod_id, p1.prod_name，如果不这样，MySQL 将返回错误信息，因为分别存在两个名为 prod_id, prod_name 的列，MySQL 不知道想要的是哪一列，即使事实上它们是同一列。<br>自联结通常用于替代在相同表中检索数据的子查询语句，虽然最终的结果是相同的，但有时候处理联结远比处理子查询要快得多。</p>
<h5 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h5><p>无论何时对表进行联结，至少应该有一个列出现在不止一个表中，被联结的列，标准的联结，前一章中的内部联结，返回所有数据，甚至相同的列多次出现，自然联结则排除多次出现，使每个列只返回一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select c.\*, o.order_num, o.order_date, oi.prod_id, oi.quantity, oi.item_price</span><br><span class="line">from customers as c, orders as o, orderitems as oi</span><br><span class="line">where c.cust_id = o.cust_id</span><br><span class="line">and o.order_num = oi.order_num</span><br><span class="line">and prod_id = &apos;FB&apos;;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，通配符只对第一个表使用，所有其他列明确列出，所以没有重复的列被检索出来。<br>事实上，迄今为止，我们建立的每个内部联结都是自然联结，很有可能我们永远都不会用到不是自然联结的内部联结。</p>
<h5 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h5><p>检索所有客户及其订单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select customers.cust_name, orders.order_num</span><br><span class="line">from customers inner join orders</span><br><span class="line">on customers.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure>
<p>外部联结语法类似，检索所有的用户，包括那些没有订单的用户：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select customers.cust_name, orders.order_num</span><br><span class="line">from customers left outer join orders</span><br><span class="line">on customers.cust_id = orders.cust_id;</span><br></pre></td></tr></table></figure>
<p>在使用 outer join 时，必须使用 right 或者 left 指定包括其所有行的表。外部联结的类型，存在两种形式的外部联结，它们之间唯一的差别在于所关联的表的顺序不同，换句话说，左外部联结可以通过颠倒 from 或者 where 子句中的表的顺序转换为右外部联结。</p>
<h5 id="使用带聚集函数的联结"><a href="#使用带聚集函数的联结" class="headerlink" title="使用带聚集函数的联结"></a>使用带聚集函数的联结</h5><p>检索所有客户及其订单数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select customers.cust_name, customers.cust_id,</span><br><span class="line">count(orders.order_num) as num_ord</span><br><span class="line">from customers inner join orders</span><br><span class="line">on customers.cust_id = orders.cust_id</span><br><span class="line">group by customers.cust_id;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cust_name cust_id num_ord</span><br><span class="line">.... .... 2</span><br><span class="line">.... .... 1</span><br><span class="line">.... .... 1</span><br><span class="line">.... .... 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select customers.cust_name, customers.cust_id,</span><br><span class="line">count(orders.order_num) as num_ord</span><br><span class="line">from customers left outer join orders</span><br><span class="line">on customers.cust_id = orders.cust_id</span><br><span class="line">group by customers.cust_id;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cust_name cust_id num_ord</span><br><span class="line">.... .... 2</span><br><span class="line">.... .... 1</span><br><span class="line">.... .... 0</span><br><span class="line">.... .... 1</span><br><span class="line">.... .... 1</span><br></pre></td></tr></table></figure>
<h3 id="Chapter-17-组合查询-compound-query"><a href="#Chapter-17-组合查询-compound-query" class="headerlink" title="Chapter 17 组合查询 compound query"></a>Chapter 17 组合查询 compound query</h3><p>利用 union 操作符将多条 select 语句组合成一个结果集。<br>组合查询和多个 where 条件：<br>多数情况下，组合相同表的两个查询与具有多个 where 条件子句的单条查询完成的工作是相同的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select vend_id, prod_id, prod_price</span><br><span class="line">from products</span><br><span class="line">where prod_price &lt;= 5</span><br><span class="line">union</span><br><span class="line">select vend_id, prod_id, prod_price</span><br><span class="line">from products</span><br><span class="line">where vend_id in (1001, 1002);</span><br></pre></td></tr></table></figure>
<p>等于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select vend_id, prod_id, prod_price</span><br><span class="line">from products</span><br><span class="line">where prod_price &lt;= 5</span><br><span class="line">or</span><br><span class="line">vend_id in (1001, 1002);</span><br></pre></td></tr></table></figure>
<p>union 规则：</p>
<ol>
<li>union 中的每个查询必须包含相同的列，表达式或者聚集函数（不过各个列不需要以相同的次序列出）。</li>
<li>列数据类型必须兼容，类型不必完全相同，但必须是 DBMS 可以隐含地转换类型。</li>
</ol>
<h5 id="对组合查询结果进行排序"><a href="#对组合查询结果进行排序" class="headerlink" title="对组合查询结果进行排序"></a>对组合查询结果进行排序</h5><p>在 union 组合查询时，只能使用一条 order by 子句，它必须出现在最后一条 select 语句之后。</p>
<h3 id="Chapter-18-全文本搜索"><a href="#Chapter-18-全文本搜索" class="headerlink" title="Chapter 18 全文本搜索"></a>Chapter 18 全文本搜索</h3><p>并非所有引擎都支持全文本搜索<br>MySQL 支持几种基本的数据库引擎，两个最常使用的引擎为 MyISAM 和 InnoDB，前者支持全文本搜索，而后者不支持，这就是为什么这本书创建的多数样例表使用 InnoDB，而一个样例表（productnotes 表）却使用 MyISAM 的原因。<br>like 关键字和正则表达式这两个搜索机制非常有用，但是却存在几个重要的限制：</p>
<ol>
<li>性能，这两个搜索极少使用表索引，因此，随着被搜索行数不断增加，这些搜索可能会非常耗时。</li>
<li>控制不明确</li>
<li>不够智能</li>
</ol>
<p>使用全文本搜索时，MySQL 不要分别查看每个行，不需要分别分析处理每个词，MySQL 创建指定列中各词的一个索引，搜索可以针对这些词进行，这样，MySQL 可以快速有效地决定哪些词匹配（哪些行包含它们），哪些词不匹配，以及它们的匹配频率。<br>为了进行全文本搜索，必须索引被搜索的列，而且要随着数据的改动不断地重新索引，在对表列进行适当设计后，MySQL 会自动进行所有索引和重新索引。<br>在索引之后，select 可与 match 和 against 一起使用以实际执行搜索。<br>一般在创建表时启用全文本搜索，create table 语句接受 fulltext 子句，它给出一个被索引列的一个逗号分隔的列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create table productnotes (</span><br><span class="line">note_id int not null auto_increment,</span><br><span class="line">prod_id char(10) not null,</span><br><span class="line">note_date datetime not null,</span><br><span class="line">node_text text null,</span><br><span class="line">primary key(note_id),</span><br><span class="line">fulltext(node_text)</span><br><span class="line">) engine=myisam;</span><br></pre></td></tr></table></figure>
<p>进行全文本搜索</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select node_text from productnotes where</span><br><span class="line">match(node_text) against(&apos;rabbit&apos;);</span><br></pre></td></tr></table></figure>
<p>有两行包含词 rabbit，这两行被返回。<br>上述的搜索可以简单的使用 like 子句完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select node_text from productnotes where node_text like &apos;%rabbit%&apos;;</span><br></pre></td></tr></table></figure>
<p>两行都包含词 rabbit，但包含词 rabbit 作为第三个词的等级比作为第二十个词的等级高，全文搜索的一个重要特点就是具有较高等级的行优先返回。<br><strong>….to do</strong></p>
<h3 id="Chapter-19-插入数据"><a href="#Chapter-19-插入数据" class="headerlink" title="Chapter 19 插入数据"></a>Chapter 19 插入数据</h3><p>毫无疑问，select 是最常用的 SQL 语句了，但是还有其他 3 个经常使用的 SQL 语句。<br>insert 可以以几种方式使用：</p>
<ul>
<li>插入完整的行</li>
<li>插入行的一部分</li>
<li>插入多行</li>
<li>插入某些查询结果</li>
</ul>
<p><strong>插入及系统安全：可针对每个表或每个用户，利用 MySQL 的安全机制禁止使用 insert 语句</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">insert into customers</span><br><span class="line">values (</span><br><span class="line">null,</span><br><span class="line">&apos;Pep E. LaPaw&apos;,</span><br><span class="line">&apos;100 Main Street&apos;,</span><br><span class="line">&apos;Los Angeles&apos;,</span><br><span class="line">&apos;CA&apos;,</span><br><span class="line">&apos;90046&apos;,</span><br><span class="line">&apos;USA&apos;,</span><br><span class="line">NULL,</span><br><span class="line">NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>依序，第一列 cust_id 为 null，是因为这列是由 MySQL 自动增量的。<br>这种语法很简单，但并不安全，高度依赖于表中列的定义次序，不能保证表结构变动后各个列保持完全相同的次序。更加安全也更加繁琐的方式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">insert into customers (</span><br><span class="line">cust_name,</span><br><span class="line">cust_address,</span><br><span class="line">cust_city,</span><br><span class="line">cust_state,</span><br><span class="line">cust_zip,</span><br><span class="line">cust_county,</span><br><span class="line">cust_contact,</span><br><span class="line">cust_email</span><br><span class="line">)</span><br><span class="line">values (</span><br><span class="line">&apos;Pep E. LaPaw&apos;,</span><br><span class="line">&apos;100 Main Street&apos;,</span><br><span class="line">&apos;Los Angeles&apos;,</span><br><span class="line">&apos;CA&apos;,</span><br><span class="line">&apos;90046&apos;,</span><br><span class="line">&apos;USA&apos;,</span><br><span class="line">NULL,</span><br><span class="line">NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>省略的列：</p>
<ol>
<li>NULL</li>
<li>default value<br>否则就会产生一条错误信息，并相应的行插入不成功。<br>提高整体性能：<br>insert 操作可能很耗时，特别是有很多索引需要更新时，而它可能降低等待处理的 select 语句的性能。<br>如果数据检索是重要的，通常如此，则你需要通过在 insert 和 into 之间添加关键字 low_priority，指示 MySQL 降低 insert 语句的优先级。这也适用于 update 和 delete 语句。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">insert into customers (...)</span><br><span class="line">values (...), (...);</span><br></pre></td></tr></table></figure>
<p>此技术可以提高数据库处理的性能，因为 MySQL 用单条 insert 语句处理多个插入比使用多条 insert 语句要快。</p>
<h4 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h4><p>将一条 select 语句的结果插入表中，这就是所谓的 insert select。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">insert into customers (...)</span><br><span class="line">select ... from custnew;</span><br></pre></td></tr></table></figure>
<p>Insert select 列名不一定匹配，MySQL 使用的是其位置。</p>
<h3 id="Chapter-20-更新和删除数据"><a href="#Chapter-20-更新和删除数据" class="headerlink" title="Chapter 20 更新和删除数据"></a>Chapter 20 更新和删除数据</h3><p>update 有两种使用方式：</p>
<ol>
<li>更新表中特定行</li>
<li>更新表中所有行</li>
</ol>
<p><strong>一定要用 where 子句</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">update customers</span><br><span class="line">set cust_email = &apos;elmer@fudd.com&apos;, cust_name = &apos;The Fudds&apos;</span><br><span class="line">where cust_id = 10005;</span><br></pre></td></tr></table></figure>
<p>在 update 中可以使用子查询，使得能用 select 语句检索出的数据更新数据。<br>ignore 关键字，在使用 update 更新多行时，如果其中的一行或者多行出现一个错误，则整个 update 操作被取消，错误发生前更新的所有行将恢复到其原有的值，为了即使发生错误，也能继续进行更新，可用 ignore 关键字。<br>update ignore customers…<br>delete 有两种使用方式：</p>
<ol>
<li>删除表中特定行</li>
<li>删除表中所有行</li>
</ol>
<p><strong>一定要用 where 子句</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">delete from customers where cust_id = 10006;</span><br></pre></td></tr></table></figure>
<p>删除的是内容而不是表，即便是删除了表中所有的行。<br>更快的删除<br>如果想从表中删除所有行，不要使用 delete，可以使用 truncate table，它完成相同的工作，但是速度更快，它实际上是删除了原来的表并重新创建了一个表，而不是逐行删除表中的数据。<br>更新和删除的指导原则</p>
<ol>
<li>在对 update 或 delete 语句使用 where 子句前，首先使用 select 进行测试，保证其过滤的是正确的记录，以免编写的 where 子句不正确。</li>
<li>使用强制实施引用完整性的数据库，这样 MySQL 不允许删除与其他表相关联的数据行。</li>
</ol>
<h3 id="Chapter-21-创建和操纵表"><a href="#Chapter-21-创建和操纵表" class="headerlink" title="Chapter 21 创建和操纵表"></a>Chapter 21 创建和操纵表</h3><p>迄今为止，我们看到的都是以单个列作为主键，为创建由多个列组成的主键，应该以逗号分隔的列表给出各列名，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create table orderitems (</span><br><span class="line">order_num int not null,</span><br><span class="line">order_item int not null,</span><br><span class="line">prod_id char(10) not null,</span><br><span class="line">quantity int not null,</span><br><span class="line">item_price decimal(8, 2) not null,</span><br><span class="line">primary key (order_num, order_item)</span><br><span class="line">) engine=innodb;</span><br></pre></td></tr></table></figure>
<ul>
<li>主键唯一标识表中的一行</li>
<li>外键是表中的一列，唯一标识另外一个表中的一行。</li>
</ul>
<p>每个表只允许一个 auto_increment 列，而且它必须被索引（如，通过使它成为主键）。<br>覆盖 auto_increment，如果一个列被指定为 auto_increment，你可以简单地在 insert 语句中指定一个值，只要它是唯一的(至今尚未使用过)即可，该值将被用来代替自动生成的值，后续的增量将开始使用该手工插入的值。<br><code>select last_insert_id()</code> 返回最后一个 auto_increment 值。<br>指定默认值 <code>quantity int not null default 1</code>，与大多数 DBMS 不一样，MySQL 不允许使用函数作为默认值，它只支持常量。</p>
<h4 id="引擎类型"><a href="#引擎类型" class="headerlink" title="引擎类型"></a>引擎类型</h4><p>具体管理和处理数据的内部引擎。</p>
<ul>
<li>InnoDB 是一个可靠的事务处理引擎，但它不支持全文本搜索。</li>
<li>Memory 功能等同于 MyISAM，但是数据存储在内存，而不是磁盘中，速度很快，特别适合于临时表。</li>
<li>MyISAM 是一个性能极高的引擎，不支持事务处理，但是支持全文本搜索。</li>
</ul>
<p>在同一个数据库中引擎可以混用，一个表用 MyISAM，另一个表用 InnoDB。<br>外键不能跨引擎。</p>
<h4 id="alter-表"><a href="#alter-表" class="headerlink" title="alter 表"></a>alter 表</h4><p>alter table，但是理想状态下，当表中存储数据后，该表就不应该被 alter，在表的设计过程中需要花费大量的时间来考虑，以便后期不对该表进行大的变动。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">alter table vendors</span><br><span class="line">add vend_phone char(20);</span><br><span class="line"></span><br><span class="line">alter table vendors</span><br><span class="line">drop column vend_phone;</span><br></pre></td></tr></table></figure>
<p>alter table 的一个常见用途是定义外键：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">alter table orderitems</span><br><span class="line">add constraint fk_orderitems_orders</span><br><span class="line">foreign key (order_num) references orders (order_num);</span><br></pre></td></tr></table></figure>
<p>小心使用 alter table，数据表的更改不能撤销，如果增加了不需要的列，可能不能删除它们，类似地，如果删除了不应该删除的列，可能会丢失该列中的所有数据。<br>删除表 <code>drop table customers2;</code><br>重命名表 <code>rename table customers2 to customers;</code></p>
<h3 id="Chapter-22-使用视图"><a href="#Chapter-22-使用视图" class="headerlink" title="Chapter 22 使用视图"></a>Chapter 22 使用视图</h3><p>视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select cust_name, cust_contact</span><br><span class="line">from customers, orders, orderitems</span><br><span class="line">where customers.cust_id = order.cust_id</span><br><span class="line">and order.order_num = orderitems.order_num</span><br><span class="line">and prod_id = &apos;TNT2&apos;;</span><br></pre></td></tr></table></figure>
<p>此查询用来检索订购了某个特定产品的客户，任何需要这个数据的人都必须理解相关表的结构，并知道如何创建查询和对表进行联结，为了检索其他的产品或者多个产品的相同数据，必须修改最后的 where 子句。<br>现在，假如可以把整个查询包装成为一个 productcustomers 的虚拟表，则可以轻松地检索出相同的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select cust_name, cust_contact from</span><br><span class="line">productcustomers</span><br><span class="line">where prod_id = &apos;TNT2&apos;;</span><br></pre></td></tr></table></figure>
<p>productcustomers 是一个视图，作为视图，它不包含表中应该有的任何列或者数据，它包含的是一个 SQL 查询。</p>
<h4 id="视图用处"><a href="#视图用处" class="headerlink" title="视图用处"></a>视图用处</h4><ul>
<li>重用 SQL 语句</li>
<li>简化复杂的 SQL 操作</li>
<li>使用表的组成部分而不是整个表</li>
<li>保护数据，可以给用户授予表的特定部分的访问权限而不是整个表的访问权限</li>
<li>更改数据格式和表示，视图可返回与底层表的数据格式和表示不同的数据</li>
</ul>
<p>在视图创建之后，可以用与表基本相同的方式利用它们，可以对视图执行 select 操作，过滤和排序数据，将视图联结到其他视图或者表，甚至能添加和更新数据（添加和更新数据存在某些限制），重要的是，在添加或者更改表中的数据时，视图将立即进行反映。<br>视图的规则和限制：</p>
<ol>
<li>视图可以嵌套</li>
<li>order by 可以用在视图中，但如果从该视图检索数据的 select 中也包含 order by，那么该视图的 order by 将被覆盖。</li>
<li>视图不能索引，也不能有关联的触发器或者默认值</li>
<li>为创建视图，必须有足够的访问权限，这些限制通常由数据库管理人员授予。</li>
<li>视图可以和表一起使用，例如编写一条联结表和视图的 select 语句。</li>
</ol>
<p>使用视图：</p>
<ol>
<li>视图用 create view 语句来创建</li>
<li>使用 show create view viewname;来查看创建视图的语句。</li>
<li>drop view viewname;</li>
<li>更新视图时，可以先用 drop 再用 create，也可以直接用 create or replace view。</li>
</ol>
<h4 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a>利用视图简化复杂的联结</h4><p>视图的最常用的应用之一是隐藏复杂的 SQL，这通常会涉及到联结。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ceate view productcustomers as</span><br><span class="line">select cust_name, cust_contact, prod_id</span><br><span class="line">from customers, orders, orderitems</span><br><span class="line">where customers.cust_id = orders.cust_id</span><br><span class="line">and orders.order_num = orderitems.order_num;</span><br><span class="line"></span><br><span class="line">select cust_name, cust_contact</span><br><span class="line">from productcustomers</span><br><span class="line">where prod_id = &apos;TNT2&apos;;</span><br></pre></td></tr></table></figure>
<h4 id="利用视图重新格式化检索出的数据"><a href="#利用视图重新格式化检索出的数据" class="headerlink" title="利用视图重新格式化检索出的数据"></a>利用视图重新格式化检索出的数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select concat(rtrim(vend_name), &apos; (&apos;, rtrim(vend_county), &apos;)&apos;) as vend_title</span><br><span class="line">from vendors</span><br><span class="line">order by vend_name;</span><br></pre></td></tr></table></figure>
<p>现在假设经常需要这个格式的结果，创建视图，重用 SQL 语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create view vendorlocations as</span><br><span class="line">select concat(rtrim(vend_name), &apos; (&apos;, rtrim(vend_county), &apos;)&apos;) as vend_title</span><br><span class="line">from vendors</span><br><span class="line">order by vend_name;</span><br></pre></td></tr></table></figure>
<p>这样就可以在应用中使用 <code>select * from vendorlocations;</code>进行数据检索了，重用了 SQL 语句，简化了应用中的 SQL 语句，并且没有造成数据的重复。</p>
<h4 id="用视图过滤不想要的数据"><a href="#用视图过滤不想要的数据" class="headerlink" title="用视图过滤不想要的数据"></a>用视图过滤不想要的数据</h4><p>可以定义 customeremaillist 视图，它过滤了没有电子邮件地址的用户。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create view customeremaillist as</span><br><span class="line">select cust_id, cust_name, cust_email</span><br><span class="line">from customers</span><br><span class="line">where cust_email is not null;</span><br></pre></td></tr></table></figure>
<p>此时可以在应用中通过<code>select * from customeremaillist;</code>进行检索了。</p>
<h4 id="使用视图与计算字段"><a href="#使用视图与计算字段" class="headerlink" title="使用视图与计算字段"></a>使用视图与计算字段</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create view orderitemsexpanded as</span><br><span class="line">select order_num, prod_id, quantity, item_price quantity\*item_price as expanded_price</span><br><span class="line">from orderitems;</span><br></pre></td></tr></table></figure>
<h4 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h4><p>视图是可更新的，即可以对其使用 insert，update，delete，更新一个视图将更新其基表，可以回忆一下，视图本身并没数据，如果对视图增加或者删除行，实际上是对其基表增加或者删除行。<br>但是并非所有的视图都是可更新的，基本上说，如果 MySQL 不能正确地确定被更新的基数据，则不允许更新，这实际上是说，如果视图中定义有如下的操作，则不能进行视图的更新：</p>
<ol>
<li>分组 （使用 group by 和 having）</li>
<li>联结</li>
<li>子查询</li>
<li>并</li>
<li>聚集函数（min，max， count， sum 等）</li>
<li>distinct</li>
<li>导出（计算）列</li>
</ol>
<h3 id="Chapter-23-使用存储过程"><a href="#Chapter-23-使用存储过程" class="headerlink" title="Chapter 23 使用存储过程"></a>Chapter 23 使用存储过程</h3><p>迄今为止，使用的大多数 SQL 语句都是针对一个或者多个表的<strong>单条语句</strong>，但是并非所有的操作都这么简单，经常会有一个完整的操作需要多条语句才能完成。<br>那么如何编写此代码？可以单独编写每条语句，并根据结果有条件地执行另外的语句。在每次需要这个处理时，重复一遍如此的操作即可。<br>可以创建存储过程，存储过程简单来说，就为以后使用而保存地一条或者多条 MySQL 语句的集合，可将其视为批处理文件。</p>
<h4 id="为什么要使用存储过程？"><a href="#为什么要使用存储过程？" class="headerlink" title="为什么要使用存储过程？"></a>为什么要使用存储过程？</h4><ol>
<li>把处理封装在容易使用的单元中</li>
<li>不需要反复建立一系列处理步骤，让所有开发人员和应用程序都使用同一存储过程的相同代码，防止错误，鲁棒性。</li>
<li>简化对变动的管理，如果表名、列名或者业务逻辑有变动，只需要更改存储过程的代码，使用的它人员甚至对于变动都没有察觉，增加安全性。</li>
<li>提高性能，因为使用存储过程要比使用单独的 SQL 语句要快。</li>
</ol>
<p>简单来说就是三点，简单，鲁棒，安全，高性能。<br>不过将 SQL 语句转换为存储过程前，也必须知道其缺陷：</p>
<ol>
<li>编写存储过程比基本的 SQL 语句复杂</li>
<li>可能没有创建存储过程的安全访问权限，很多数据库管理人员允许用户使用存储过程，但是不允许他们创建存储过程。</li>
</ol>
<h4 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h4><p>存储过程的执行称之为调用，call 接受存储过程的名字以及需要传递给它的任意参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">call productpricing(</span><br><span class="line">@pricelow,</span><br><span class="line">@pricehigh,</span><br><span class="line">@priceaverage</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create procedure productpricing()</span><br><span class="line">begin</span><br><span class="line">select avg(prod_price) as priceaverage</span><br><span class="line">from products;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">call productpricing();</span><br><span class="line">priceaverage</span><br><span class="line">16.133571</span><br></pre></td></tr></table></figure>
<h4 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h4><p>存储过程被创建之后，被保存在服务器上以供使用，直至被删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">drop procedure productpricing;</span><br></pre></td></tr></table></figure>
<h4 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h4><p>productpricing 只是一个简单的存储过程，它简单地显示 select 语句的结果，一般，存储过程并不显示结果，而是把结果返回给你指定的变量。<br><strong>变量内存中的一个特定位置，用来临时存储数据</strong><br>以下是 productpricing 的修改版本，如果不先删除此存储过程，则不能再次创建它</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create procedure productpricing (</span><br><span class="line">out pl decimal(8, 2),</span><br><span class="line">out ph decimal(8, 2),</span><br><span class="line">out pa decimal(8, 2)</span><br><span class="line">)</span><br><span class="line">begin</span><br><span class="line">select min(prod_price)</span><br><span class="line">into pl</span><br><span class="line">from products;</span><br><span class="line">select max(prod_price)</span><br><span class="line">into ph</span><br><span class="line">from products;</span><br><span class="line">select avg(prod_price)</span><br><span class="line">into pa</span><br><span class="line">from products;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<p>关键字 out 指出相应的参数用来从存储过程传出一个值（返回给调用者），MySQL 支持 IN（传递给存储过程）、out（从存储过程传出）和 inout（对存储过程传入和传出）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">call productpricing(</span><br><span class="line">@pricelow,</span><br><span class="line">@pricehigh,</span><br><span class="line">@priceaverage</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>由于此存储过程要求 3 个参数，因此必须正好传递 3 个参数，不多也不少，所以，这条 call 语句给出 3 个参数，存储过程将把结果保存进这三个变量中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select @priceaverage;</span><br><span class="line">@priceaverage</span><br><span class="line">16.133571428</span><br></pre></td></tr></table></figure>
<p>下面是一个使用 in 和 out 参数的例子，ordertotal 接受订单号并返回该订单的合计：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create procedure ordertotal (</span><br><span class="line">in onumber int,</span><br><span class="line">out ototal decimal(8, 2)</span><br><span class="line">)</span><br><span class="line">begin</span><br><span class="line">select sum(item_price\*quantity)</span><br><span class="line">from orderitems</span><br><span class="line">where order_num = onumber</span><br><span class="line">into ototal;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">call ordertotal(20005, @total);</span><br><span class="line">select @total;</span><br><span class="line">@total</span><br><span class="line">149.87</span><br></pre></td></tr></table></figure>
<h3 id="Chapter-24-使用游标"><a href="#Chapter-24-使用游标" class="headerlink" title="Chapter 24 使用游标"></a>Chapter 24 使用游标</h3><p>有时，需要在检索出来的行中前进或者后退一行或者多行，这就是使用游标的原因，cursor 是一个存储在 MySQL 服务器上的数据库查询，它不是一条 select 语句，而是被该语句检索出来的数据集，在得到了游标之后，应用程序可以根据需要滚动或者浏览其中的数据。游标主要应用于交互式应用，其中用户可以滚动数据并对数据进行浏览或者做出更改。<br>不像多数 DBMS，MySQL 游标只能用于存储过程和函数。</p>
<h4 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h4><ol>
<li>在能够使用游标前，必须定义它，这个过程实际上并没有检索数据，它只是定义要使用的 select 语句。</li>
<li>一旦定义之后，必须打开游标以供使用，这个过程用前面定义的 select 语句把实际数据检索出来了</li>
<li>对于填有数据的游标，根据需要取出各行</li>
<li>在结束游标使用之后，必须关闭游标。</li>
</ol>
<p>在定义游标之后，可以按需频繁的打开和关闭游标，在游标打开之后，可按需频繁地执行取操作。</p>
<h4 id="创建游标"><a href="#创建游标" class="headerlink" title="创建游标"></a>创建游标</h4><p>游标用 declare 语句创建，并定义相应地 select 语句，根据需要带 where 和其他子句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create procedure processorders()</span><br><span class="line">begin</span><br><span class="line">declare ordernumbers cursor</span><br><span class="line">for</span><br><span class="line">select order_num from orders;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<h4 id="打开和关闭游标"><a href="#打开和关闭游标" class="headerlink" title="打开和关闭游标"></a>打开和关闭游标</h4><p>在处理 open 语句时执行查询，临时存储检索出的数据以供浏览和滚动。<br><code>open ordernumbers;</code><br>close 释放游标所使用的所有内部内存和资源，因此每个游标在不再需要时就应该关闭。<br><code>close ordernumbers;</code><br><strong>隐含关闭</strong>： 如果你不明确关闭游标，MySQL 将会在到达 end 语句时自动关闭它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create procedure processorders()</span><br><span class="line">begin</span><br><span class="line">-- declare the cursor</span><br><span class="line">declare ordernumbers cursor</span><br><span class="line">for</span><br><span class="line">select order_num from orders;</span><br><span class="line"></span><br><span class="line">    -- open the cursor</span><br><span class="line">    open ordernumbers;</span><br><span class="line"></span><br><span class="line">    -- close the cursor</span><br><span class="line">    close ordernumbers;</span><br><span class="line"></span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<p>这个存储过程定义，打开和关闭了一个游标，但是对于检索出来的数据什么处理也没有做。</p>
<h4 id="使用游标数据"><a href="#使用游标数据" class="headerlink" title="使用游标数据"></a>使用游标数据</h4><p>在一个游标被打开之后，可以使用 fetch 语句分别访问它的每一行，fetch 指定检索什么数据（所需的列），检索出来的数据存储在什么地方，它还向前移动游标中的内部指针，使得下一条 fetch 语句检索的是下一行而不是同一行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create procedure processorders()</span><br><span class="line">begin</span><br><span class="line">-- declare local variable</span><br><span class="line">declare o int;</span><br><span class="line"></span><br><span class="line">    -- declare the cursor</span><br><span class="line">    declare ordernumbers cursor</span><br><span class="line">    for</span><br><span class="line">    select order_num from orders;</span><br><span class="line"></span><br><span class="line">    -- open the cursor</span><br><span class="line">    open ordernumbers;</span><br><span class="line"></span><br><span class="line">    -- get order number</span><br><span class="line">    fetch ordernumbers into o;</span><br><span class="line"></span><br><span class="line">    -- close the cursor</span><br><span class="line">    close ordernumbers;</span><br><span class="line"></span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<p>fetch 检索当前行的 order_num 列（自动从第一行开始）到一个名为 o 的局部变量中，对检索出的数据不做任何处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create procedure processorders()</span><br><span class="line">begin</span><br><span class="line">-- declare local variable</span><br><span class="line">declare done boolean default 0;</span><br><span class="line">declare o int;</span><br><span class="line"></span><br><span class="line">    -- declare the cursor</span><br><span class="line">    declare ordernumbers cursor</span><br><span class="line">    for</span><br><span class="line">    select order_num from orders;</span><br><span class="line"></span><br><span class="line">    -- declare continue handler</span><br><span class="line">    declare continue handler for sqlstate &apos;02000&apos; set done = 1;</span><br><span class="line"></span><br><span class="line">    -- open the cursor</span><br><span class="line">    open ordernumbers;</span><br><span class="line"></span><br><span class="line">    -- loop through all rows</span><br><span class="line">    repeat</span><br><span class="line"></span><br><span class="line">        -- get order number</span><br><span class="line">        fetch ordernumbers into o;</span><br><span class="line"></span><br><span class="line">    -- end of loop</span><br><span class="line">    until done end repeat;</span><br><span class="line"></span><br><span class="line">    -- close the cursor</span><br><span class="line">    close ordernumbers;</span><br><span class="line"></span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<p><code>declare continue handler for sqlstate &#39;02000&#39; set done = 1;</code>这条语句定义了一个 continue handler，它是在条件出现时被执行的代码，这里，它指出当 SQLSTATE 为 ‘02000’ 条件出现时，set done = 1。SQLSTATE ‘02000’ 是一个未找到条件，当 repeat 由于没有更多的行供循环时，就会出现这个条件。</p>
<p><strong>declare 语句的次序</strong>：declare 语句的发布存在特定的次序，用 declare 语句定义的局部变量必须在定义在任意游标或句柄之前，而句柄必须定义在游标之后，不遵守此顺序将产生错误信息。<br>进一步修改的版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create procedure processorders()</span><br><span class="line">begin</span><br><span class="line">-- declare local variable</span><br><span class="line">declare done boolean default 0;</span><br><span class="line">declare o int;</span><br><span class="line">declare t decimal(8, 2);</span><br><span class="line"></span><br><span class="line">    -- declare the cursor</span><br><span class="line">    declare ordernumbers cursor</span><br><span class="line">    for</span><br><span class="line">    select order_num from orders;</span><br><span class="line"></span><br><span class="line">    -- declare continue handler</span><br><span class="line">    declare continue handler for sqlstate &apos;02000&apos; set done = 1;</span><br><span class="line"></span><br><span class="line">    -- create a table to store the results</span><br><span class="line">    create table if not exists ordertotals (</span><br><span class="line">        order_num   int,</span><br><span class="line">        total       decimal(8, 2)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    -- open the cursor</span><br><span class="line">    open ordernumbers;</span><br><span class="line"></span><br><span class="line">    -- loop through all rows</span><br><span class="line">    repeat</span><br><span class="line"></span><br><span class="line">        -- get order number</span><br><span class="line">        fetch ordernumbers into o;</span><br><span class="line"></span><br><span class="line">        -- get the total for this order</span><br><span class="line">        call ordertotal(o, t);</span><br><span class="line"></span><br><span class="line">        -- insert order and total into ordertotals</span><br><span class="line">        insert into ordertotals (order_num, total)</span><br><span class="line">        values (o, t);</span><br><span class="line"></span><br><span class="line">    -- end of loop</span><br><span class="line">    until done end repeat;</span><br><span class="line"></span><br><span class="line">    -- close the cursor</span><br><span class="line">    close ordernumbers;</span><br><span class="line"></span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<p>此存储过程不返回数据，但它能够创建和填充另一个表，可以查看该表：<br><code>select * from ordertotals;</code>。</p>
<h3 id="Chapter-25-使用触发器"><a href="#Chapter-25-使用触发器" class="headerlink" title="Chapter 25 使用触发器"></a>Chapter 25 使用触发器</h3><p>需要某条语句或者某些语句在事件发生时自动执行。<br>比如：</p>
<ul>
<li>每当增加一个顾客到某个数据库表时，都检查其电话号码格式是否正确，州的缩写是否大写；</li>
<li>每当订购一个产品时，都从库存数量中减去订购的数量</li>
<li>无论何时删除一行，都在某个存档表中保留一个副本</li>
</ul>
<p>所有的这些例子共同之处就是它们都需要在某个表发生变动时自动处理，触发器是 MySQL 响应以下任意语句时而自动执行的一条 MySQL 语句（或位于 begin 和 end 之间的一组语句）：</p>
<ul>
<li>update</li>
<li>insert</li>
<li>delete<br>其他语句不触发触发器。</li>
</ul>
<h4 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h4><ol>
<li>唯一的触发器名</li>
<li>触发器关联的表</li>
<li>触发器应该响应的活动（update insert delete）</li>
<li>触发器何时执行（处理之前或者处理之后）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create trigger newproduct after insert on products</span><br><span class="line">for each row select &apos;Product added&apos;;</span><br></pre></td></tr></table></figure>
<p>文本 Product added 将对每个插入的行显示一次。<br><strong>只有表才支持触发器，视图不支持，临时表也不支持。</strong><br>触发器按每个表每个事件每次地定义，每个表每个事件只允许一个触发器，每个表最多支持 6 个触发器，每条 insert，update，delete 的之前和之后，单一触发器不能与多个事件或者多个表关联，所以如果你需要一个对 insert 和 update 操作都触发的触发器，则应该定义两个触发器。<br><strong>触发器失败</strong>：如果 before 触发器失败，则 mysql 将不执行请求的操作，此外如果 before 触发器或者语句本身失败，MySQL 将不执行 after 触发器。</p>
<h4 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">drop trigger newproduct;</span><br></pre></td></tr></table></figure>
<p>触发器不能更改或者覆盖，为了修改一个触发器，必须先删除它，然后再重新创建。</p>
<h4 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h4><h5 id="insert-触发器："><a href="#insert-触发器：" class="headerlink" title="insert 触发器："></a>insert 触发器：</h5><ol>
<li>在 insert 触发器代码内部可以引用一个名为 NEW 的虚拟表，访问被插入的行</li>
<li>在 before insert 触发器中，NEW 中的值也可以被更新（允许更改被插入的值）</li>
<li>对于 auto_increment 列，new 在 insert 执行之前是 0，在 insert 执行之后包含新的自动生成值。</li>
</ol>
<p>比<code>select last_insert_id();</code>更好的方法是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create trigger neworder after insert on orders</span><br><span class="line">for each row select new.order_num;</span><br></pre></td></tr></table></figure>
<p>为了测试这个触发器<br><code>insert into orders (order_date, cust_id) values (now(), 10001);</code><br>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">order_num</span><br><span class="line">20010</span><br></pre></td></tr></table></figure>
<p><strong>before or after</strong>: 通常将 before 用于数据验证和净化，目的是保证插入表中的数据确实是需要的数据。</p>
<h5 id="delete-触发器"><a href="#delete-触发器" class="headerlink" title="delete 触发器"></a>delete 触发器</h5><p>在 delete 触发器代码内部，可以引用一个名为 old 的虚拟表，访问被删除的行。</p>
<h3 id="Chapter-26-管理事务处理"><a href="#Chapter-26-管理事务处理" class="headerlink" title="Chapter 26 管理事务处理"></a>Chapter 26 管理事务处理</h3><p>并不是所有的引擎都支持事务处理<br>transaction processing 可以用于维护数据库的完整性，它保证成批的 MySQL 操作要么完全执行，要么完全不执行。<br>几个常用的术语：</p>
<ol>
<li>事务 transaction 指一组 SQL 语句</li>
<li>回退 rollback 指撤销指定 SQL 语句的过程</li>
<li>提高 commit 指将未存储的 SQL 语句结果写入数据库表</li>
<li>保留点 savepoint 指事务处理中设置的临时占位符，你可以对它发布回退（与回退整个事务处理不同）</li>
</ol>
<h4 id="控制事务处理"><a href="#控制事务处理" class="headerlink" title="控制事务处理"></a>控制事务处理</h4><p>管理事务处理的关键在于将 SQL 语句组分解为逻辑块，并明确规定数据何时应该回退，何时不应该回退。<br>用<code>start transaction</code>标识事务的开始</p>
<h6 id="使用-rollback-来回退-MySQL-语句"><a href="#使用-rollback-来回退-MySQL-语句" class="headerlink" title="使用 rollback 来回退 MySQL 语句"></a>使用 rollback 来回退 MySQL 语句</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">select _ from ordertotals;</span><br><span class="line">start transaction;</span><br><span class="line">delete from ordertotals;</span><br><span class="line">select _ from ordertotals;</span><br><span class="line">rollback;</span><br><span class="line">select \* from ordertotals;</span><br></pre></td></tr></table></figure>
<p>哪些语句可以回退？<br>事务处理用来管理 insert，update，delete 语句，不能回退 create 或者 drop 操作，事务处理块中可以使用这两条语句，但是如果你执行回退，它们不会被撤销。</p>
<h6 id="使用-commit"><a href="#使用-commit" class="headerlink" title="使用 commit"></a>使用 commit</h6><p>一般的 MySQL 语句都是直接针对数据库表执行和编写的，这就是所谓的隐含提交（implicit commit），即提交操作是自动进行的。<br>但是，在事务处理块中，提交不会隐含地进行，为明确地进行提交，使用 commit 语句，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">start transaction;</span><br><span class="line">delete from orderitems where order_num = 20010;</span><br><span class="line">delete from orders where order_num = 20010;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，从系统中完全删除订单 20010，因为涉及到更新两个数据库表，所以使用事务处理块来保证订单不会被部分删除。最后地 commit 仅在不出错时写出更改，如果第一条 delete 起作用，但第二条语句失败，则 delete 会被撤销。<br>当 commit 或者 rollback 之后，事务会自动隐含关闭。</p>
<h5 id="使用保留点"><a href="#使用保留点" class="headerlink" title="使用保留点"></a>使用保留点</h5><p>简单的 rollback 和 commit 语句就可以写入或者撤销整个事务处理，但是更复杂的事务处理可能需要部分提交或者部分回退。<br>为了支持回退部分事务处理，必须在事务处理块中的合适位置放置占位符，这样，如果需要回退，可以回退到某个占位符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">savepoint delete1;</span><br><span class="line">....</span><br><span class="line">rollback to delete1;</span><br></pre></td></tr></table></figure>
<p>savepoint 越多越好。<br>保留点在事务处理完成（执行一条 rollback 或者 commit）后自动释放，也可以使用 release savepoint 来显式地释放保留点。<br>更改默认的提交行为，默认的 MySQL 行为是自动提交所有更改，为了指示 MySQL 不自动提交更改，需要使用以下语句<br><code>set autocommit = 0;</code><br>autocommit 标志是针对每个连接而不是服务器的。</p>
<h3 id="Chapter-28-安全管理"><a href="#Chapter-28-安全管理" class="headerlink" title="Chapter 28 安全管理"></a>Chapter 28 安全管理</h3><p>访问控制，MySQL 服务器的安全基础是：用户对于他们需要的数据具有适当的访问权，既不能多也不能少。<br>不要使用 root，应该严肃对待 root 登陆的使用，仅在绝对需要时使用它，或许在你不能登陆其他管理账号时使用，不应该在日常的 MySQL 操作中使用 root。<br>MySQL 用户账号和信息存储在名为 mysql 的 MySQL 数据库中，一般不需要直接访问 mysql 数据库和表，但是有时需要直接访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">use mysql;</span><br><span class="line">select user from user;</span><br></pre></td></tr></table></figure>
<h5 id="创建用户账号"><a href="#创建用户账号" class="headerlink" title="创建用户账号"></a>创建用户账号</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">create user ben identified by &apos;opop&apos;;</span><br></pre></td></tr></table></figure>
<p>使用 grant 或者 insert 也可以创建用户账号。但是为了安全起见，不建议直接对 user 表进行插入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">rename user ben to bforta;</span><br><span class="line">...</span><br><span class="line">drop user bforta;</span><br></pre></td></tr></table></figure>
<p>MySQL 5 之前：自 MySQL 5 以来，drop user 删除用户账号和所有相关的账号权限，在 MySQL 5 以前，drop user 只能用于删除用户账户，不能删除相关的权限，因此如果使用旧版本的 MySQL，需要先 revoke 删除与账号相关的权限，然后再使用 drop user 删除账号。</p>
<h4 id="设置访问权限"><a href="#设置访问权限" class="headerlink" title="设置访问权限"></a>设置访问权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">show grants for bforta;</span><br><span class="line"></span><br><span class="line">Grants for bforta@%</span><br><span class="line">GRANT USAGE ON _._ TO &apos;bforta&apos;@&apos;%&apos;</span><br></pre></td></tr></table></figure>
<p>USAGE 表示根本没有任何权限，此结果表示在任意数据库和任意表上对任何东西都没有权限。<br>为了设置权限，使用 grant 语句，grant 要求你至少给出以下信息：</p>
<ul>
<li>要授予的权限</li>
<li>被授予访问权限的数据库或表</li>
<li>用户名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">grant select on crashcourse.\* to bforta;</span><br></pre></td></tr></table></figure>
<p>用户 bforta 对于 crashcourse 数据库中的所有数据具有只读访问权限。<br><code>show grants for bforta;</code>反映了这个更改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Grants for bforta@%</span><br><span class="line">GRANT USAGE ON _._ TO &apos;bforta&apos;@&apos;%&apos;</span><br><span class="line">GRANT SELECT ON &apos;crashcourse&apos;.\* TO &apos;bforta&apos;@&apos;%&apos;</span><br></pre></td></tr></table></figure>
<p>grant 的反操作为 revoke，用它来撤销特定的权限，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">revoke select on crashcourse.\* from bforta;</span><br></pre></td></tr></table></figure>
<p>被撤销的访问权限必须存在，否则就会出错。<br>grant 和 revoke 可在几个层次上控制访问权限：</p>
<ul>
<li>整个服务器，grant all 和 revoke all</li>
<li>整个数据库，使用 on database.*</li>
<li>特定的表，使用 on database.table</li>
<li>特定的列</li>
<li>特定的存储过程</li>
</ul>
<h3 id="Chapter-30-改善性能"><a href="#Chapter-30-改善性能" class="headerlink" title="Chapter 30 改善性能"></a>Chapter 30 改善性能</h3><p><strong>数据库管理员把他们生命中的相当一部分时间花在了调整、试验以及改善 DBMS 性能之上</strong>。在诊断应用的滞缓现象和性能问题时，性能不良的数据库以及数据库查询通常是最常见的祸因。</p>
<ul>
<li>调整内存分配，缓冲区大小，为了查看当前设置，可使用 show variable;和 show status;。</li>
<li>MySQL 是一个多用户多线程的 DBMS，换言之，它经常同时执行多个任务，如果这些任务中的某一个执行缓慢，则所有请求都会执行缓慢，使用 show processlist; 显示所有活动进程以及它们的线程 ID 和执行时间，还可以使用 kill 命令终结某个特定的进程。</li>
<li>总是有不止一种方法编写同一条 select 语句，应该试验 join，union，子查询等，找出最佳的方法。</li>
<li>使用 explain 语句让 MySQL 解释它将如何执行一条 select 语句</li>
<li>一般而言，存储过程执行得比逐条要快</li>
<li>应该总是使用正确的数据类型</li>
<li>绝不要检索比需求还要多的数据</li>
<li>有的操作（包括 insert）支持一个可选的 delayed 关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。</li>
<li>在导入数据时，应该关闭自动提交，可以删除索引，包括 fulltext 索引，然后在导入完成后再重建它们。</li>
<li>必须索引数据库表以改善数据检索的性能确认索引挺难的，需要分析实用的 select 语句以找出重复的 where 和 order by 子句，如果一个简单的 where 子句返回结果所需的时间太长，则可以判定其中使用的列或者几列就是需要索引的对象。</li>
<li>你的 select 语句中有一系列复杂的 or 条件吗？通过使用多条 select 语句和连接它们的 union 语句，你能看到极大的性能提升。</li>
<li>索引可以改善数据检索的性能，但是损害数据插入、删除和更新的性能，如果一些表收集数据且不被经常检索，可以无需索引，索引可以按需添加和删除</li>
<li>like 很慢，一般来说，使用 fulltext 而不是 like。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MySQL/" rel="tag"># MySQL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/03/01/C-内存管理/" rel="prev" title="C++内存管理">
      <i class="fa fa-chevron-left"></i> C++内存管理
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/03/16/计算机概念的英文表述/" rel="next" title="计算机概念的英文表述">
      计算机概念的英文表述 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-1"><span class="nav-number">1.</span> <span class="nav-text">Chapter 1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-2"><span class="nav-number">2.</span> <span class="nav-text">Chapter 2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Chapter-3-使用-MySQL"><span class="nav-number">3.</span> <span class="nav-text">Chapter 3 使用 MySQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-4-检索数据"><span class="nav-number">3.1.</span> <span class="nav-text">Chapter 4 检索数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-5-排序检索数据"><span class="nav-number">3.2.</span> <span class="nav-text">Chapter 5 排序检索数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-6-过滤数据"><span class="nav-number">3.3.</span> <span class="nav-text">Chapter 6 过滤数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-7-数据过滤"><span class="nav-number">3.4.</span> <span class="nav-text">Chapter 7 数据过滤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-8-用通配符进行过滤"><span class="nav-number">3.5.</span> <span class="nav-text">Chapter 8 用通配符进行过滤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-9-使用正则表达式"><span class="nav-number">3.6.</span> <span class="nav-text">Chapter 9 使用正则表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-10-创建计算字段"><span class="nav-number">3.7.</span> <span class="nav-text">Chapter 10 创建计算字段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#拼接字段"><span class="nav-number">3.7.1.</span> <span class="nav-text">拼接字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#执行算术运算"><span class="nav-number">3.7.2.</span> <span class="nav-text">执行算术运算</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-11-使用数据处理函数"><span class="nav-number">3.8.</span> <span class="nav-text">Chapter 11 使用数据处理函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文本处理函数"><span class="nav-number">3.8.1.</span> <span class="nav-text">文本处理函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#日期和时间处理函数"><span class="nav-number">3.8.2.</span> <span class="nav-text">日期和时间处理函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数值处理函数"><span class="nav-number">3.8.3.</span> <span class="nav-text">数值处理函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-12-汇总数据"><span class="nav-number">3.9.</span> <span class="nav-text">Chapter 12 汇总数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-13-分组数据"><span class="nav-number">3.10.</span> <span class="nav-text">Chapter 13 分组数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#过滤分组"><span class="nav-number">3.10.1.</span> <span class="nav-text">过滤分组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-14-使用子查询"><span class="nav-number">3.11.</span> <span class="nav-text">Chapter 14 使用子查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#子查询结果作为计算字段使用"><span class="nav-number">3.11.1.</span> <span class="nav-text">子查询结果作为计算字段使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-15-联结表"><span class="nav-number">3.12.</span> <span class="nav-text">Chapter 15 联结表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内部联结"><span class="nav-number">3.12.1.</span> <span class="nav-text">内部联结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#联结多个表"><span class="nav-number">3.12.2.</span> <span class="nav-text">联结多个表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-16-创建高级联结"><span class="nav-number">3.13.</span> <span class="nav-text">Chapter 16 创建高级联结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用表别名"><span class="nav-number">3.13.1.</span> <span class="nav-text">使用表别名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用不同类型的联结"><span class="nav-number">3.13.2.</span> <span class="nav-text">使用不同类型的联结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#自然联结"><span class="nav-number">3.13.2.1.</span> <span class="nav-text">自然联结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#外部联结"><span class="nav-number">3.13.2.2.</span> <span class="nav-text">外部联结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用带聚集函数的联结"><span class="nav-number">3.13.2.3.</span> <span class="nav-text">使用带聚集函数的联结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-17-组合查询-compound-query"><span class="nav-number">3.14.</span> <span class="nav-text">Chapter 17 组合查询 compound query</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对组合查询结果进行排序"><span class="nav-number">3.14.0.1.</span> <span class="nav-text">对组合查询结果进行排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-18-全文本搜索"><span class="nav-number">3.15.</span> <span class="nav-text">Chapter 18 全文本搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-19-插入数据"><span class="nav-number">3.16.</span> <span class="nav-text">Chapter 19 插入数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#插入检索出的数据"><span class="nav-number">3.16.1.</span> <span class="nav-text">插入检索出的数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-20-更新和删除数据"><span class="nav-number">3.17.</span> <span class="nav-text">Chapter 20 更新和删除数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-21-创建和操纵表"><span class="nav-number">3.18.</span> <span class="nav-text">Chapter 21 创建和操纵表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#引擎类型"><span class="nav-number">3.18.1.</span> <span class="nav-text">引擎类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#alter-表"><span class="nav-number">3.18.2.</span> <span class="nav-text">alter 表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-22-使用视图"><span class="nav-number">3.19.</span> <span class="nav-text">Chapter 22 使用视图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#视图用处"><span class="nav-number">3.19.1.</span> <span class="nav-text">视图用处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#利用视图简化复杂的联结"><span class="nav-number">3.19.2.</span> <span class="nav-text">利用视图简化复杂的联结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#利用视图重新格式化检索出的数据"><span class="nav-number">3.19.3.</span> <span class="nav-text">利用视图重新格式化检索出的数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用视图过滤不想要的数据"><span class="nav-number">3.19.4.</span> <span class="nav-text">用视图过滤不想要的数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用视图与计算字段"><span class="nav-number">3.19.5.</span> <span class="nav-text">使用视图与计算字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更新视图"><span class="nav-number">3.19.6.</span> <span class="nav-text">更新视图</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-23-使用存储过程"><span class="nav-number">3.20.</span> <span class="nav-text">Chapter 23 使用存储过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么要使用存储过程？"><span class="nav-number">3.20.1.</span> <span class="nav-text">为什么要使用存储过程？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用存储过程"><span class="nav-number">3.20.2.</span> <span class="nav-text">使用存储过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建存储过程"><span class="nav-number">3.20.3.</span> <span class="nav-text">创建存储过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除存储过程"><span class="nav-number">3.20.4.</span> <span class="nav-text">删除存储过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用参数"><span class="nav-number">3.20.5.</span> <span class="nav-text">使用参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-24-使用游标"><span class="nav-number">3.21.</span> <span class="nav-text">Chapter 24 使用游标</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用游标"><span class="nav-number">3.21.1.</span> <span class="nav-text">使用游标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建游标"><span class="nav-number">3.21.2.</span> <span class="nav-text">创建游标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#打开和关闭游标"><span class="nav-number">3.21.3.</span> <span class="nav-text">打开和关闭游标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用游标数据"><span class="nav-number">3.21.4.</span> <span class="nav-text">使用游标数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-25-使用触发器"><span class="nav-number">3.22.</span> <span class="nav-text">Chapter 25 使用触发器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建触发器"><span class="nav-number">3.22.1.</span> <span class="nav-text">创建触发器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除触发器"><span class="nav-number">3.22.2.</span> <span class="nav-text">删除触发器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用触发器"><span class="nav-number">3.22.3.</span> <span class="nav-text">使用触发器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#insert-触发器："><span class="nav-number">3.22.3.1.</span> <span class="nav-text">insert 触发器：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#delete-触发器"><span class="nav-number">3.22.3.2.</span> <span class="nav-text">delete 触发器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-26-管理事务处理"><span class="nav-number">3.23.</span> <span class="nav-text">Chapter 26 管理事务处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#控制事务处理"><span class="nav-number">3.23.1.</span> <span class="nav-text">控制事务处理</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#使用-rollback-来回退-MySQL-语句"><span class="nav-number">3.23.1.0.1.</span> <span class="nav-text">使用 rollback 来回退 MySQL 语句</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#使用-commit"><span class="nav-number">3.23.1.0.2.</span> <span class="nav-text">使用 commit</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用保留点"><span class="nav-number">3.23.1.1.</span> <span class="nav-text">使用保留点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-28-安全管理"><span class="nav-number">3.24.</span> <span class="nav-text">Chapter 28 安全管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#创建用户账号"><span class="nav-number">3.24.0.1.</span> <span class="nav-text">创建用户账号</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设置访问权限"><span class="nav-number">3.24.1.</span> <span class="nav-text">设置访问权限</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Chapter-30-改善性能"><span class="nav-number">3.25.</span> <span class="nav-text">Chapter 30 改善性能</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fengcun Li"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Fengcun Li</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">111</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fengcun Li</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  











<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
