<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="Chapter 1数据库就是数据库管理系统创建和操纵的容器。模式(schema) 可以用来描述数据库中特定的表以及整个数据库（和其中表的关系），即关于数据库和表的布局及特性信息。
数据类型限制可存储在列中的数据类型，帮助正确的排序数据，并在优化磁盘使用方面起重要的作用。主键：一列或者一组列，其值可以唯一区分表中的每行。没有主键，更新后者删除表中特定行是困难的，因为没有安全的方式保证只涉及相关的行。虽然并不总是需要主键，但是大多数数据库设计人员应该保证他们创建额每个表具有一个主键，以便于以后的数据操纵和管理。表中的任何列都可以作为主键，只要满足两个条件：

任意两行不具有相同的主键
每个行都必须具有一个主键值，主键列不允许NULL值。主键的最佳实践：
不更新主键列的值
不重用主键列的值
不在主键列中使用可能会更改的值。">
    

    <!--Author-->
    
        <meta name="author" content="Robert Lexis">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="MySQL Crash Course 读书笔记"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="This is Robert Lexis."/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>MySQL Crash Course 读书笔记 - This is Robert Lexis.</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
    </div>
</header>

        <section class="main">
            
<div class="post">

    <div class="post-header">
        <h1 class="title">
            <a href="/2018/03/15/MySQL-Crash-Course-读书笔记/">
                MySQL Crash Course 读书笔记
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-03-15</span>
            
            
            
        </div>
    </div>

    <div class="content">

        <!-- Gallery -->
        

        <!-- Post Content -->
        <h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><p>数据库就是数据库管理系统创建和操纵的容器。<br>模式(schema) 可以用来描述数据库中特定的表以及整个数据库（和其中表的关系），即关于数据库和表的布局及特性信息。</p>
<p>数据类型限制可存储在列中的数据类型，帮助正确的排序数据，并在优化磁盘使用方面起重要的作用。<br>主键：一列或者一组列，其值可以唯一区分表中的每行。没有主键，更新后者删除表中特定行是困难的，因为没有安全的方式保证只涉及相关的行。虽然并不总是需要主键，但是大多数数据库设计人员应该保证他们创建额每个表具有一个主键，以便于以后的数据操纵和管理。<br>表中的任何列都可以作为主键，只要满足两个条件：</p>
<ol>
<li>任意两行不具有相同的主键</li>
<li>每个行都必须具有一个主键值，主键列不允许NULL值。<br>主键的最佳实践：</li>
<li>不更新主键列的值</li>
<li>不重用主键列的值</li>
<li>不在主键列中使用可能会更改的值。<a id="more"></a>
</li>
</ol>
<h2 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h2><p>DBMS 可以分为两类</p>
<ol>
<li>基于共享文件系统， Microsoft Access， FileMaker，桌面用途。</li>
<li>基于客户机-服务器， MySQL， Oracle，Microsoft SQL Server。<br>注意：</li>
<li>命令用;或者\g结束，换句话说，仅按Enter不执行命令。</li>
<li>help or \h</li>
<li>quit or exit</li>
</ol>
<h2 id="Chapter-3-使用-MySQL"><a href="#Chapter-3-使用-MySQL" class="headerlink" title="Chapter 3 使用 MySQL"></a>Chapter 3 使用 MySQL</h2><p>默认端口 3306<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use crashcourse;</div><div class="line">Database changed</div></pre></td></tr></table></figure></p>
<p>数据库、表、列、用户、权限等的信息被存储在数据库和表中，MySQL 使用 MySQL 来存储这些信息。不过，内部的表一般不直接访问，可使用 MySQL 的 show 命令来显示这些信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show databases;</div></pre></td></tr></table></figure></p>
<p>包含在结果列表中的可能是 MySQL 内部使用的数据库，如 mysql， information_schema。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show tables;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show columns from customers;</div></pre></td></tr></table></figure>
<p>什么是自动增量？<br>某些表列需要唯一值，例如订单编号，在每个行添加至表中时，MySQL 可以自动地为每个行分配下一个可用编号，不用在添加一行时手动分配唯一值（这样必须记住最后一次使用的值）。<br>describe 语句， MySQL 支持用 describe 作为 show columns from 的一种快捷方式。<br>所支持的其他show语句还有：</p>
<ul>
<li>show status, 用于显示广泛的服务器状态信息</li>
<li>show create database, show create table，用来显示创建特定数据库或表的MySQL语句。</li>
<li>show grants, 用来显示授予用户（所有用户或特定用户）的安全权限。</li>
<li>show errors, show warnings 用来显示服务器错误或者警告信息。</li>
</ul>
<h3 id="Chapter-4-检索数据"><a href="#Chapter-4-检索数据" class="headerlink" title="Chapter 4 检索数据"></a>Chapter 4 检索数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select prod_name from products;</div></pre></td></tr></table></figure>
<p>如果没有明确排序查询结果，则返回的数据的顺序并没有特殊意义，返回数据的顺序可能是数据被添加到表中的顺序，也可能不是。<br>多条 SQL 语句必须以分号分隔，MySQL 如同多数DBMS一样，不需要在单条SQL语句后加分号，但是在mysql 命令行，必须加上分号来结束SQL语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">select * from products;</div><div class="line">select distinct vend_id from products;</div></pre></td></tr></table></figure></p>
<p>不能部分使用distinct, distinct 关键字应用于所有列而不仅仅是前置它的列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">select prod_name from products limit 5;</div><div class="line">select prod_name from products limit 6, 5;</div></pre></td></tr></table></figure></p>
<p>limit 6, 5 返回从行6开始的5行。包前。<br>如果没有足够的行，只返回它能返回的行数。<br>由于这两位数字的混淆，MySQL 5 支持 limit 的另一种替代语法，<code>limit 4 offset 3</code>。<br>表名和列名可以是完全限定的，<code>select products.prod_name from crashcourse.products</code>，在一些情形下是需要完全限定名的。</p>
<h3 id="Chapter-5-排序检索数据"><a href="#Chapter-5-排序检索数据" class="headerlink" title="Chapter 5 排序检索数据"></a>Chapter 5 排序检索数据</h3><p>select 语句的 order by 子句。<br>子句 clause，SQL 语句由子句构成，有些子句是必须的，有些子句是可选的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select prod_name from products order by prod_name;</div></pre></td></tr></table></figure></p>
<p>用非检索的列排序数据是完全合法的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select prod_id, prod_price, prod_name from products order by prod_price, prod_name;</div></pre></td></tr></table></figure></p>
<p>指定排序方向<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select prod_id, prod_price, prod_name from products order by prod_price desc, prod_name;</div></pre></td></tr></table></figure></p>
<p>desc 关键字只应用于直接位于其前面的列名。<br>在给出 order by 子句时，应该保证它位于 from 子句之后，如果使用 limit 子句，它必须位于 order by 子句之后，使用的子句顺序不对将产生错误信息。</p>
<h3 id="Chapter-6-过滤数据"><a href="#Chapter-6-过滤数据" class="headerlink" title="Chapter 6 过滤数据"></a>Chapter 6 过滤数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select prod_name, prod_price from products where prod_price = 2.50;</div></pre></td></tr></table></figure>
<p>SQL 过滤与应用过滤：SQL 过滤快速且节省带宽。<br>在同时使用 order by 和 where时，应该让 order by 位于 where 之后。<br>where 子句操作符：</p>
<ul>
<li>= 等于</li>
<li>&lt;&gt; 不等于</li>
<li>!= 不等于</li>
<li>&lt;, &lt;=, &gt;, &gt;=</li>
<li>between</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select prod_name, prod_price from products where prod_name = &apos;fuses&apos;;</div></pre></td></tr></table></figure>
<p>何时使用括号？<br>单引号用来限定字符串，如果将值与串类型的列进行比较，则需要引号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select prod_name, prod_price from products where prod_price between 5 and 10;</div></pre></td></tr></table></figure></p>
<p>包前包后。<br>NULL 与 0，空字符串或者仅仅包含空格不同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select prod_name from products where prod_name is null;</div></pre></td></tr></table></figure></p>
<h3 id="Chapter-7-数据过滤"><a href="#Chapter-7-数据过滤" class="headerlink" title="Chapter 7 数据过滤"></a>Chapter 7 数据过滤</h3><p>MySQL 允许给出多个 where 子句，并用 and 或者 or 进行连接。<br>计算次序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select prod_name, prod_price from products where vend_id = 1002 or vend_id = 1003 and prod_price &gt;= 10;</div></pre></td></tr></table></figure></p>
<p>SQL 在处理 or 操作符之前，优先处理 and 操作符，当 MySQL 看到上面的句子时，它理解为由供应商 1003 制造的价格 10 美元（含）以上的产品，或者由供应商 1002 制造的任何产品，而不管其价格如何。<br>换句话说，and 在计算次序中优先级更高。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select prod_name, prod_price from products where (vend_id = 1003 or vend_id = 1002) and prod_price &gt;= 10;</div></pre></td></tr></table></figure></p>
<p>圆括号在 where 子句中除了用于明确计算顺序，还能用来指定 in 操作符的范围，合法值由逗号分隔，全部都在圆括号中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select prod_name, prod_price from products where vend_id in (1002, 1003, 1004) order by prod_name;</div></pre></td></tr></table></figure></p>
<p>in 操作符与 or 操作符完成相同的功能，那为什么使用 in 操作符呢？</p>
<ol>
<li>直观</li>
<li>计算次序更加容易管理</li>
<li>比 or 更快</li>
<li>in 的最大优点是可以包含其他的 select 语句，使得能够动态地建立 where 子句。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select prod_name, prod_price from products where vend_id not in (1002, 1003, 1004) order by prod_name;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>MySQL 支持使用 not 对 in，between，exists 子句取反。</p>
<h3 id="Chapter-8-用通配符进行过滤"><a href="#Chapter-8-用通配符进行过滤" class="headerlink" title="Chapter 8 用通配符进行过滤"></a>Chapter 8 用通配符进行过滤</h3><p>like 操作符<br>为在搜索子句中使用通配符，必须使用 like 操作符，like 指示 MySQL 后跟的搜索模式利用通配符匹配而不是直接相等比较。<br>%表示任意字符出现任意次数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select prod_id, prod_name from products where prod_name like &apos;jet%&apos;;</div></pre></td></tr></table></figure></p>
<p><strong>根据MySQL的配置方式，搜索可以是区分大小写的，如果区分大小写，’jet%’ 与 JetPack 1000 将不匹配。</strong><br>注意尾空格，例如，在保存词 anvil 时，如果它后面有一个或者多个空格，则子句 where prod_name like ‘%anvil’ 将不会匹配它们，解决这个问题的一个简单办法是在搜索模式（search pattern）的最后附加一个%，一个更好的方式是使用函数去掉尾空格。<br><strong>% 似乎可以匹配任何东西，但是NULL除外。</strong><br><code>_</code> 通配符，只匹配单个字符。<br>通配符的使用技巧：</p>
<ol>
<li>不要过度使用通配符。</li>
<li>在确实需要使用通配符时，除非有必要，否则不要将通配符放在搜索模式的开始处，放在开始处搜索起来是最慢的。</li>
</ol>
<h3 id="Chapter-9-使用正则表达式"><a href="#Chapter-9-使用正则表达式" class="headerlink" title="Chapter 9 使用正则表达式"></a>Chapter 9 使用正则表达式</h3><p>MySQL 仅支持正则表达式的一个很小的子集。<br>基本字符匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select prod_name from products where prod_name regexp &apos;1000&apos; order by prod_name;</div></pre></td></tr></table></figure></p>
<p>返回列 prod_name 包含 ‘1000’ 的所有行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select prod_name from products where prod_name regexp &apos;.000&apos; order by prod_name;</div></pre></td></tr></table></figure></p>
<p>MySQL 的正则表达式匹配不区分大小写，为了区分大小写可以用 binary 关键字，如 <code>where prod_name regexp binary &#39;JetPack .000&#39;</code><br>进行 or 匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select prod_name from products where prod_name regexp &apos;1000|2000|3000&apos; order by prod_name;</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">prod_name</div><div class="line">JetPack 1000</div><div class="line">JetPack 2000</div><div class="line">JetPack 3000</div></pre></td></tr></table></figure></p>
<p>匹配几个字符之一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select prod_name from products where prod_name regexp &apos;[123] Ton&apos; order by prod_name;</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">prod_name</div><div class="line">1 ton anvil</div><div class="line">2 ton anvil</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select prod_name from products where prod_name regexp &apos;[^123] Ton&apos; order by prod_name;</div></pre></td></tr></table></figure>
<p>匹配除这些字符外的任何东西。<br>匹配范围[1-9]，[a-z]。<br>匹配特殊字符，必须以<code>\\</code>为前导。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select prod_name from products where </div><div class="line">prod_name regexp &apos;\\([0-9] sticks?\\)&apos;</div><div class="line">order by prod_name;</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">prod_name</div><div class="line">TNT (1 stick)</div><div class="line">TNT (7, sticks)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">select prod_name from products where </div><div class="line">prod_name regexp &apos;[[:digit:]]&#123;4&#125;&apos; order by prod_name;</div></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">prod_name</div><div class="line">JetPack 1000</div><div class="line">JetPack 2000</div></pre></td></tr></table></figure></p>
<p>定位符 <code>^, $, [[:&lt;:]], [[:&gt;:]]</code>。</p>
<h3 id="Chapter-10-创建计算字段"><a href="#Chapter-10-创建计算字段" class="headerlink" title="Chapter 10 创建计算字段"></a>Chapter 10 创建计算字段</h3><p>计算字段，比如城市、州、邮编的拼接，单价乘以数量，根据表数据进行总数、平均数或者其他的计算。计算字段也是一个字段，但是它并不存在于实际的数据库表中，计算字段是在运行时在select 语句内创建出来的。</p>
<h4 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h4><p>concatenate 将值连起来一起构成单个值。<br>MySQL 的不同之处，多数 DBMS 使用 <code>+</code> 或 <code>||</code> 实现拼接，而 MySQL 则使用 <code>Concat()</code> 函数来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select concat(vend_name, &apos; (&apos;, vend_county, &apos;)&apos;) from vendors order by vend_name;</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">concat(vend_name, &apos; (&apos;, vend_county, &apos;)&apos;)</div><div class="line">ACME (USA)</div><div class="line">Anvil R us (USA)</div></pre></td></tr></table></figure></p>
<p>通过使用 <code>rtrim()</code> 函数来删除数据右侧多余的空格整理数据。<br>ltrim，trim。<br>使用别名，上面的语句工作得很好，但是在 select 语句内创建出来的计算字段并没有名称，不能被后续使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select concat(rtrim(vend_name), &apos; (&apos;, rtrim(vend_county), &apos;)&apos;) as vend_title from vendors order by vend_name;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vend_title</div><div class="line">ACME (USA)</div><div class="line">Anvil R us (USA)</div></pre></td></tr></table></figure>
<p>如今就像一个实际的表列一样。<br>别名还有其他的用处，包括在实际的表列名包含不符合规定的字符（如空格）时重新命名它，在原来的名字含混或者容易误解时扩充它。</p>
<h4 id="执行算术运算"><a href="#执行算术运算" class="headerlink" title="执行算术运算"></a>执行算术运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select prod_id, quantity, item_price from orderitems where order_num = 2005;</div></pre></td></tr></table></figure>
<p>检索出订单号为2005的订单包含的所有物品。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select prod_id, quantity, item_price, quantity * item_price as expanded_price </div><div class="line">from orderitems </div><div class="line">where order_num = 2005;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select 3*2; 6</div><div class="line">select trim(&apos; abc &apos;); abc</div><div class="line">select now(); 当前的日期与时间</div></pre></td></tr></table></figure>
<h3 id="Chapter-11-使用数据处理函数"><a href="#Chapter-11-使用数据处理函数" class="headerlink" title="Chapter 11 使用数据处理函数"></a>Chapter 11 使用数据处理函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select vend_name, upper(vend_name) as vend_name_uppercase from vendors order by vend_name;</div></pre></td></tr></table></figure>
<h4 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h4><ul>
<li>left</li>
<li>right</li>
<li>length</li>
<li>locate</li>
<li>lower</li>
<li>upper</li>
<li>ltrim</li>
<li>rtrim</li>
<li>trim</li>
<li>substring</li>
<li>soundex</li>
</ul>
<h4 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h4><p>日期和时间采用相应的数据类型和特殊的格式存储，以便能够快速和有效地排序或过滤，并节省物理存储空间。<br>一般地，应用程序并不直接处理、使用这样的格式，因此就需要日期和时间处理函数来读取、统计和处理这些值。由于这个原因，日期和时间处理函数在MySQL中具有重要的作用。<br>常用的函数：</p>
<ul>
<li>adddate</li>
<li>addtime</li>
<li>curdate</li>
<li>curtime</li>
<li>date 返回日期时间的日期部分</li>
<li>datediff 计算两个日期之差</li>
<li>date_add</li>
<li>date_format 返回一个格式化的日期或者时间字符串</li>
<li>day</li>
<li>dayofweek</li>
<li>hour</li>
<li>minute</li>
<li>month</li>
<li>now</li>
<li>second</li>
<li>time</li>
<li>year</li>
</ul>
<p>首先需要注意的是 MySQL 使用的日期格式，无论你什么时候指定一个日期，不管是插入或者更新表值还是使用 <code>where</code> 子句进行过滤，日期都必须为 <code>yyyy-mm-dd</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select cust_id, order_num from orders where order_date = &apos;2015-09-01&apos;;</div></pre></td></tr></table></figure></p>
<p>order_date 的数据类型是 datetime，这种类型存储日期及时间，因此 <code>&#39;2015-09-01&#39;</code> 匹配的是 <code>&#39;2015-09-01 00:00:00&#39;</code>。<br>如果是要日期请使用 <code>date()</code> 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select cust_id, order_num from orders where date(order_date) = &apos;2015-09-01&apos;;</div></pre></td></tr></table></figure></p>
<p>使用 date 是一个良好的习惯，即使你知道相应的列只包含日期也是如此，这样由于某种原因表中以后有日期和时间值，你的SQL代码也不用修改。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select cust_id, order_num from orders where date(order_date) between &apos;2015-09-01&apos; and &apos;2005-09-30&apos;;</div></pre></td></tr></table></figure></p>
<h4 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h4><ul>
<li>abs </li>
<li>cos</li>
<li>exp</li>
<li>mod</li>
<li>pi</li>
<li>rand</li>
<li>sin </li>
<li>sqrt</li>
<li>tan</li>
</ul>
<h3 id="Chapter-12-汇总数据"><a href="#Chapter-12-汇总数据" class="headerlink" title="Chapter 12 汇总数据"></a>Chapter 12 汇总数据</h3><p>聚集函数<br>我们经常需要汇总数据而不用把它们实际检索出来，当需要的是对表中数据汇总而不是实际数据本身时，返回实际数据是对处理时间和处理资源的一种浪费，更不用说带宽了。<br>MySQL 给出了5个聚集函数（aggregate function），聚集函数是运行在行组上，计算和返回单个值的函数。</p>
<ul>
<li>avg 返回某列的平均值</li>
<li>count 返回某列的行数</li>
<li>max 返回某列的最大值</li>
<li>min 返回某列的最小值</li>
<li>sum 返回某列值之和</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select avg(prod_price) as avg_price from products where vend_id = 1003;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">avg_price</div><div class="line">16.133571</div></pre></td></tr></table></figure></p>
<p><code>avg</code> 只能用于单个列，为了获得多个列的平均值，必须使用多个 <code>avg</code> 函数，<code>avg</code> 函数会自动忽略 <code>null</code> 的行。<br>count 函数有两种使用方式：</p>
<ol>
<li>使用 <code>count(*)</code> 对表中行的数目进行计数，不管表列中包含的是空值还是非空值。</li>
<li>使用 <code>count(column)</code> 对特定列中具有值的行进行计数，忽略 <code>null</code> 值。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select count(*) as num_cust from customers;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>sum 函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select sum(item_price*quantity) as total_price from orderitems where order_num = 2005;</div></pre></td></tr></table></figure></p>
<p>聚集不同值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select avg(distinct prod_price) as avg_price from products where vend_id = 1003;</div></pre></td></tr></table></figure></p>
<p>all 为默认值。<br>聚集函数组合<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">select count(*) as num_items, </div><div class="line">    min(prod_price) as price_min,</div><div class="line">    max(prod_price) as price_max,</div><div class="line">    avg(prod_price) as price_avg</div><div class="line">from products;</div></pre></td></tr></table></figure></p>
<h3 id="Chapter-13-分组数据"><a href="#Chapter-13-分组数据" class="headerlink" title="Chapter 13 分组数据"></a>Chapter 13 分组数据</h3><p>这涉及到两个 <code>select</code> 语句子句，分别是 <code>group by</code> 和 <code>having</code>。<br>在上一章汇总数据时，是在表的所有数据或匹配特定的 <code>where</code> 子句的数据上进行的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select vend_id, count(*) as num_prods from products group by vend_id;</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vend_id num_prods</div><div class="line">1001 3</div><div class="line">1002 2</div><div class="line">1003 7</div><div class="line">1005 2</div></pre></td></tr></table></figure></p>
<p>group by 的注意：</p>
<ol>
<li>可以嵌套</li>
<li><strong>除了聚集计算语句外，select 语句中的每个列都必须在 group by 子句中给出</strong></li>
<li>如果分组列中有 <code>null</code> 值，则 <code>null</code> 将作为一个分组返回。</li>
<li><code>group by</code> 子句必须出现在 <code>where</code> 子句之后，<code>order by</code> 子句之前。</li>
</ol>
<h4 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h4><p>MySQL 允许过滤分组，规定包括哪些分组，排除哪些分组，例如，可能想要列出至少有两个订单的所有顾客，为了得到这个结果，必须基于用户分组进行计数并过滤而不是个别的行进行过滤。<br>where 可以基于行而不是分组进行过滤，事实上，where 没有分组的概念。<br>使用 having， having 非常类似where，事实上，目前为止所学的所有类型的where子句都用在having中来，唯一的差别是having 是过滤分组。<br>having 支持所有where 操作符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select cust_id, count(*) as orders from orders group by cust_id having count(*) &gt;= 2;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">select vend_id, count(*) as num_prods from products where prod_price &gt;= 10</div><div class="line">group by vend_id having count(*) &gt;= 2;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">select order_num, sum(quantity*item_price) as ordertotal </div><div class="line">from orderitems</div><div class="line">group by order_num </div><div class="line">having sum(quantity*item_price) &gt;= 50</div><div class="line">order by ordertotal;</div></pre></td></tr></table></figure>
<p>having 子句中使用 <code>sum(quantity*item_price)</code>，而order by 子句中使用 ordertotal ，这是因为这两个子句分别运行于 as 子句之前和之后。</p>
<h3 id="Chapter-14-使用子查询"><a href="#Chapter-14-使用子查询" class="headerlink" title="Chapter 14 使用子查询"></a>Chapter 14 使用子查询</h3><p>子查询嵌套在其他查询中的查询。<br>orderitems&lt;-orders-&gt;customers<br>要求列出订购物品TNT2的所有客户：<br>需要三条查询语句</p>
<ol>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select order_num from orderitems where prod_id = &apos;TNT2&apos;;</div><div class="line">order_num</div><div class="line">20005</div><div class="line">20007</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select cust_id from orders where order_num in (20005, 20007);</div><div class="line">cust_id</div><div class="line">10001</div><div class="line">10004</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select cust_name, cust_contact from customers where cust_id in (10001, 10004);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>也可以使用一条语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">select cust_name, cust_contact from customers where cust_id in (</div><div class="line">    select cust_id from orders where order_num in (</div><div class="line">        select order_num from orderitems where prod_id = &apos;TNT2&apos;</div><div class="line">    )</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p><strong>列必须匹配： 在where子句中使用子查询， 应该保证select语句具有与where子句中相同数目的列，通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列。</strong><br>子查询及其性能，这里给出的代码有效并获得了所需的结果，但是，使用子查询并不总是执行这种类型的数据检索的最有效的方法。</p>
<h4 id="子查询结果作为计算字段使用"><a href="#子查询结果作为计算字段使用" class="headerlink" title="子查询结果作为计算字段使用"></a>子查询结果作为计算字段使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select cust_name, cust_state, </div><div class="line">    (select count(*) from orders where orders.cust_id = customers.cust_id) as orders </div><div class="line">from customers order by cust_name;</div></pre></td></tr></table></figure>
<p>子查询及其性能，这里给出的代码有效并获得了所需的结果，但是，使用子查询并不总是执行这种类型的数据检索的最有效的方法。<br>逐渐增加子查询来建立查询，首先，建立和测试最内层的查询，然后，用硬编码数据建立和测试外层查询，并且仅在确认它正常后才嵌入子查询，这时再次测试它。</p>
<h3 id="Chapter-15-联结表"><a href="#Chapter-15-联结表" class="headerlink" title="Chapter 15 联结表"></a>Chapter 15 联结表</h3><p>SQL 最强大的功能之一就是能在数据检索查询的执行中联结 (join) 表。<br>外键 (foreign key)，外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系：<br>这样做的好处是：</p>
<ol>
<li>数据不重复，节省空间。</li>
<li>信息变动时，可以只更新一个表中的单个记录，相关表中的数据不用改动。</li>
<li>数据的一致性好。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select vend_name, prod_name, prod_price</div><div class="line">from vendors, products</div><div class="line">where vendors.vend_id = products.vend_id</div><div class="line">order by vend_name, prod_name;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>笛卡儿积 由没有联结条件的表关系返回的结果为笛卡儿积，检索出的行的数目为第一个表中的行数乘以第二个表中的行数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select vend_name, prod_name, prod_price</div><div class="line">from vendors, products</div><div class="line">order by vend_name, prod_name;</div></pre></td></tr></table></figure></p>
<p>因此应该确保所有的联结都有where子句。</p>
<h4 id="内部联结"><a href="#内部联结" class="headerlink" title="内部联结"></a>内部联结</h4><p>目前为止所用的联结称为等值联结，它基于两个表之间的相等测试，这种联结也成为内部联结，其实这种联结可以使用稍微不同的语法来明确指定联结的类型，下面的语句与前面的例子返回完全相同的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select vend_name, prod_name, prod_price</div><div class="line">from vendors inner join products </div><div class="line">on vendors.vend_id = products.vend_id</div><div class="line">order by vend_name, prod_name;</div></pre></td></tr></table></figure></p>
<h4 id="联结多个表"><a href="#联结多个表" class="headerlink" title="联结多个表"></a>联结多个表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">select prod_name, vend_name, prod_price, quantity</div><div class="line">from orderitems, products, vendors </div><div class="line">where products.vend_id = vendors.vend_id</div><div class="line">and orderitems.prod_id = products.prod_id</div><div class="line">and order_num = 2005;</div></pre></td></tr></table></figure>
<p>正如第14章所述，子查询并不总是执行复杂select操作的最有效的方法，下面是使用联结的相同查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">select cust_name, cust_contact</div><div class="line">from customers, orders, orderitems </div><div class="line">where customers.cust_id = order.cust_id</div><div class="line">and order.order_num = orderitems.order_num</div><div class="line">and prod_id = &apos;TNT2&apos;;</div></pre></td></tr></table></figure></p>
<h3 id="Chapter-16-创建高级联结"><a href="#Chapter-16-创建高级联结" class="headerlink" title="Chapter 16 创建高级联结"></a>Chapter 16 创建高级联结</h3><h4 id="使用表别名"><a href="#使用表别名" class="headerlink" title="使用表别名"></a>使用表别名</h4><p>SQL 的别名除了用于列名和计算字段外，SQL还允许给表名起别名，这样做主要有两个主要理由：</p>
<ol>
<li>缩短SQL语句</li>
<li>允许在单条select语句中多次使用相同的表<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">select cust_name, cust_contact</div><div class="line">from customers as c, orders as o, orderitems as oi </div><div class="line">where c.cust_id = o.cust_id</div><div class="line">and o.order_num = oi.order_num</div><div class="line">and prod_id = &apos;TNT2&apos;;</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="使用不同类型的联结"><a href="#使用不同类型的联结" class="headerlink" title="使用不同类型的联结"></a>使用不同类型的联结</h4><p>迄今为止，使用的仅是称为内部联结或等值联结的简单联结。<br>现在看其他三种联结，分别为自联结，自然联结，外部联结。<br>自联结，如前所述，使用表别名的主要原因是能在单条select语句中不止一次引用相同的表。<br>假设发现某物品id为DTNTR存在问题，想知道生产该物品的供应商的其他物品是否也存在这些问题。即在同一个表中。<br>一种解决方式是使用子查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select prod_id, prod_name </div><div class="line">from products </div><div class="line">where vend_id = (select vend_id from products where prod_id = &apos;DTNTR&apos;);</div></pre></td></tr></table></figure></p>
<p>现在看使用联结的相同查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select p1.prod_id, p1.prod_name </div><div class="line">from products as p1, products as p2 </div><div class="line">where p1.vend_id = p2.vend_id </div><div class="line">and p2.prod_id = &apos;DTNTR&apos;;</div></pre></td></tr></table></figure></p>
<p>p1.prod_id, p1.prod_name，如果不这样，MySQL将返回错误信息，因为分别存在两个名为 prod_id, prod_name 的列，MySQL 不知道想要的是哪一列，即使事实上它们是同一列。<br>自联结通常用于替代在相同表中检索数据的子查询语句，虽然最终的结果是相同的，但有时候处理联结远比处理子查询要快得多。</p>
<h5 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h5><p>无论何时对表进行联结，至少应该有一个列出现在不止一个表中，被联结的列，标准的联结，前一章中的内部联结，返回所有数据，甚至相同的列多次出现，自然联结则排除多次出现，使每个列只返回一次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">select c.*, o.order_num, o.order_date, oi.prod_id, oi.quantity, oi.item_price</div><div class="line">from customers as c, orders as o, orderitems as oi</div><div class="line">where c.cust_id = o.cust_id</div><div class="line">and o.order_num = oi.order_num</div><div class="line">and prod_id = &apos;FB&apos;;</div></pre></td></tr></table></figure></p>
<p>在这个例子中，通配符只对第一个表使用，所有其他列明确列出，所以没有重复的列被检索出来。<br>事实上，迄今为止，我们建立的每个内部联结都是自然联结，很有可能我们永远都不会用到不是自然联结的内部联结。</p>
<h5 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h5><p>检索所有客户及其订单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select customers.cust_name, orders.order_num</div><div class="line">from customers inner join orders</div><div class="line">on customers.cust_id = orders.cust_id;</div></pre></td></tr></table></figure></p>
<p>外部联结语法类似，检索所有的用户，包括那些没有订单的用户：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select customers.cust_name, orders.order_num</div><div class="line">from customers left outer join orders</div><div class="line">on customers.cust_id = orders.cust_id;</div></pre></td></tr></table></figure></p>
<p>在使用 outer join 时，必须使用right或者left指定包括其所有行的表。外部联结的类型，存在两种形式的外部联结，它们之间唯一的差别在于所关联的表的顺序不同，换句话说，左外部联结可以通过颠倒from 或者 where子句中的表的顺序转换为右外部联结。</p>
<h5 id="使用带聚集函数的联结"><a href="#使用带聚集函数的联结" class="headerlink" title="使用带聚集函数的联结"></a>使用带聚集函数的联结</h5><p>检索所有客户及其订单数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">select customers.cust_name, customers.cust_id,</div><div class="line">count(orders.order_num) as num_ord</div><div class="line">from customers inner join orders</div><div class="line">on customers.cust_id = orders.cust_id</div><div class="line">group by customers.cust_id;</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cust_name cust_id num_ord</div><div class="line">....        ....    2</div><div class="line">....        ....    1</div><div class="line">....        ....    1</div><div class="line">....        ....    1</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">select customers.cust_name, customers.cust_id,</div><div class="line">count(orders.order_num) as num_ord</div><div class="line">from customers left outer join orders</div><div class="line">on customers.cust_id = orders.cust_id</div><div class="line">group by customers.cust_id;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cust_name cust_id num_ord</div><div class="line">....        ....    2</div><div class="line">....        ....    1</div><div class="line">....        ....    0</div><div class="line">....        ....    1</div><div class="line">....        ....    1</div></pre></td></tr></table></figure></p>
<h3 id="Chapter-17-组合查询-compound-query"><a href="#Chapter-17-组合查询-compound-query" class="headerlink" title="Chapter 17 组合查询 compound query"></a>Chapter 17 组合查询 compound query</h3><p>利用 union 操作符将多条select语句组合成一个结果集。<br>组合查询和多个where条件：<br>多数情况下，组合相同表的两个查询与具有多个where条件子句的单条查询完成的工作是相同的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">select vend_id, prod_id, prod_price </div><div class="line">from products</div><div class="line">where prod_price &lt;= 5</div><div class="line">union</div><div class="line">select vend_id, prod_id, prod_price</div><div class="line">from products</div><div class="line">where vend_id in (1001, 1002);</div></pre></td></tr></table></figure></p>
<p>等于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">select vend_id, prod_id, prod_price</div><div class="line">from products</div><div class="line">where prod_price &lt;= 5</div><div class="line">or </div><div class="line">vend_id in (1001, 1002);</div></pre></td></tr></table></figure></p>
<p>union 规则：</p>
<ol>
<li>union 中的每个查询必须包含相同的列，表达式或者聚集函数（不过各个列不需要以相同的次序列出）。</li>
<li>列数据类型必须兼容，类型不必完全相同，但必须是 DBMS可以隐含地转换类型。</li>
</ol>
<h5 id="对组合查询结果进行排序"><a href="#对组合查询结果进行排序" class="headerlink" title="对组合查询结果进行排序"></a>对组合查询结果进行排序</h5><p>在 union 组合查询时，只能使用一条order by 子句，它必须出现在最后一条select语句之后。</p>
<h3 id="Chapter-18-全文本搜索"><a href="#Chapter-18-全文本搜索" class="headerlink" title="Chapter 18 全文本搜索"></a>Chapter 18 全文本搜索</h3><p>并非所有引擎都支持全文本搜索<br>MySQL 支持几种基本的数据库引擎，两个最常使用的引擎为MyISAM 和 InnoDB，前者支持全文本搜索，而后者不支持，这就是为什么这本书创建的多数样例表使用 InnoDB，而一个样例表（productnotes表）却使用MyISAM的原因。<br>like关键字和正则表达式这两个搜索机制非常有用，但是却存在几个重要的限制：</p>
<ol>
<li>性能，这两个搜索极少使用表索引，因此，随着被搜索行数不断增加，这些搜索可能会非常耗时。</li>
<li>控制不明确</li>
<li>不够智能<br>使用全文本搜索时，MySQL不要分别查看每个行，不需要分别分析处理每个词，MySQL创建指定列中各词的一个索引，搜索可以针对这些词进行，这样，MySQL可以快速有效地决定哪些词匹配（哪些行包含它们），哪些词不匹配，以及它们的匹配频率。<br>为了进行全文本搜索，必须索引被搜索的列，而且要随着数据的改动不断地重新索引，在对表列进行适当设计后，MySQL会自动进行所有索引和重新索引。<br>在索引之后，select 可与match 和 against 一起使用以实际执行搜索。<br>一般在创建表时启用全文本搜索，create table 语句接受 fulltext子句，它给出一个被索引列的一个逗号分隔的列表。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">create table productnotes (</div><div class="line">    note_id     int        not null auto_increment,</div><div class="line">    prod_id     char(10)   not null,</div><div class="line">    note_date   datetime   not null,</div><div class="line">    node_text   text       null,</div><div class="line">    primary key(note_id),</div><div class="line">    fulltext(node_text)</div><div class="line">) engine=myisam;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>进行全文本搜索<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">select node_text from productnotes where</div><div class="line">match(node_text) against(&apos;rabbit&apos;);</div></pre></td></tr></table></figure></p>
<p>有两行包含词 rabbit，这两行被返回。<br>上述的搜索可以简单的使用like子句完成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select node_text from productnotes where node_text like &apos;%rabbit%&apos;;</div></pre></td></tr></table></figure></p>
<p>两行都包含词 rabbit，但包含词 rabbit 作为第三个词的等级比作为第二十个词的等级高，全文搜索的一个重要特点就是具有较高等级的行优先返回。<br><strong>….to do</strong></p>
<h3 id="Chapter-19-插入数据"><a href="#Chapter-19-插入数据" class="headerlink" title="Chapter 19 插入数据"></a>Chapter 19 插入数据</h3><p>毫无疑问，select 是最常用的SQL语句了，但是还有其他3个经常使用的SQL语句。<br>insert 可以以几种方式使用：</p>
<ul>
<li>插入完整的行</li>
<li>插入行的一部分</li>
<li>插入多行</li>
<li>插入某些查询结果</li>
</ul>
<p><strong>插入及系统安全：可针对每个表或每个用户，利用MySQL的安全机制禁止使用insert语句</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">insert into customers</div><div class="line">values (</div><div class="line">    null, </div><div class="line">    &apos;Pep E. LaPaw&apos;,</div><div class="line">    &apos;100 Main Street&apos;,</div><div class="line">    &apos;Los Angeles&apos;,</div><div class="line">    &apos;CA&apos;,</div><div class="line">    &apos;90046&apos;,</div><div class="line">    &apos;USA&apos;,</div><div class="line">    NULL,</div><div class="line">    NULL</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>依序，第一列 cust_id 为 null，是因为这列是由MySQL自动增量的。<br>这种语法很简单，但并不安全，高度依赖于表中列的定义次序，不能保证表结构变动后各个列保持完全相同的次序。更加安全也更加繁琐的方式是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">insert into customers (</div><div class="line">    cust_name,</div><div class="line">    cust_address,</div><div class="line">    cust_city,</div><div class="line">    cust_state,</div><div class="line">    cust_zip,</div><div class="line">    cust_county,</div><div class="line">    cust_contact,</div><div class="line">    cust_email</div><div class="line">    )</div><div class="line">    values (</div><div class="line">    &apos;Pep E. LaPaw&apos;,</div><div class="line">    &apos;100 Main Street&apos;,</div><div class="line">    &apos;Los Angeles&apos;,</div><div class="line">    &apos;CA&apos;,</div><div class="line">    &apos;90046&apos;,</div><div class="line">    &apos;USA&apos;,</div><div class="line">    NULL,</div><div class="line">    NULL</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>省略的列：</p>
<ol>
<li>NULL</li>
<li>default value<br>否则就会产生一条错误信息，并相应的行插入不成功。<br>提高整体性能：<br>insert 操作可能很耗时，特别是有很多索引需要更新时，而它可能降低等待处理的select语句的性能。<br>如果数据检索是重要的，通常如此，则你需要通过在insert 和into 之间添加关键字low_priority，指示MySQL降低insert语句的优先级。这也适用于 update 和 delete语句。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">insert into customers (...)</div><div class="line">values (...), (...);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>此技术可以提高数据库处理的性能，因为MySQL用单条insert语句处理多个插入比使用多条insert语句要快。</p>
<h4 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h4><p>将一条select语句的结果插入表中，这就是所谓的insert select。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">insert into customers (...)</div><div class="line">select ... from custnew;</div></pre></td></tr></table></figure></p>
<p>Insert select 列名不一定匹配，MySQL使用的是其位置。</p>
<h3 id="Chapter-20-更新和删除数据"><a href="#Chapter-20-更新和删除数据" class="headerlink" title="Chapter 20 更新和删除数据"></a>Chapter 20 更新和删除数据</h3><p>update 有两种使用方式：</p>
<ol>
<li>更新表中特定行</li>
<li>更新表中所有行<br><strong>一定要用where子句</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">update customers</div><div class="line">set cust_email = &apos;elmer@fudd.com&apos;, cust_name = &apos;The Fudds&apos;</div><div class="line">where cust_id = 10005;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在update中可以使用子查询，使得能用select语句检索出的数据更新数据。<br>ignore 关键字，在使用 update 更新多行时，如果其中的一行或者多行出现一个错误，则整个update操作被取消，错误发生前更新的所有行将恢复到其原有的值，为了即使发生错误，也能继续进行更新，可用ignore关键字。<br>update ignore customers…<br>delete 有两种使用方式：</p>
<ol>
<li>删除表中特定行</li>
<li>删除表中所有行<br><strong>一定要用where子句</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">delete from customers where cust_id = 10006;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>删除的是内容而不是表，即便是删除了表中所有的行。<br>更快的删除<br>如果想从表中删除所有行，不要使用delete，可以使用truncate table，它完成相同的工作，但是速度更快，它实际上是删除了原来的表并重新创建了一个表，而不是逐行删除表中的数据。<br>更新和删除的指导原则</p>
<ol>
<li>在对update 或delete语句使用where子句前，首先使用select进行测试，保证其过滤的是正确的记录，以免编写的where子句不正确。</li>
<li>使用强制实施引用完整性的数据库，这样MySQL不允许删除与其他表相关联的数据行。</li>
</ol>
<h3 id="Chapter-21-创建和操纵表"><a href="#Chapter-21-创建和操纵表" class="headerlink" title="Chapter 21 创建和操纵表"></a>Chapter 21 创建和操纵表</h3><p>迄今为止，我们看到的都是以单个列作为主键，为创建由多个列组成的主键，应该以逗号分隔的列表给出各列名，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">create table orderitems (</div><div class="line">    order_num    int           not null,</div><div class="line">    order_item   int           not null,</div><div class="line">    prod_id      char(10)      not null,</div><div class="line">    quantity     int           not null,</div><div class="line">    item_price   decimal(8, 2) not null,</div><div class="line">    primary key (order_num, order_item)</div><div class="line">) engine=innodb;</div></pre></td></tr></table></figure></p>
<ul>
<li>主键唯一标识表中的一行</li>
<li>外键是表中的一列，唯一标识另外一个表中的一行。</li>
</ul>
<p>每个表只允许一个 auto_increment 列，而且它必须被索引（如，通过使它成为主键）。<br>覆盖 auto_increment，如果一个列被指定为 auto_increment，你可以简单地在insert语句中指定一个值，只要它是唯一的(至今尚未使用过)即可，该值将被用来代替自动生成的值，后续的增量将开始使用该手工插入的值。<br><code>select last_insert_id()</code> 返回最后一个 auto_increment 值。<br>指定默认值 <code>quantity int not null default 1</code>，与大多数DBMS不一样，MySQL不允许使用函数作为默认值，它只支持常量。</p>
<h4 id="引擎类型"><a href="#引擎类型" class="headerlink" title="引擎类型"></a>引擎类型</h4><p>具体管理和处理数据的内部引擎。</p>
<ul>
<li>InnoDB 是一个可靠的事务处理引擎，但它不支持全文本搜索。</li>
<li>Memory 功能等同于 MyISAM，但是数据存储在内存，而不是磁盘中，速度很快，特别适合于临时表。</li>
<li>MyISAM 是一个性能极高的引擎，不支持事务处理，但是支持全文本搜索。</li>
</ul>
<p>在同一个数据库中引擎可以混用，一个表用 MyISAM，另一个表用 InnoDB。<br>外键不能跨引擎。</p>
<h4 id="alter-表"><a href="#alter-表" class="headerlink" title="alter 表"></a>alter 表</h4><p>alter table，但是理想状态下，当表中存储数据后，该表就不应该被alter，在表的设计过程中需要花费大量的时间来考虑，以便后期不对该表进行大的变动。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">alter table vendors</div><div class="line">add vend_phone char(20);</div><div class="line"></div><div class="line">alter table vendors</div><div class="line">drop column vend_phone;</div></pre></td></tr></table></figure></p>
<p>alter table 的一个常见用途是定义外键：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alter table orderitems</div><div class="line">add constraint fk_orderitems_orders</div><div class="line">foreign key (order_num) references orders (order_num);</div></pre></td></tr></table></figure></p>
<p>小心使用alter table，数据表的更改不能撤销，如果增加了不需要的列，可能不能删除它们，类似地，如果删除了不应该删除的列，可能会丢失该列中的所有数据。<br>删除表 <code>drop table customers2;</code><br>重命名表 <code>rename table customers2 to customers;</code></p>
<h3 id="Chapter-22-使用视图"><a href="#Chapter-22-使用视图" class="headerlink" title="Chapter 22 使用视图"></a>Chapter 22 使用视图</h3><p>视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">select cust_name, cust_contact</div><div class="line">from customers, orders, orderitems </div><div class="line">where customers.cust_id = order.cust_id</div><div class="line">and order.order_num = orderitems.order_num</div><div class="line">and prod_id = &apos;TNT2&apos;;</div></pre></td></tr></table></figure></p>
<p>此查询用来检索订购了某个特定产品的客户，任何需要这个数据的人都必须理解相关表的结构，并知道如何创建查询和对表进行联结，为了检索其他的产品或者多个产品的相同数据，必须修改最后的where子句。<br>现在，假如可以把整个查询包装成为一个 productcustomers 的虚拟表，则可以轻松地检索出相同的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select cust_name, cust_contact from</div><div class="line">productcustomers</div><div class="line">where prod_id = &apos;TNT2&apos;;</div></pre></td></tr></table></figure></p>
<p>productcustomers 是一个视图，作为视图，它不包含表中应该有的任何列或者数据，它包含的是一个SQL 查询。</p>
<h4 id="视图用处"><a href="#视图用处" class="headerlink" title="视图用处"></a>视图用处</h4><ul>
<li>重用 SQL 语句</li>
<li>简化复杂的 SQL 操作</li>
<li>使用表的组成部分而不是整个表</li>
<li>保护数据，可以给用户授予表的特定部分的访问权限而不是整个表的访问权限</li>
<li>更改数据格式和表示，视图可返回与底层表的数据格式和表示不同的数据</li>
</ul>
<p>在视图创建之后，可以用与表基本相同的方式利用它们，可以对视图执行select操作，过滤和排序数据，将视图联结到其他视图或者表，甚至能添加和更新数据（添加和更新数据存在某些限制），重要的是，在添加或者更改表中的数据时，视图将立即进行反映。<br>视图的规则和限制：</p>
<ol>
<li>视图可以嵌套</li>
<li>order by 可以用在视图中，但如果从该视图检索数据的select 中也包含order by，那么该视图的order by 将被覆盖。</li>
<li>视图不能索引，也不能有关联的触发器或者默认值</li>
<li>为创建视图，必须有足够的访问权限，这些限制通常由数据库管理人员授予。</li>
<li>视图可以和表一起使用，例如编写一条联结表和视图的select语句。</li>
</ol>
<p>使用视图：</p>
<ol>
<li>视图用 create view 语句来创建</li>
<li>使用 show create view viewname;来查看创建视图的语句。</li>
<li>drop view viewname;</li>
<li>更新视图时，可以先用drop再用create，也可以直接用create or replace view。</li>
</ol>
<h4 id="利用视图简化复杂的联结"><a href="#利用视图简化复杂的联结" class="headerlink" title="利用视图简化复杂的联结"></a>利用视图简化复杂的联结</h4><p>视图的最常用的应用之一是隐藏复杂的SQL，这通常会涉及到联结。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ceate view productcustomers as </div><div class="line">select cust_name, cust_contact, prod_id</div><div class="line">from customers, orders, orderitems</div><div class="line">where customers.cust_id = orders.cust_id</div><div class="line">and orders.order_num = orderitems.order_num;</div><div class="line"></div><div class="line">select cust_name, cust_contact </div><div class="line">from productcustomers</div><div class="line">where prod_id = &apos;TNT2&apos;;</div></pre></td></tr></table></figure></p>
<h4 id="利用视图重新格式化检索出的数据"><a href="#利用视图重新格式化检索出的数据" class="headerlink" title="利用视图重新格式化检索出的数据"></a>利用视图重新格式化检索出的数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select concat(rtrim(vend_name), &apos; (&apos;, rtrim(vend_county), &apos;)&apos;) as vend_title</div><div class="line">from vendors</div><div class="line">order by vend_name;</div></pre></td></tr></table></figure>
<p>现在假设经常需要这个格式的结果，创建视图，重用 SQL 语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">create view vendorlocations as</div><div class="line">select concat(rtrim(vend_name), &apos; (&apos;, rtrim(vend_county), &apos;)&apos;) as vend_title</div><div class="line">from vendors</div><div class="line">order by vend_name;</div></pre></td></tr></table></figure></p>
<p>这样就可以在应用中使用 <code>select * from vendorlocations;</code>进行数据检索了，重用了SQL语句，简化了应用中的SQL语句，并且没有造成数据的重复。</p>
<h4 id="用视图过滤不想要的数据"><a href="#用视图过滤不想要的数据" class="headerlink" title="用视图过滤不想要的数据"></a>用视图过滤不想要的数据</h4><p>可以定义 customeremaillist 视图，它过滤了没有电子邮件地址的用户。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">create view customeremaillist as </div><div class="line">select cust_id, cust_name, cust_email</div><div class="line">from customers</div><div class="line">where cust_email is not null;</div></pre></td></tr></table></figure></p>
<p>此时可以在应用中通过<code>select * from customeremaillist;</code>进行检索了。</p>
<h4 id="使用视图与计算字段"><a href="#使用视图与计算字段" class="headerlink" title="使用视图与计算字段"></a>使用视图与计算字段</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">create view orderitemsexpanded as </div><div class="line">select order_num, prod_id, quantity, item_price quantity*item_price as expanded_price</div><div class="line">from orderitems;</div></pre></td></tr></table></figure>
<h4 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h4><p>视图是可更新的，即可以对其使用insert，update，delete，更新一个视图将更新其基表，可以回忆一下，视图本身并没数据，如果对视图增加或者删除行，实际上是对其基表增加或者删除行。<br>但是并非所有的视图都是可更新的，基本上说，如果MySQL不能正确地确定被更新的基数据，则不允许更新，这实际上是说，如果视图中定义有如下的操作，则不能进行视图的更新：</p>
<ol>
<li>分组 （使用 group by 和 having）</li>
<li>联结</li>
<li>子查询</li>
<li>并</li>
<li>聚集函数（min，max， count， sum等）</li>
<li>distinct</li>
<li>导出（计算）列</li>
</ol>
<h3 id="Chapter-23-使用存储过程"><a href="#Chapter-23-使用存储过程" class="headerlink" title="Chapter 23 使用存储过程"></a>Chapter 23 使用存储过程</h3><p>迄今为止，使用的大多数SQL语句都是针对一个或者多个表的<strong>单条语句</strong>，但是并非所有的操作都这么简单，经常会有一个完整的操作需要多条语句才能完成。<br>那么如何编写此代码？可以单独编写每条语句，并根据结果有条件地执行另外的语句。在每次需要这个处理时，重复一遍如此的操作即可。<br>可以创建存储过程，存储过程简单来说，就为以后使用而保存地一条或者多条MySQL语句的集合，可将其视为批处理文件。</p>
<h4 id="为什么要使用存储过程？"><a href="#为什么要使用存储过程？" class="headerlink" title="为什么要使用存储过程？"></a>为什么要使用存储过程？</h4><ol>
<li>把处理封装在容易使用的单元中</li>
<li>不需要反复建立一系列处理步骤，让所有开发人员和应用程序都使用同一存储过程的相同代码，防止错误，鲁棒性。</li>
<li>简化对变动的管理，如果表名、列名或者业务逻辑有变动，只需要更改存储过程的代码，使用的它人员甚至对于变动都没有察觉，增加安全性。</li>
<li>提高性能，因为使用存储过程要比使用单独的SQL语句要快。<br>简单来说就是三点，简单，鲁棒，安全，高性能。<br>不过将SQL语句转换为存储过程前，也必须知道其缺陷：</li>
<li>编写存储过程比基本的SQL语句复杂</li>
<li>可能没有创建存储过程的安全访问权限，很多数据库管理人员允许用户使用存储过程，但是不允许他们创建存储过程。</li>
</ol>
<h4 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h4><p>存储过程的执行称之为调用，call 接受存储过程的名字以及需要传递给它的任意参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">call productpricing(</div><div class="line">    @pricelow,</div><div class="line">    @pricehigh,</div><div class="line">    @priceaverage</div><div class="line">    );</div></pre></td></tr></table></figure></p>
<h4 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">create procedure productpricing()</div><div class="line">begin</div><div class="line">    select avg(prod_price) as priceaverage</div><div class="line">    from products;</div><div class="line">end;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">call productpricing();</div><div class="line">priceaverage</div><div class="line">16.133571</div></pre></td></tr></table></figure>
<h4 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h4><p>存储过程被创建之后，被保存在服务器上以供使用，直至被删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">drop procedure productpricing;</div></pre></td></tr></table></figure></p>
<h4 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h4><p>productpricing 只是一个简单的存储过程，它简单地显示select语句的结果，一般，存储过程并不显示结果，而是把结果返回给你指定的变量。<br><strong>变量内存中的一个特定位置，用来临时存储数据</strong><br>以下是 productpricing 的修改版本，如果不先删除此存储过程，则不能再次创建它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">create procedure productpricing (</div><div class="line">    out pl decimal(8, 2),</div><div class="line">    out ph decimal(8, 2),</div><div class="line">    out pa decimal(8, 2)</div><div class="line">)</div><div class="line">begin</div><div class="line">    select min(prod_price)</div><div class="line">    into pl</div><div class="line">    from products;</div><div class="line">    select max(prod_price)</div><div class="line">    into ph</div><div class="line">    from products;</div><div class="line">    select avg(prod_price)</div><div class="line">    into pa</div><div class="line">    from products;</div><div class="line">end;</div></pre></td></tr></table></figure></p>
<p>关键字 out 指出相应的参数用来从存储过程传出一个值（返回给调用者），MySQL 支持IN（传递给存储过程）、out（从存储过程传出）和inout（对存储过程传入和传出）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">call productpricing(</div><div class="line">    @pricelow,</div><div class="line">    @pricehigh,</div><div class="line">    @priceaverage</div><div class="line">    );</div></pre></td></tr></table></figure></p>
<p>由于此存储过程要求3个参数，因此必须正好传递3个参数，不多也不少，所以，这条call语句给出3个参数，存储过程将把结果保存进这三个变量中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select @priceaverage;</div><div class="line">@priceaverage</div><div class="line">16.133571428</div></pre></td></tr></table></figure></p>
<p>下面是一个使用in和out参数的例子，ordertotal 接受订单号并返回该订单的合计：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">create procedure ordertotal (</div><div class="line">    in onumber int,</div><div class="line">    out ototal decimal(8, 2)</div><div class="line">)</div><div class="line">begin</div><div class="line">    select sum(item_price*quantity)</div><div class="line">    from orderitems</div><div class="line">    where order_num = onumber</div><div class="line">    into ototal;</div><div class="line">end;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">call ordertotal(20005, @total);</div><div class="line">select @total;</div><div class="line">@total</div><div class="line">149.87</div></pre></td></tr></table></figure>
<h3 id="Chapter-24-使用游标"><a href="#Chapter-24-使用游标" class="headerlink" title="Chapter 24 使用游标"></a>Chapter 24 使用游标</h3><p>有时，需要在检索出来的行中前进或者后退一行或者多行，这就是使用游标的原因，cursor 是一个存储在MySQL服务器上的数据库查询，它不是一条select语句，而是被该语句检索出来的数据集，在得到了游标之后，应用程序可以根据需要滚动或者浏览其中的数据。游标主要应用于交互式应用，其中用户可以滚动数据并对数据进行浏览或者做出更改。<br>不像多数DBMS，MySQL游标只能用于存储过程和函数。</p>
<h4 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h4><ol>
<li>在能够使用游标前，必须定义它，这个过程实际上并没有检索数据，它只是定义要使用的select语句。</li>
<li>一旦定义之后，必须打开游标以供使用，这个过程用前面定义的select语句把实际数据检索出来了</li>
<li>对于填有数据的游标，根据需要取出各行</li>
<li>在结束游标使用之后，必须关闭游标。<br>在定义游标之后，可以按需频繁的打开和关闭游标，在游标打开之后，可按需频繁地执行取操作。</li>
</ol>
<h4 id="创建游标"><a href="#创建游标" class="headerlink" title="创建游标"></a>创建游标</h4><p>游标用declare 语句创建，并定义相应地select语句，根据需要带where和其他子句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">create procedure processorders()</div><div class="line">begin</div><div class="line">    declare ordernumbers cursor</div><div class="line">    for</div><div class="line">    select order_num from orders;</div><div class="line">end;</div></pre></td></tr></table></figure></p>
<h4 id="打开和关闭游标"><a href="#打开和关闭游标" class="headerlink" title="打开和关闭游标"></a>打开和关闭游标</h4><p>在处理open语句时执行查询，临时存储检索出的数据以供浏览和滚动。<br><code>open ordernumbers;</code><br>close 释放游标所使用的所有内部内存和资源，因此每个游标在不再需要时就应该关闭。<br><code>close ordernumbers;</code><br><strong>隐含关闭</strong>： 如果你不明确关闭游标，MySQL 将会在到达end语句时自动关闭它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">create procedure processorders()</div><div class="line">begin</div><div class="line">    -- declare the cursor</div><div class="line">    declare ordernumbers cursor</div><div class="line">    for</div><div class="line">    select order_num from orders;</div><div class="line"></div><div class="line">    -- open the cursor</div><div class="line">    open ordernumbers;</div><div class="line"></div><div class="line">    -- close the cursor</div><div class="line">    close ordernumbers;</div><div class="line">end;</div></pre></td></tr></table></figure></p>
<p>这个存储过程定义，打开和关闭了一个游标，但是对于检索出来的数据什么处理也没有做。</p>
<h4 id="使用游标数据"><a href="#使用游标数据" class="headerlink" title="使用游标数据"></a>使用游标数据</h4><p>在一个游标被打开之后，可以使用fetch语句分别访问它的每一行，fetch 指定检索什么数据（所需的列），检索出来的数据存储在什么地方，它还向前移动游标中的内部指针，使得下一条fetch语句检索的是下一行而不是同一行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">create procedure processorders()</div><div class="line">begin</div><div class="line">    -- declare local variable</div><div class="line">    declare o int;</div><div class="line"></div><div class="line">    -- declare the cursor</div><div class="line">    declare ordernumbers cursor</div><div class="line">    for</div><div class="line">    select order_num from orders;</div><div class="line"></div><div class="line">    -- open the cursor</div><div class="line">    open ordernumbers;</div><div class="line"></div><div class="line">    -- get order number</div><div class="line">    fetch ordernumbers into o;</div><div class="line">    </div><div class="line">    -- close the cursor</div><div class="line">    close ordernumbers;</div><div class="line">end;</div></pre></td></tr></table></figure></p>
<p>fetch 检索当前行的 order_num 列（自动从第一行开始）到一个名为 o 的局部变量中，对检索出的数据不做任何处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">create procedure processorders()</div><div class="line">begin</div><div class="line">    -- declare local variable</div><div class="line">    declare done boolean default 0;</div><div class="line">    declare o int;</div><div class="line"></div><div class="line">    -- declare the cursor</div><div class="line">    declare ordernumbers cursor</div><div class="line">    for</div><div class="line">    select order_num from orders;</div><div class="line"></div><div class="line">    -- declare continue handler</div><div class="line">    declare continue handler for sqlstate &apos;02000&apos; set done = 1;</div><div class="line"></div><div class="line">    -- open the cursor</div><div class="line">    open ordernumbers;</div><div class="line"></div><div class="line">    -- loop through all rows</div><div class="line">    repeat</div><div class="line"></div><div class="line">        -- get order number</div><div class="line">        fetch ordernumbers into o;</div><div class="line"></div><div class="line">    -- end of loop</div><div class="line">    until done end repeat;</div><div class="line"></div><div class="line">    -- close the cursor</div><div class="line">    close ordernumbers;</div><div class="line">end;</div></pre></td></tr></table></figure></p>
<p><code>declare continue handler for sqlstate &#39;02000&#39; set done = 1;</code>这条语句定义了一个 continue handler，它是在条件出现时被执行的代码，这里，它指出当 SQLSTATE 为 ‘02000’ 条件出现时，set done = 1。SQLSTATE ‘02000’ 是一个未找到条件，当 repeat 由于没有更多的行供循环时，就会出现这个条件。</p>
<p><strong>declare 语句的次序</strong>：declare 语句的发布存在特定的次序，用declare 语句定义的局部变量必须在定义在任意游标或句柄之前，而句柄必须定义在游标之后，不遵守此顺序将产生错误信息。<br>进一步修改的版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">create procedure processorders()</div><div class="line">begin</div><div class="line">    -- declare local variable</div><div class="line">    declare done boolean default 0;</div><div class="line">    declare o int;</div><div class="line">    declare t decimal(8, 2);</div><div class="line"></div><div class="line">    -- declare the cursor</div><div class="line">    declare ordernumbers cursor</div><div class="line">    for</div><div class="line">    select order_num from orders;</div><div class="line"></div><div class="line">    -- declare continue handler</div><div class="line">    declare continue handler for sqlstate &apos;02000&apos; set done = 1;</div><div class="line"></div><div class="line">    -- create a table to store the results</div><div class="line">    create table if not exists ordertotals (</div><div class="line">        order_num   int,</div><div class="line">        total       decimal(8, 2)</div><div class="line">    );</div><div class="line"></div><div class="line">    -- open the cursor</div><div class="line">    open ordernumbers;</div><div class="line"></div><div class="line">    -- loop through all rows</div><div class="line">    repeat</div><div class="line"></div><div class="line">        -- get order number</div><div class="line">        fetch ordernumbers into o;</div><div class="line"></div><div class="line">        -- get the total for this order </div><div class="line">        call ordertotal(o, t);</div><div class="line"></div><div class="line">        -- insert order and total into ordertotals</div><div class="line">        insert into ordertotals (order_num, total)</div><div class="line">        values (o, t);</div><div class="line"></div><div class="line">    -- end of loop</div><div class="line">    until done end repeat;</div><div class="line"></div><div class="line">    -- close the cursor</div><div class="line">    close ordernumbers;</div><div class="line">end;</div></pre></td></tr></table></figure></p>
<p>此存储过程不返回数据，但它能够创建和填充另一个表，可以查看该表：<br><code>select * from ordertotals;</code>。</p>
<h3 id="Chapter-25-使用触发器"><a href="#Chapter-25-使用触发器" class="headerlink" title="Chapter 25 使用触发器"></a>Chapter 25 使用触发器</h3><p>需要某条语句或者某些语句在事件发生时自动执行。<br>比如：</p>
<ul>
<li>每当增加一个顾客到某个数据库表时，都检查其电话号码格式是否正确，州的缩写是否大写；</li>
<li>每当订购一个产品时，都从库存数量中减去订购的数量</li>
<li>无论何时删除一行，都在某个存档表中保留一个副本</li>
</ul>
<p>所有的这些例子共同之处就是它们都需要在某个表发生变动时自动处理，触发器是MySQL响应以下任意语句时而自动执行的一条MySQL语句（或位于begin和end之间的一组语句）：</p>
<ul>
<li>update</li>
<li>insert</li>
<li>delete<br>其他语句不触发触发器。</li>
</ul>
<h4 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h4><ol>
<li>唯一的触发器名</li>
<li>触发器关联的表</li>
<li>触发器应该响应的活动（update insert delete）</li>
<li>触发器何时执行（处理之前或者处理之后）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">create trigger newproduct after insert on products</div><div class="line">for each row select &apos;Product added&apos;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>文本 Product added 将对每个插入的行显示一次。<br><strong>只有表才支持触发器，视图不支持，临时表也不支持。</strong><br>触发器按每个表每个事件每次地定义，每个表每个事件只允许一个触发器，每个表最多支持6个触发器，每条insert，update，delete的之前和之后，单一触发器不能与多个事件或者多个表关联，所以如果你需要一个对insert和update操作都触发的触发器，则应该定义两个触发器。<br><strong>触发器失败</strong>：如果before触发器失败，则mysql将不执行请求的操作，此外如果before触发器或者语句本身失败，MySQL将不执行after触发器。</p>
<h4 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">drop trigger newproduct;</div></pre></td></tr></table></figure>
<p>触发器不能更改或者覆盖，为了修改一个触发器，必须先删除它，然后再重新创建。</p>
<h4 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h4><h5 id="insert-触发器："><a href="#insert-触发器：" class="headerlink" title="insert 触发器："></a>insert 触发器：</h5><ol>
<li>在insert触发器代码内部可以引用一个名为NEW的虚拟表，访问被插入的行</li>
<li>在before insert触发器中，NEW中的值也可以被更新（允许更改被插入的值）</li>
<li>对于 auto_increment 列，new 在insert执行之前是0，在insert执行之后包含新的自动生成值。<br>比<code>select last_insert_id();</code>更好的方法是<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">create trigger neworder after insert on orders</div><div class="line">for each row select new.order_num;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>为了测试这个触发器<br><code>insert into orders (order_date, cust_id) values (now(), 10001);</code><br>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">order_num</div><div class="line">20010</div></pre></td></tr></table></figure></p>
<p><strong>before or after</strong>: 通常将before用于数据验证和净化，目的是保证插入表中的数据确实是需要的数据。</p>
<h5 id="delete触发器"><a href="#delete触发器" class="headerlink" title="delete触发器"></a>delete触发器</h5><p>在delete触发器代码内部，可以引用一个名为old的虚拟表，访问被删除的行。</p>
<h3 id="Chapter-26-管理事务处理"><a href="#Chapter-26-管理事务处理" class="headerlink" title="Chapter 26 管理事务处理"></a>Chapter 26 管理事务处理</h3><p>并不是所有的引擎都支持事务处理<br>transaction processing 可以用于维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。<br>几个常用的术语：</p>
<ol>
<li>事务 transaction 指一组SQL语句</li>
<li>回退 rollback 指撤销指定SQL语句的过程</li>
<li>提高 commit 指将未存储的SQL语句结果写入数据库表</li>
<li>保留点 savepoint 指事务处理中设置的临时占位符，你可以对它发布回退（与回退整个事务处理不同）</li>
</ol>
<h4 id="控制事务处理"><a href="#控制事务处理" class="headerlink" title="控制事务处理"></a>控制事务处理</h4><p>管理事务处理的关键在于将SQL语句组分解为逻辑块，并明确规定数据何时应该回退，何时不应该回退。<br>用<code>start transaction</code>标识事务的开始</p>
<h6 id="使用rollback-来回退MySQL语句"><a href="#使用rollback-来回退MySQL语句" class="headerlink" title="使用rollback 来回退MySQL语句"></a>使用rollback 来回退MySQL语句</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">select * from ordertotals;</div><div class="line">start transaction;</div><div class="line">delete from ordertotals;</div><div class="line">select * from ordertotals;</div><div class="line">rollback;</div><div class="line">select * from ordertotals;</div></pre></td></tr></table></figure>
<p>哪些语句可以回退？<br>事务处理用来管理insert，update，delete语句，不能回退create或者drop操作，事务处理块中可以使用这两条语句，但是如果你执行回退，它们不会被撤销。</p>
<h6 id="使用-commit"><a href="#使用-commit" class="headerlink" title="使用 commit"></a>使用 commit</h6><p>一般的MySQL语句都是直接针对数据库表执行和编写的，这就是所谓的隐含提交（implicit commit），即提交操作是自动进行的。<br>但是，在事务处理块中，提交不会隐含地进行，为明确地进行提交，使用commit语句，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">start transaction;</div><div class="line">delete from orderitems where order_num = 20010;</div><div class="line">delete from orders where order_num = 20010;</div><div class="line">commit;</div></pre></td></tr></table></figure></p>
<p>在这个例子中，从系统中完全删除订单20010，因为涉及到更新两个数据库表，所以使用事务处理块来保证订单不会被部分删除。最后地commit仅在不出错时写出更改，如果第一条delete起作用，但第二条语句失败，则delete会被撤销。<br>当commit或者rollback之后，事务会自动隐含关闭。</p>
<h5 id="使用保留点"><a href="#使用保留点" class="headerlink" title="使用保留点"></a>使用保留点</h5><p>简单的 rollback 和 commit 语句就可以写入或者撤销整个事务处理，但是更复杂的事务处理可能需要部分提交或者部分回退。<br>为了支持回退部分事务处理，必须在事务处理块中的合适位置放置占位符，这样，如果需要回退，可以回退到某个占位符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">savepoint delete1;</div><div class="line">....</div><div class="line">rollback to delete1;</div></pre></td></tr></table></figure></p>
<p>savepoint 越多越好。<br>保留点在事务处理完成（执行一条rollback或者commit）后自动释放，也可以使用release savepoint 来显式地释放保留点。<br>更改默认的提交行为，默认的MySQL行为是自动提交所有更改，为了指示MySQL不自动提交更改，需要使用以下语句<br><code>set autocommit = 0;</code><br>autocommit 标志是针对每个连接而不是服务器的。</p>
<h3 id="Chapter-28-安全管理"><a href="#Chapter-28-安全管理" class="headerlink" title="Chapter 28 安全管理"></a>Chapter 28 安全管理</h3><p>访问控制，MySQL服务器的安全基础是：用户对于他们需要的数据具有适当的访问权，既不能多也不能少。<br>不要使用root，应该严肃对待root登陆的使用，仅在绝对需要时使用它，或许在你不能登陆其他管理账号时使用，不应该在日常的MySQL操作中使用root。<br>MySQL 用户账号和信息存储在名为mysql的MySQL数据库中，一般不需要直接访问mysql数据库和表，但是有时需要直接访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use mysql;</div><div class="line">select user from user;</div></pre></td></tr></table></figure></p>
<h5 id="创建用户账号"><a href="#创建用户账号" class="headerlink" title="创建用户账号"></a>创建用户账号</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">create user ben identified by &apos;opop&apos;;</div></pre></td></tr></table></figure>
<p>使用 grant 或者 insert 也可以创建用户账号。但是为了安全起见，不建议直接对user表进行插入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rename user ben to bforta;</div><div class="line">...</div><div class="line">drop user bforta;</div></pre></td></tr></table></figure></p>
<p>MySQL 5 之前：自MySQL 5 以来，drop user 删除用户账号和所有相关的账号权限，在MySQL 5以前，drop user 只能用于删除用户账户，不能删除相关的权限，因此如果使用旧版本的MySQL，需要先revoke删除与账号相关的权限，然后再使用 drop user 删除账号。</p>
<h4 id="设置访问权限"><a href="#设置访问权限" class="headerlink" title="设置访问权限"></a>设置访问权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">show grants for bforta;</div><div class="line"></div><div class="line">Grants for bforta@%</div><div class="line">GRANT USAGE ON *.* TO &apos;bforta&apos;@&apos;%&apos;</div></pre></td></tr></table></figure>
<p>USAGE 表示根本没有任何权限，此结果表示在任意数据库和任意表上对任何东西都没有权限。<br>为了设置权限，使用grant语句，grant要求你至少给出以下信息：</p>
<ul>
<li>要授予的权限</li>
<li>被授予访问权限的数据库或表</li>
<li>用户名<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grant select on crashcourse.* to bforta;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>用户 bforta 对于 crashcourse 数据库中的所有数据具有只读访问权限。<br><code>show grants for bforta;</code>反映了这个更改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Grants for bforta@%</div><div class="line">GRANT USAGE ON *.* TO &apos;bforta&apos;@&apos;%&apos;</div><div class="line">GRANT SELECT ON &apos;crashcourse&apos;.* TO &apos;bforta&apos;@&apos;%&apos;</div></pre></td></tr></table></figure></p>
<p>grant 的反操作为 revoke，用它来撤销特定的权限，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">revoke select on crashcourse.* from bforta;</div></pre></td></tr></table></figure></p>
<p>被撤销的访问权限必须存在，否则就会出错。<br>grant 和 revoke 可在几个层次上控制访问权限：</p>
<ul>
<li>整个服务器，grant all 和 revoke all</li>
<li>整个数据库，使用 on database.*</li>
<li>特定的表，使用 on database.table</li>
<li>特定的列</li>
<li>特定的存储过程</li>
</ul>
<h3 id="Chapter-30-改善性能"><a href="#Chapter-30-改善性能" class="headerlink" title="Chapter 30 改善性能"></a>Chapter 30 改善性能</h3><p><strong>数据库管理员把他们生命中的相当一部分时间花在了调整、试验以及改善DBMS性能之上</strong>。在诊断应用的滞缓现象和性能问题时，性能不良的数据库以及数据库查询通常是最常见的祸因。</p>
<ul>
<li>调整内存分配，缓冲区大小，为了查看当前设置，可使用show variable;和show status;。</li>
<li>MySQL 是一个多用户多线程的DBMS，换言之，它经常同时执行多个任务，如果这些任务中的某一个执行缓慢，则所有请求都会执行缓慢，使用 show processlist; 显示所有活动进程以及它们的线程ID和执行时间，还可以使用kill命令终结某个特定的进程。</li>
<li>总是有不止一种方法编写同一条select语句，应该试验join，union，子查询等，找出最佳的方法。</li>
<li>使用explain 语句让MySQL 解释它将如何执行一条select语句</li>
<li>一般而言，存储过程执行得比逐条要快</li>
<li>应该总是使用正确的数据类型</li>
<li>绝不要检索比需求还要多的数据</li>
<li>有的操作（包括insert）支持一个可选的delayed关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。</li>
<li>在导入数据时，应该关闭自动提交，可以删除索引，包括fulltext索引，然后在导入完成后再重建它们。</li>
<li>必须索引数据库表以改善数据检索的性能确认索引挺难的，需要分析实用的select语句以找出重复的where和order by 子句，如果一个简单的where子句返回结果所需的时间太长，则可以判定其中使用的列或者几列就是需要索引的对象。</li>
<li>你的select 语句中有一系列复杂的or条件吗？通过使用多条select语句和连接它们的union语句，你能看到极大的性能提升。</li>
<li>索引可以改善数据检索的性能，但是损害数据插入、删除和更新的性能，如果一些表收集数据且不被经常检索，可以无需索引，索引可以按需添加和删除</li>
<li>like 很慢，一般来说，使用 fulltext 而不是 like。</li>
</ul>

    </div>

    

    

    <!-- Comments -->
    

</div>
        </section>

    </div>
</div>


</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This is Robert Lexis (FengCun Li). To see the world, things dangerous to come to, to see behind walls, to draw closer, to find each other and to feel. That is the purpose of LIFE.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2018/09/03/Optimizers/">Optimizers</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/28/Tensorflow-模型浮点数计算量和参数量统计/">TensorFlow 模型浮点数计算量和参数量统计</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/26/YOLO/">YOLO</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/26/非最大值抑制/">非最大值抑制</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/RobertLexis">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:robert_lexis@163.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Robert Lexis Loves Wenny
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>