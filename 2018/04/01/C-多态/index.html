<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="C++多态的实现？多态性可以简单地概括为“一个接口，多种实现”，程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。C++多态性是通过虚函数来实现的，重写虚函数。多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译时就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。最常见的用法就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同类型而调用不同的方法。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是一定的，而固定的地址将始终调用到同一个函数，这就无法实现一个接口，多种实现的目的了。
虚函数的作用？虚函数用于实现多态，这点大家都能答上来但是虚函数在设计上还具有封装和抽象的作用。比如抽象工厂模式。每个虚函数都有一个虚函数列表，根据指向对象的类型不同，函数地址也将不同。">
    

    <!--Author-->
    
        <meta name="author" content="Robert Lexis">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="C++多态"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="This is Robert Lexis."/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>C++多态 - This is Robert Lexis.</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
    </div>
</header>

        <section class="main">
            
<div class="post">

    <div class="post-header">
        <h1 class="title">
            <a href="/2018/04/01/C-多态/">
                C++多态
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-04-01</span>
            
            
            
        </div>
    </div>

    <div class="content">

        <!-- Gallery -->
        

        <!-- Post Content -->
        <h3 id="C-多态的实现？"><a href="#C-多态的实现？" class="headerlink" title="C++多态的实现？"></a>C++多态的实现？</h3><p>多态性可以简单地概括为“一个接口，多种实现”，程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。<br>C++多态性是通过虚函数来实现的，重写虚函数。<br>多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译时就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。<br>封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。<br>最常见的用法就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同类型而调用不同的方法。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是一定的，而固定的地址将始终调用到同一个函数，这就无法实现一个接口，多种实现的目的了。</p>
<h3 id="虚函数的作用？"><a href="#虚函数的作用？" class="headerlink" title="虚函数的作用？"></a>虚函数的作用？</h3><p>虚函数用于实现多态，这点大家都能答上来但是虚函数在设计上还具有封装和抽象的作用。比如抽象工厂模式。<br>每个虚函数都有一个虚函数列表，根据指向对象的类型不同，函数地址也将不同。<br><a id="more"></a></p>
<h3 id="virtual-的语义就是强制派生类重写该函数。"><a href="#virtual-的语义就是强制派生类重写该函数。" class="headerlink" title="virtual 的语义就是强制派生类重写该函数。"></a>virtual 的语义就是强制派生类重写该函数。</h3><h3 id="C-纯虚函数"><a href="#C-纯虚函数" class="headerlink" title="C++纯虚函数"></a>C++纯虚函数</h3><p>引入原因：在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。含有纯虚拟函数的类称为抽象类，它不能生成对象。<br>多态性：指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。 </p>
<ul>
<li>编译时多态性：通过重载函数实现</li>
<li>运行时多态性：通过虚函数实现<br>静态多态和动态多态。静态多态是指通过模板技术或者函数重载技术实现的多态，其在编译期确定行为。动态多态是指通过虚函数技术实现在运行期动态绑定的技术。</li>
</ul>
<h3 id="动态绑定的实现"><a href="#动态绑定的实现" class="headerlink" title="动态绑定的实现"></a>动态绑定的实现</h3><ol>
<li>为每一个包含虚函数的类设置一个虚表（VTABLE）<br>每当创建一个包含有虚函数的类或从包含虚函数的类派生一个类时，编译器就会为这个类创建一个 VTABLE。在 VTABLE 中，编译器放置了这个类中，或者它的基类中所有已经声明为 virtual 的函数的地址。如果在这个派生类中没有对基类中声明为 virtual 的函数进行重新定义，编译器就使用基类的这个虚函数的地址。<strong>而且所有 VTABLE 中虚函数地址的顺序是完全相同的。</strong></li>
<li>初始化虚指针（VPTR）<br>编译器在这个类的<strong>每个对象</strong>中放置 VPTR。VPTR 在对象的相同的位置（通常都在对象的开头）。VPTR 必须被初始化为指向相应的 VTABLE。</li>
<li>为虚函数调用插入代码<br>当通过基类的指针调用派生类的虚函数时，编译器将在调用处插入相应的代码，以实现通过 VPTR 找到 VTABLE，并根据 VTABLE 中存储的正确的虚函数地址，访问到正确的函数。</li>
</ol>
<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p>C++ 中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。<br>C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。这意味着我们可以通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。<br>假设我们有这样的一个类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">class Base</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Base()&#123;&#125;;</div><div class="line">    ~Base()&#123;&#125;;</div><div class="line">    virtual void f() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    virtual void g() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    virtual void h() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl;</div><div class="line">    &#125;      </div><div class="line">&#125;;</div><div class="line">typedef void(*Func)(void);</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;   </div><div class="line">    Base b;</div><div class="line">    Func fp = nullptr, gp = nullptr, hp = nullptr;</div><div class="line">    // 打印值一样，值是一样的，但是这个值的意义是不一样的，分别指向32bit空间，整个对象空间，64bit空间，</div><div class="line">    // 这在解引用时就会出现本质的差异。</div><div class="line">    cout &lt;&lt; &quot;虚函数表地址：&quot; &lt;&lt; (int*)(&amp;b) &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; &quot;虚函数表地址：&quot; &lt;&lt; &amp;b &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; &quot;虚函数表地址：&quot; &lt;&lt; (long long*)(&amp;b) &lt;&lt; endl;</div><div class="line">    // 下面这一行会报错，是因为这台机器是64位的，*(int*)(&amp;b) 是一个整型，空间只有32位，</div><div class="line">    // 在强制将其cast成64位地址时，就会报出 cast to pointer from integer of different size [-Wint-to-pointer-cast]</div><div class="line">    // cout &lt;&lt; &quot;虚函数表 — 第一个函数地址：&quot; &lt;&lt; (int*)*(int*)(&amp;b) &lt;&lt; endl;</div><div class="line">    // 当将 int 改成 long long 时就好了，如此将一个 long long 转换成指针（无论是何种类型的指针，此处是整型指针）。</div><div class="line">    // 在64位机器上用 long long*  cast 指针是安全的，而用 int* 则是不安全的。</div><div class="line">    cout &lt;&lt; &quot;虚函数表 — 第一个函数地址：&quot; &lt;&lt; (int*)*(long long*)(&amp;b) &lt;&lt; endl;</div><div class="line">    // Invoke the first virtual function </div><div class="line">    fp = (Func)*((long long*)*(long long*)(&amp;b));</div><div class="line">    fp();</div><div class="line">    gp = (Func)*((long long*)*(long long*)(&amp;b) + 1);</div><div class="line">    gp();</div><div class="line">    hp = (Func)*((long long*)*(long long*)(&amp;b) + 2);</div><div class="line">    hp();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“/0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。</p>
<p>下面将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。</p>
<h4 id="一般继承（无虚函数覆盖）"><a href="#一般继承（无虚函数覆盖）" class="headerlink" title="一般继承（无虚函数覆盖）"></a>一般继承（无虚函数覆盖）</h4><p><img src="http://oytnj8g2y.bkt.clouddn.com/vtable0.JPG" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">class Base</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Base()&#123;&#125;;</div><div class="line">    ~Base()&#123;&#125;;</div><div class="line">    virtual void f() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    virtual void g() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    virtual void h() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl;</div><div class="line">    &#125;      </div><div class="line">&#125;;</div><div class="line">class Derive : public Base</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Derive()&#123;&#125;;</div><div class="line">    ~Derive()&#123;&#125;;</div><div class="line">    virtual void f1() &#123;</div><div class="line">        cout &lt;&lt; &quot;Derive::f1&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    virtual void g1() &#123;</div><div class="line">        cout &lt;&lt; &quot;Derive::g1&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    virtual void h1() &#123;</div><div class="line">        cout &lt;&lt; &quot;Derive::h1&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;;</div><div class="line">typedef void(*Func)(void);</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;   </div><div class="line"></div><div class="line">    Derive d;</div><div class="line">    Func fp = nullptr, gp = nullptr, hp = nullptr;</div><div class="line">    fp = (Func)*((long long*)*(long long*)(&amp;d));</div><div class="line">    fp();</div><div class="line">    gp = (Func)*((long long*)*(long long*)(&amp;d) + 1);</div><div class="line">    gp();</div><div class="line">    hp = (Func)*((long long*)*(long long*)(&amp;d) + 2);</div><div class="line">    hp();</div><div class="line"></div><div class="line">    Func f1p = nullptr, g1p = nullptr, h1p = nullptr;</div><div class="line">    f1p = (Func)*((long long*)*(long long*)(&amp;d) + 3);</div><div class="line">    f1p();</div><div class="line">    g1p = (Func)*((long long*)*(long long*)(&amp;d) + 4);</div><div class="line">    g1p();</div><div class="line">    h1p = (Func)*((long long*)*(long long*)(&amp;d) + 5);</div><div class="line">    h1p();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Base::f</div><div class="line">Base::g</div><div class="line">Base::h</div><div class="line">Derive::f1</div><div class="line">Derive::g1</div><div class="line">Derive::h1</div></pre></td></tr></table></figure>
<p><img src="http://oytnj8g2y.bkt.clouddn.com/vtable1.JPG" alt=""><br>我们可以看到下面几点：</p>
<ol>
<li>虚函数按照其声明顺序放于表中。</li>
<li>父类的虚函数在子类的虚函数前面。<h4 id="一般继承（有虚函数覆盖）"><a href="#一般继承（有虚函数覆盖）" class="headerlink" title="一般继承（有虚函数覆盖）"></a>一般继承（有虚函数覆盖）</h4>覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。<br><img src="http://oytnj8g2y.bkt.clouddn.com/vtable2.JPG" alt=""><br>为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子：<br><img src="http://oytnj8g2y.bkt.clouddn.com/vtable3.JPG" alt=""><br>我们从表中可以看到下面几点，</li>
<li>覆盖的f()函数被放到了虚表中原来父类虚函数的位置。</li>
<li>没有被覆盖的函数依旧。<br>这样，我们就可以看到对于下面这样的程序，<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Base *b = new Derive();</div><div class="line">b-&gt;f();</div></pre></td></tr></table></figure>
</li>
</ol>
<p>由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。</p>
<h4 id="多重继承（无虚函数覆盖）"><a href="#多重继承（无虚函数覆盖）" class="headerlink" title="多重继承（无虚函数覆盖）"></a>多重继承（无虚函数覆盖）</h4><p>下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。<br><img src="http://oytnj8g2y.bkt.clouddn.com/vtable4.JPG" alt=""><br>对于子类实例中的虚函数表，是下面这个样子：<br><img src="http://oytnj8g2y.bkt.clouddn.com/vtable5.JPG" alt=""><br>我们可以看到：</p>
<ol>
<li>每个父类都有自己的虚表。</li>
<li>子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）</li>
</ol>
<p>这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。</p>
<h4 id="多重继承（有虚函数覆盖）"><a href="#多重继承（有虚函数覆盖）" class="headerlink" title="多重继承（有虚函数覆盖）"></a>多重继承（有虚函数覆盖）</h4><p>下面我们再来看看，如果发生虚函数覆盖的情况。<br>下图中，我们在子类中覆盖了父类的f()函数。<br><img src="http://oytnj8g2y.bkt.clouddn.com/vtable6.JPG" alt=""><br>下面是对于子类实例中的虚函数表的图：<br><img src="http://oytnj8g2y.bkt.clouddn.com/vtable7.JPG" alt=""><br>我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Derive d;</div><div class="line">Base1 *b1 = &amp;d;</div><div class="line">Base2 *b2 = &amp;d;</div><div class="line">Base3 *b3 = &amp;d;</div><div class="line">b1-&gt;f(); //Derive::f()</div><div class="line">b2-&gt;f(); //Derive::f()</div><div class="line">b3-&gt;f(); //Derive::f()</div><div class="line">b1-&gt;g(); //Base1::g()</div><div class="line">b2-&gt;g(); //Base2::g()</div><div class="line">b3-&gt;g(); //Base3::g()</div></pre></td></tr></table></figure></p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>每次写C++的文章，总免不了要批判一下C++。这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。</p>
<ol>
<li>通过父类型的指针访问子类自己的虚函数</li>
</ol>
<p>我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的<strong>自有虚函数</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Base1 *b1 = new Derive();</div><div class="line">b1-&gt;f1();  //编译出错</div></pre></td></tr></table></figure></p>
<p>任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。</p>
<ol>
<li>访问 non-public 的虚函数<br>另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">class Base</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Base()&#123;&#125;;</div><div class="line">    ~Base()&#123;&#125;;</div><div class="line">    virtual void f() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl;</div><div class="line">    &#125;;</div><div class="line">private:</div><div class="line">    virtual void h() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line">class Derive: public Base</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Derive()&#123;&#125;;</div><div class="line">    ~Derive()&#123;&#125;;</div><div class="line">    virtual void f() &#123;</div><div class="line">        cout &lt;&lt; &quot;Derive::f&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    virtual void g() &#123;</div><div class="line">        cout &lt;&lt; &quot;Derive::g&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">typedef void(*Func)(void);</div><div class="line"></div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    Base* ptr = new Derive;</div><div class="line">    ptr-&gt;f();</div><div class="line">    // ptr-&gt;g();</div><div class="line">    Func func_ptr = nullptr;</div><div class="line">    func_ptr = (Func)*((long long*)*(long long*)ptr + 1); </div><div class="line">    func_ptr();</div><div class="line">    func_ptr = (Func)*((long long*)*(long long*)ptr + 2); </div><div class="line">    func_ptr();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Derive::f</div><div class="line">Base::h</div><div class="line">Derive::g</div></pre></td></tr></table></figure>

    </div>

    

    
        <div class="post-tags">
            <i class="fa fa-tags" aria-hidden="true"></i>
            <a href="/tags/C/">#C++</a>
        </div>
    

    <!-- Comments -->
    

</div>
        </section>

    </div>
</div>


</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This is Robert Lexis (FengCun Li). To see the world, things dangerous to come to, to see behind walls, to draw closer, to find each other and to feel. That is the purpose of LIFE.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2019/03/18/Emplace-back/">Emplace back</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/03/14/Perfect-forward/">Perfect forward</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/03/14/Move-semantic-perfect-forward/">Move semantic &amp; perfect f</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/03/14/RAII-smart-pointer/">RAII &amp; smart pointer</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/RobertLexis">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:robert_lexis@163.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Robert Lexis Loves Wenny
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>