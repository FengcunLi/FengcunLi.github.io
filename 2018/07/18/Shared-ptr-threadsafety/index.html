<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="From giantchen.shared_ptr 的引用计数本身是安全且无锁的，但对象的读写则不是，因为 shared_ptr 有两个数据成员，读写操作不能原子化。shared_ptr 的线程安全级别和内建类型、标准库容器、std::string 一样，即：

一个 shared_ptr 对象实体可被多个线程同时读取；
两个 shared_ptr 对象实体可以被两个线程同时写入
如果要从多个线程读写同一个 shared_ptr 对象，那么需要加锁

请注意，以上是 shared_ptr 对象本身的线程安全级别，不是它管理的对象的线程安全级别。
本文则具体分析一下为什么“因为 shared_ptr 有两个数据成员，读写操作不能原子化”使得多线程读写同一个 shared_ptr 对象需要加锁。本文以 boost::shared_ptr 为例，与 std::shared_ptr 可能略有区别。">
    

    <!--Author-->
    
        <meta name="author" content="Robert Lexis">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Shared_ptr threadsafety"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="This is Robert Lexis."/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>Shared_ptr threadsafety - This is Robert Lexis.</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
    </div>
</header>

        <section class="main">
            
<div class="post">

    <div class="post-header">
        <h1 class="title">
            <a href="/2018/07/18/Shared-ptr-threadsafety/">
                Shared_ptr threadsafety
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-07-18</span>
            
            
            
        </div>
    </div>

    <div class="content">

        <!-- Gallery -->
        

        <!-- Post Content -->
        <p><strong>From giantchen.</strong><br><code>shared_ptr</code> 的引用计数本身是安全且无锁的，但对象的读写则不是，因为 <code>shared_ptr</code> 有两个数据成员，读写操作不能原子化。<code>shared_ptr</code> 的线程安全级别和内建类型、标准库容器、<code>std::string</code> 一样，即：</p>
<ul>
<li>一个 shared_ptr 对象实体可被多个线程同时读取；</li>
<li>两个 shared_ptr 对象实体可以被两个线程同时写入</li>
<li>如果要从多个线程读写同一个 shared_ptr 对象，那么需要加锁</li>
</ul>
<p>请注意，以上是 <code>shared_ptr</code> 对象本身的线程安全级别，不是它管理的对象的线程安全级别。</p>
<p>本文则具体分析一下为什么“因为 <code>shared_ptr</code> 有两个数据成员，读写操作不能原子化”使得多线程读写同一个 <code>shared_ptr</code> 对象需要加锁。本文以 <code>boost::shared_ptr</code> 为例，与 <code>std::shared_ptr</code> 可能略有区别。<br><a id="more"></a></p>
<h3 id="shared-ptr-的数据结构"><a href="#shared-ptr-的数据结构" class="headerlink" title="shared_ptr 的数据结构"></a>shared_ptr 的数据结构</h3><p><code>shared_ptr</code> 是引用计数型（reference counting）智能指针，几乎所有的实现都采用在堆（heap）上放个计数值（count）的办法。具体来说，<code>shared_ptr&lt;Foo&gt;</code> 包含两个成员，一个是指向 <code>Foo</code> 的指针 <code>ptr</code>，另一个是 <code>ref_count</code> 指针，指向堆上的 <code>ref_count</code> 对象。<code>ref_count</code> 对象有多个成员，具体的数据结构如图所示，其中 <code>deleter</code> 和 <code>allocator</code> 是可选的。<br><img src="/2018/07/18/Shared-ptr-threadsafety/1.png" alt="data_structure"><br>为了简化并突出重点，后文只画出 <code>use_count</code> 的值，<code>shared_ptr&lt;Foo&gt; x(new Foo);</code> 对应的内存数据结构:<br><img src="/2018/07/18/Shared-ptr-threadsafety/2.png" alt="data_structure"><br>如果再执行 <code>shared_ptr&lt;Foo&gt; y = x;</code> 那么对应的数据结构如下:<br><img src="/2018/07/18/Shared-ptr-threadsafety/3.png" alt="data_structure"><br>但是 <code>y=x</code> 涉及两个成员的复制，这两步拷贝不会同时（原子）发生。<br>中间步骤 1，复制 ptr 指针：<br><img src="/2018/07/18/Shared-ptr-threadsafety/4.png" alt="data_structure"><br>中间步骤 2，复制 ref_count 指针，导致引用计数加 1：<br><img src="/2018/07/18/Shared-ptr-threadsafety/5.png" alt="data_structure"><br>步骤1和步骤2的先后顺序跟实现相关（因此步骤 2 里没有画出 y.ptr 的指向），我见过的都是先1后2。既然 <code>y=x</code> 有两个步骤，如果没有 mutex 保护，那么在多线程里就有 race condition。</p>
<h3 id="多线程无保护读写-shared-ptr-可能出现的-race-condition"><a href="#多线程无保护读写-shared-ptr-可能出现的-race-condition" class="headerlink" title="多线程无保护读写 shared_ptr 可能出现的 race condition"></a>多线程无保护读写 shared_ptr 可能出现的 race condition</h3><p>考虑一个简单的场景，有 3 个 <code>shared_ptr&lt;Foo&gt;</code> 对象 <code>x</code>、<code>g</code>、<code>n</code>：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">shared_ptr</span>&lt;Foo&gt; g(<span class="keyword">new</span> Foo); <span class="comment">// 线程之间共享的 shared_ptr</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;Foo&gt; x; <span class="comment">// 线程 A 的局部变量</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;Foo&gt; n(<span class="keyword">new</span> Foo); <span class="comment">// 线程 B 的局部变量</span></div></pre></td></tr></table></figure></p>
<p>一开始，各安其事。<br><img src="/2018/07/18/Shared-ptr-threadsafety/6.png" alt="data_structure"><br>线程 A 执行 x = g; （即 read g），以下完成了步骤 1，还没来及执行步骤 2。这时切换到了 B 线程。<br><img src="/2018/07/18/Shared-ptr-threadsafety/7.png" alt="data_structure"><br>同时线程 B 执行 g = n; （即 write g），两个步骤一起完成了。<br>先是步骤 1：<br><img src="/2018/07/18/Shared-ptr-threadsafety/8.png" alt="data_structure"><br>再是步骤 2：<br><img src="/2018/07/18/Shared-ptr-threadsafety/9.png" alt="data_structure"><br>这是 Foo1 对象已经销毁，x.ptr 成了空悬指针！<br>最后回到线程 A，完成步骤 2：<br><img src="/2018/07/18/Shared-ptr-threadsafety/10.png" alt="data_structure"><br>多线程无保护地读写 <code>g</code>，造成了“<code>x</code> 是空悬指针”的后果。这正是多线程读写同一个 <code>shared_ptr</code> 必须加锁的原因。</p>
<h3 id="为什么图-1-中的-ref-count-也有指向-Foo-的指针？"><a href="#为什么图-1-中的-ref-count-也有指向-Foo-的指针？" class="headerlink" title="为什么图 1 中的 ref_count 也有指向 Foo 的指针？"></a>为什么图 1 中的 ref_count 也有指向 Foo 的指针？</h3><p><code>shared_ptr&lt;Foo&gt; sp(new Foo)</code> 在构造 <code>sp</code> 的时候捕获了 <code>Foo</code> 的析构行为。实际上 <code>shared_ptr.ptr</code> 和 <code>ref_count.ptr</code> 可以是不同的类型（只要它们之间存在隐式转换），这是 <code>shared_ptr</code> 的一大功能。分 3 点来说：</p>
<ul>
<li>无需虚析构；假设 Bar 是 Foo 的基类，但是 Bar 和 Foo 都没有虚析构。<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">shared_ptr</span>&lt;Foo&gt; sp1(<span class="keyword">new</span> Foo); <span class="comment">// ref_count.ptr 的类型是 Foo*</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;Bar&gt; sp2 = sp1; <span class="comment">// 可以赋值，自动向上转型（up-cast）</span></div><div class="line">sp1.reset(); <span class="comment">// 这时 Foo 对象的引用计数降为 1</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>此后 <code>sp2</code> 仍然能安全地管理 <code>Foo</code> 对象的生命期，并安全完整地释放 <code>Foo</code>，因为其 <code>ref_count</code> 记住了 <code>Foo</code> 的实际类型。</p>
<ul>
<li><code>shared_ptr&lt;void&gt;</code> 可以指向并安全地管理（析构或防止析构）任何对象；<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">shared_ptr</span>&lt;Foo&gt; sp1(<span class="keyword">new</span> Foo); <span class="comment">// ref_count.ptr 的类型是 Foo*</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">void</span>&gt; sp2 = sp1; <span class="comment">// 可以赋值，Foo* 向 void* 自动转型</span></div><div class="line">sp1.reset(); <span class="comment">// 这时 Foo 对象的引用计数降为 1</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>此后 <code>sp2</code> 仍然能安全地管理 <code>Foo</code> 对象的生命期，并安全完整地释放 <code>Foo</code>，不会出现 <code>delete void*</code> 的情况，因为 <code>delete</code> 的是 <code>ref_count.ptr</code>，不是 <code>sp2.ptr</code>。</p>
<ul>
<li>多继承。假设 <code>Bar</code> 是 <code>Foo</code> 的多个基类之一，那么：<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">shared_ptr</span>&lt;Foo&gt; sp1(<span class="keyword">new</span> Foo);</div><div class="line"><span class="built_in">shared_ptr</span>&lt;Bar&gt; sp2 = sp1; <span class="comment">// 这时 sp1.ptr 和 sp2.ptr 可能指向不同的地址，因为 Bar subobject 在 Foo object 中的 offset 可能不为0。</span></div><div class="line">sp1.reset(); <span class="comment">// 此时 Foo 对象的引用计数降为 1</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>但是 <code>sp2</code> 仍然能安全地管理 <code>Foo</code> 对象的生命期，并安全完整地释放 <code>Foo</code>，因为 delete 的不是 <code>Bar*</code>，而是原来的 <code>Foo*</code>。换句话说，<code>sp2.ptr</code> 和 <code>ref_count.ptr</code> 可能具有不同的值（当然它们的类型也不同）。</p>
<h3 id="为什么要尽量使用-make-shared-？"><a href="#为什么要尽量使用-make-shared-？" class="headerlink" title="为什么要尽量使用 make_shared()？"></a>为什么要尽量使用 make_shared()？</h3><p>为了节省一次内存分配，原来 <code>shared_ptr&lt;Foo&gt; x(new Foo);</code> 需要为 <code>Foo</code> 和 <code>ref_count</code> 各分配一次内存，现在用 <code>make_shared()</code> 的话，可以一次分配一块足够大的内存，供 <code>Foo</code> 和 <code>ref_count</code> 对象容身。数据结构是：<br><img src="/2018/07/18/Shared-ptr-threadsafety/11.png" alt="data_structure"><br>不过 <code>Foo</code> 的构造函数参数要传给 <code>make_shared()</code>，后者再传给 <code>Foo::Foo()</code>，这只有在 C++11 里通过 <strong>perfect forwarding</strong> 才能完美解决。</p>

    </div>

    

    
        <div class="post-tags">
            <i class="fa fa-tags" aria-hidden="true"></i>
            <a href="/tags/C/">#C++</a>
        </div>
    

    <!-- Comments -->
    

</div>
        </section>

    </div>
</div>


</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This is Robert Lexis (FengCun Li). To see the world, things dangerous to come to, to see behind walls, to draw closer, to find each other and to feel. That is the purpose of LIFE.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2019/07/12/Unnamed-namespace/">Unnamed namespace</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/05/08/Static-variable-in-inlined-function/">Static variable in inline</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/04/23/Iterator-invalidation-rules/">Iterator invalidation rul</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2019/03/18/Emplace-back/">Emplace back</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/RobertLexis">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:robert_lexis@163.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Robert Lexis Loves Wenny
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>