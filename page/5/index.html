<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    

    <!--Author-->
    
        <meta name="author" content="Robert Lexis">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="This is WHY."/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="This is WHY."/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>page - This is WHY.</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">This is WHY.</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2017/12/07/Learning-TensorFlow-1-Basic/">
                Learning TensorFlow 1 Basic
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-12-07</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h2><h4 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h4><p><strong>Tensor</strong> 存储的不是数字，而是<strong>运算（Operation）</strong>结果的一个引用，例如 <code>Tensor(&quot;add:0&quot;, shape=(2,), dtype=float32)</code>。</p>
<blockquote>
<p>Tensor<br>Represents one of the outputs of an <strong>Operation</strong>.</p>
<p>A Tensor is a symbolic handle to one of the outputs of an Operation. It does not hold the values of that operation’s output, but instead provides a means of computing those values in a TensorFlow tf.Session.<br>This class has two primary purposes:</p>
<ul>
<li>A Tensor can be passed as an input to another Operation. This builds a dataflow connection between operations, which enables TensorFlow to execute an entire Graph that represents a large, multi-step computation.</li>
<li>After the graph has been launched in a session, the value of the Tensor can be computed by passing it to tf.Session.run. <strong>t.eval() is a shortcut for calling tf.get_default_session().run(t)</strong>.<br>In the following example, c, d, and e are symbolic Tensor objects, whereas result is a numpy array that stores a concrete value:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Build a dataflow graph.</span></div><div class="line">c = tf.constant([[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]])</div><div class="line">d = tf.constant([[<span class="number">1.0</span>, <span class="number">1.0</span>], [<span class="number">0.0</span>, <span class="number">1.0</span>]])</div><div class="line">e = tf.matmul(c, d)</div><div class="line"></div><div class="line"><span class="comment"># Construct a `Session` to execute the graph.</span></div><div class="line">sess = tf.Session()</div><div class="line"></div><div class="line"><span class="comment"># Execute the graph and store the value that `e` represents in `result`.</span></div><div class="line">result = sess.run(e)</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="运算-Operation"><a href="#运算-Operation" class="headerlink" title="运算 Operation"></a>运算 Operation</h4><p>运算是对张量的操作, 张量与张量之间的联系是通过运算发生的。</p>
<blockquote>
<p>Represents a graph node that performs computation on tensors.</p>
<p>An Operation is a node in a TensorFlow Graph that takes zero or more Tensor objects as input, and produces zero or more Tensor objects as output. Objects of type Operation are created by calling a Python op constructor (such as tf.matmul) or tf.Graph.create_op.<br>For example <code>c = tf.matmul(a, b)</code> creates <strong>an Operation of type “MatMul”</strong> that takes tensors <code>a</code> and <code>b</code> as input, and produces <code>c</code> as output.<br>After the graph has been launched in a session, an Operation can be executed by passing it to <code>tf.Session.run</code>. <strong>op.run() is a shortcut for calling tf.get_default_session().run(op)</strong>.</p>
</blockquote>
<h4 id="计算图"><a href="#计算图" class="headerlink" title="计算图"></a>计算图</h4><p>TensorFlow 会自动生成一个默认的计算图，如果没有特殊指定，运算（即节点）会自动被加入到这个计算图中。</p>
<h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>TensorFlow 不会自动生成一个默认的会话，但是可以在指定默认会话之后通过 <code>tf.Tensor.eval()</code>来获得张量所引用的运算结果的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sess = tf.Session()</div><div class="line"># 通过上下文管理器就可以完成默认会话的指定</div><div class="line">with sess.as_default():</div><div class="line">     print(result.eval())</div></pre></td></tr></table></figure></p>
<p>上面的代码和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sess = tf.Session()</div><div class="line">sess.run(result)</div></pre></td></tr></table></figure></p>
<p>及<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sess = tf.Session()</div><div class="line">result.eval(session=sess)</div></pre></td></tr></table></figure></p>
<p>是一样的。<br>在交互式环境下，通过指定默认会话的方式来执行计算是十分方便的，但是指定默认会话的语句 <code>with sess.as_default()</code> 又带来缩进问题等比较麻烦，因此 <code>tf.InteractiveSession()</code> 应运而生，使用这个函数可以在交互式环境下将生成的会话直接指定为默认会话。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sess = tf.InteractiveSession()</div><div class="line">result.eval()</div><div class="line"># 关闭会话释放资源</div><div class="line">sess.close()</div></pre></td></tr></table></figure></p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p><code>tf.Variable</code> 的作用就是保存和更新神经网络的参数。</p>
<blockquote>
<p>The Variable() constructor requires an initial value for the variable, which can be a Tensor of any type and shape. The initial value defines the <strong>type</strong> and <strong>shape</strong> of the variable. <strong>After construction, the type and shape of the variable are fixed. The value can be changed using one of the assign methods.</strong><br>If you want to change the shape of a variable later you have to use an assign Op with validate_shape=False.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import tensorflow as tf</div><div class="line"></div><div class="line"># Create a variable.</div><div class="line">w = tf.Variable(&lt;initial-value&gt;, name=&lt;optional-name&gt;)</div><div class="line"></div><div class="line"># Use the variable in the graph like any Tensor.</div><div class="line">y = tf.matmul(w, ...another variable or tensor...)</div><div class="line"></div><div class="line"># The overloaded operators are available too.</div><div class="line">z = tf.sigmoid(w + y)</div><div class="line"></div><div class="line"># Assign a new value to the variable with `assign()` or a related method.</div><div class="line">w.assign(w + 1.0)</div><div class="line">w.assign_add(1.0)</div></pre></td></tr></table></figure>
<p>When you launch the graph, variables have to be explicitly initialized before you can run Ops that use their value. You can initialize a variable by <strong>running its initializer op</strong>, <strong>restoring the variable from a save file</strong>, or <strong>simply running an assign Op that assigns a value to the variable</strong>. In fact, the variable initializer op is just an assign Op that assigns the variable’s initial value to the variable itself.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># Launch the graph in a session.</div><div class="line">with tf.Session() as sess:</div><div class="line">  # Run the variable initializer.</div><div class="line">  sess.run(w.initializer)</div><div class="line">  # ...you now can run ops that use the value of &apos;w&apos;...</div></pre></td></tr></table></figure>
<p>The most common initialization pattern is to use the convenience function global_variables_initializer() to add an Op to the graph that initializes all the variables. You then run that Op after launching the graph.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># Add an Op to initialize global variables.</div><div class="line">init_op = tf.global_variables_initializer()</div><div class="line"></div><div class="line"># Launch the graph in a session.</div><div class="line">with tf.Session() as sess:</div><div class="line">  # Run the Op that initializes global variables.</div><div class="line">  sess.run(init_op)</div><div class="line">  # ...you can now run any Op that uses variable values...</div></pre></td></tr></table></figure>
<p>If you need to create a variable with an initial value dependent on another variable, use the other variable’s <code>initialized_value()</code>. This ensures that variables are initialized in the right order.<br>All variables are automatically collected in the graph where they are created. By default, the constructor adds the new variable to <strong>the graph collection GraphKeys.GLOBAL_VARIABLES</strong>. The convenience function <code>global_variables()</code> returns the contents of that collection.<br>When building a machine learning model it is often convenient to distinguish between variables holding the trainable model parameters and other variables such as a global step variable used to count training steps. To make this easier, the variable constructor supports a <code>trainable=&lt;bool&gt;</code> parameter. If True, the new variable is <code>also</code> added to <code>the graph collection GraphKeys.TRAINABLE_VARIABLES</code>. The convenience function <code>trainable_variables()</code> returns the contents of this collection. <strong>The various Optimizer classes use this collection as the default list of variables to optimize</strong>.</p>
</blockquote>
<p>变量初始化：</p>
<ul>
<li>tf.random_normal</li>
<li>tf.truncated_normal</li>
<li>tf.random_uniform</li>
<li>tf.random_gamma</li>
<li>tf.zeros([2, 3], int32)</li>
<li>tf.ones([2, 3], int32)</li>
<li>tf.fill([2, 3], 9)</li>
<li>tf.constant([1, 2, 3])</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">biases = tf.Variable(tf.ones([3]))</div><div class="line"># 除了使用随机数和常数，也支持通过其他变量的初始值来初始化新的变量。</div><div class="line"># tf.Variable(biases.initialized_value() * 0.2)</div></pre></td></tr></table></figure>
<p>在TensorFlow中，一个变量在被运算使用之前， 这个变量的初始化需要被显式调用。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">w1 = tf.Variable(tf.random_normal([2, 3], stddev=1, seed=1))</div><div class="line">w2 = tf.Variable(tf.random_normal([3, 1], stddev=1, seed=1))</div><div class="line">x = tf.constant([[0.7, 0.9]])</div><div class="line">a = tf.matmul(x, w1)</div><div class="line">y = tf.matmul(a, w2)</div><div class="line"></div><div class="line">sess = tf.Session()</div><div class="line"># 这里不能直接通过sess.run(y)来获取y的取值</div><div class="line"># 在变量定义时，虽然给出了初始化方法，但是这个初始化方法并没有被真正运行</div><div class="line"># 一个一个地调用初始化方法</div><div class="line">sess.run(w1.initializer)</div><div class="line">sess.run(w2.initializer)</div><div class="line">print(sess.run(y))</div><div class="line">sess.close()</div></pre></td></tr></table></figure></p>
<p>所有的变量都会被加入到 <code>GraphKeys.GLOBAL_VARIABLES</code> 这个集合，<code>global_variables</code> 函数可以拿到当前计算图的所有变量，拿到计算图的所有变量方便持久化整个计算图的运行状态。</p>
<p>变量的类型是不可改变的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">w1 = tf.Variable(tf.random_normal([2, 3], stddev=1, seed=1), name=&quot;w1&quot;) // 默认是tf.float32</div><div class="line">w2 = tf.Variable(tf.random_normal([2, 3], stddev=1, seed=1, dtype=tf.float64), name=&quot;w2&quot;)</div><div class="line">w1.assign(w2)</div></pre></td></tr></table></figure></p>
<p>程序将报错<br>变量的维度是可以改变的，但是需要设置参数 <code>validate_shape=False</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">w1 = tf.Variable(tf.random_normal([2, 3], stddev=1, seed=1), name=&quot;w1&quot;)</div><div class="line">w2 = tf.Variable(tf.random_normal([2, 2], stddev=1, seed=1), name=&quot;w2&quot;)</div><div class="line">tf.assign(w1, w2)</div></pre></td></tr></table></figure></p>
<p>会报错：维度不匹配，使用 <code>tf.assign(w1, w2, validate_shape=False)</code> 就好了</p>
<h4 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h4><p>可以通过 <code>x = tf.constant([[0.7, 0.9]])</code> 表达一个batch的数据，但是每生成一个常量，计算图中就会增加一个节点，一般来说，神经网络的训练过程需要经过几百万甚至几亿次迭代，如果都用常量的方式输入值，这个计算图就爆了。为了避免这个问题，TensorFLow 使用 <strong>placeholder</strong> 的机制来输入数据。这样就不需要生成大量的常量来提供数据，只需要将数据通过 placeholder 输入即可。<br>placeholder 的类型不可更改，但是维度可以通过提供的数据推导得到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">w1 = tf.Variable(tf.random_normal([2, 3], stddev=1, seed=1))</div><div class="line">w2 = tf.Variable(tf.random_normal([3, 1], stddev=1, seed=1))</div><div class="line"></div><div class="line">// 这里的shape不一定给出，如果是确定的，给出维度可以降低出错的概率</div><div class="line">x = tf.placeholder(tf.float32, shape=(1, 2), name=&quot;input&quot;)</div><div class="line"></div><div class="line">a = tf.matmul(x, w1)</div><div class="line">y = tf.matmul(a, w2)</div><div class="line"></div><div class="line">sess = tf.Session()</div><div class="line">init_op = tf.global_variables_initializer()</div><div class="line">sess.run(init_op)</div><div class="line"></div><div class="line">// print(sess.run(y))</div><div class="line">// 将报错，必须 feed</div><div class="line"></div><div class="line">print(sess.run(y, feed_dict=&#123;x: [[0.7, 0.9]]&#125;))</div><div class="line">sess.close()</div></pre></td></tr></table></figure></p>
<h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>在得到一个batch的前向传播结果之后，需要定义一个损失函数来刻画当前的预测值和真实值之间的差距，然后通过反向传播算法调整神经网络的参数使得差距被缩小。</p>
<h5 id="交叉熵是分类问题中常用的损失函数"><a href="#交叉熵是分类问题中常用的损失函数" class="headerlink" title="交叉熵是分类问题中常用的损失函数"></a>交叉熵是分类问题中常用的损失函数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cross_entropy = -tf.reduce_mean(_y * tf.log(tf.clip_by_value(y, 1e-10, 1.0)))</div><div class="line">learning_rate = 0.001</div><div class="line">train_step = tf.train.AdamOptimizer(learning_rate).minimize(cross_entropy)</div></pre></td></tr></table></figure>
<p>通过运行 <code>sess.run(train_step)</code> 就可以对所有在 GraphKeys.TRAINABLE_VARIABLES 集合中的变量进行优化，使得当前 batch 下损失函数更小。<br><code>cross_entropy = -tf.reduce_mean(_y * tf.log(tf.clip_by_value(y, 1e-10, 1.0)))</code>包含四个不同的运算，因为交叉熵与 softmax 回归经常一起使用，因此对这两个功能进行了封装，<code>tf.nn.softmax_cross_entropy_with_logits(y, y_)</code> y 是神经网络的原始输出，y_是真实label。</p>
<h5 id="均方误差是回归问题中常用的损失函数"><a href="#均方误差是回归问题中常用的损失函数" class="headerlink" title="均方误差是回归问题中常用的损失函数"></a>均方误差是回归问题中常用的损失函数</h5><p><code>mse = tf.reduce_mean(tf.square(y_ - y))</code> </p>
<h4 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h4><p><code>tf.train.exponential_decay</code> 函数实现了指数衰减学习率，通过它可以先使用较大的学习率来快速得到一个比较优的解，然后随着迭代逐步减少学习率，使得模型在后期更加稳定，而不是振荡。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">global_step = tf.Variable(0)</div><div class="line">learning_rate = tf.train.exponential_decay(0.1, global_step, 100, 0.96, staircase=True)</div><div class="line"></div><div class="line"># 使用指数衰减学习率，在minimize中传入global_step将自动更新global_step参数，从而使得学习率也得到相应的更新。</div><div class="line">learning_step = tf.train.GradientDescentOptimizer(learning_rate).minimize(loss, global_step=global_step)</div></pre></td></tr></table></figure></p>
<h4 id="过拟合问题"><a href="#过拟合问题" class="headerlink" title="过拟合问题"></a>过拟合问题</h4><p>TensorFlow 可以优化带正则化的损失函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">w = tf.Variable(tf.random_normal([2, 1], stddev=1, seed=1))</div><div class="line">y = tf.matmul(x, w)</div><div class="line"></div><div class="line">loss = tf.reduce_mean(tf.square(y_ - y)) + tf.contrib.layers.l2_regularizer(lambda)(w)</div></pre></td></tr></table></figure></p>
<p>比如 L1 和 L2 正则化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">weights = tf.constant([[1.0, -2.0], [-3.0, 4.0]])</div><div class="line">with tf.Session() as sess:</div><div class="line">     (|1| + |-2| + |-3| + |4|) * 0.5 = 5</div><div class="line">     print sess.run(tf.contrib.layers.l1_regularizer(0.5)(weights))</div><div class="line">     (1 + 4 + 9 + 16)/2 + 0.5 = 7.5</div><div class="line">     print sess.run(tf.contrib.layers.l2_regularizer(0.5)(weights))</div></pre></td></tr></table></figure></p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>在简单的神经网络里，像 <code>loss = tf.reduce_mean(tf.square(y_ - y)) + tf.contrib.layers.l2_regularizer(lambda)(w)</code> 这样将权重的正则化加入损失函数就可以了，但是当网络复杂之后参数增多，首先会导致损失函数的定义很长，但是更重要的是网络结构的定义部分和损失函数的定义部分可能不在同一个函数里，这样通过变量来传递的方式就不方便了。为了解决这个问题，可以使用 TensorFlow 提供的集合， 它保存了一个计算图中的很多实体（比如张量）。<br>获取一层神经网络上的权重，并将这个权重的L2正则化损失加入到名为losses的集合中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">def get_weight(shape, lambda):</div><div class="line">    var = tf.Variable(tf.random_normal(shape), dtype=tf.float32)</div><div class="line">    tf.add_to_collection(&quot;losses&quot;, tf.contrib.layers.l2_regularizer(lambda)(var))</div><div class="line">    return var</div><div class="line"></div><div class="line">x = tf.placeholder(tf.float32, shape=(None, 2))</div><div class="line">y_ = tf.placeholder(tf.float32, shape=(None, 1))</div><div class="line">batch_size = 8</div><div class="line"></div><div class="line">layer_dimension = [2, 10, 10, 10, 1]</div><div class="line">n_layers = len(layer_dimension)</div><div class="line"></div><div class="line"># 当前层</div><div class="line">cur_layer = x</div><div class="line"># 当前层的节点个数</div><div class="line">in_dimension = layer_dimension[0]</div><div class="line"></div><div class="line"># 全连接神经网络</div><div class="line">for i in range(1, n_layers):</div><div class="line">     out_dimension = layer_dimension[i]</div><div class="line">     weight = get_weight([in_dimension, out_dimension], 0.001)</div><div class="line">     bias = tf.Variable(tf.constant(0.1, shape=[out_dimension]))</div><div class="line">     cur_layer = tf.nn.relu(tf.matmul(cur_layer, weight) + bias)</div><div class="line">     in_dimension = layer_dimension[i]</div><div class="line"></div><div class="line">mse_loss = tf.reduce_mean(tf.square(y_ - cur_layer))</div><div class="line">tf.add_to_collection(&quot;losses&quot;, mse_loss)</div><div class="line">loss = tf.add_n(tf.get_collection(&quot;losses&quot;))</div></pre></td></tr></table></figure></p>
<h4 id="name-scope-和-variable-scope"><a href="#name-scope-和-variable-scope" class="headerlink" title="name_scope 和 variable_scope"></a>name_scope 和 variable_scope</h4><p>经常使用 name_scope 做计算图可视化时的缩略控制，variable_scope 控制变量的命名，控制变量共享。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import tensorflow as tf</div><div class="line">with tf.variable_scope(&apos;variable_scope_y&apos;) as scope:</div><div class="line">    var1 = tf.get_variable(name=&apos;var1&apos;, shape=[1], dtype=tf.float32)</div><div class="line">    scope.reuse_variables() # 设置共享变量</div><div class="line">    var1_reuse = tf.get_variable(name=&apos;var1&apos;)</div><div class="line">    var2 = tf.Variable(initial_value=[2.], name=&apos;var2&apos;, dtype=tf.float32)</div><div class="line">    var2_reuse = tf.Variable(initial_value=[2.], name=&apos;var2&apos;, dtype=tf.float32)</div><div class="line"></div><div class="line">with tf.Session() as sess:</div><div class="line">     sess.run(tf.global_variables_initializer())</div><div class="line">     print(var1.name, sess.run(var1))</div><div class="line">     print(var1_reuse.name, sess.run(var1_reuse))</div><div class="line">     print(var2.name, sess.run(var2))</div><div class="line">     print(var2_reuse.name, sess.run(var2_reuse))</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">variable_scope_y/var1:0 [-1.59682846]</div><div class="line">variable_scope_y/var1:0 [-1.59682846]</div><div class="line">variable_scope_y/var2:0 [ 2.]</div><div class="line">variable_scope_y/var2_1:0 [ 2.]</div></pre></td></tr></table></figure></p>
<p>可以看到变量 <code>var1_reuse</code> 重复使用了 <code>var1</code>，如果使用 Variable 的话，每次都会新建变量，但是大多数时候我们希望一些变量复用，所以就有了 get_variable()。</p>
<ul>
<li>tf.get_variable() 会根据 variable_scope 的模式不同而具有不同的行为，当 reuse=True 时，只想着复用，如果之前没有定义过这个变量则会报错；当 reuse=False 时只想着新建，如果之前定义过同名变量则会报错。 </li>
<li>tf.Variable() 只想着新建变量，不管 variable_scope 有没有设置共享变量， 都会新建变量，重名时会重命名。</li>
<li>tf.Variable 受 variable_scope 的命名空间的限制，但是由于自身的限制，不能对于 variable_scope 的 reuse=True 做出响应。</li>
<li>tf.get_variable() 不受 name_scope 的命名空间的限制。</li>
<li>name_scope 作用于运算，variable_scope 仅仅作用于变量。</li>
</ul>
<p>共享变量的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">with tf.variable_scope(&apos;foo&apos;) as foo_scope:</div><div class="line">    v = tf.get_variable(&apos;v&apos;, [1])</div><div class="line">with tf.variable_scope(&apos;foo&apos;, reuse=True):</div><div class="line">    v1 = tf.get_variable(&apos;v&apos;)</div><div class="line">assert v1 == v</div></pre></td></tr></table></figure></p>
<p>或者这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">with tf.variable_scope(&apos;foo&apos;) as foo_scope:</div><div class="line">    v = tf.get_variable(&apos;v&apos;, [1])</div><div class="line">with tf.variable_scope(foo_scope, reuse=True):</div><div class="line">    v1 = tf.get_variable(&apos;v&apos;)</div><div class="line">assert v1 == v</div></pre></td></tr></table></figure></p>
<h4 id="miscellaneous"><a href="#miscellaneous" class="headerlink" title="miscellaneous"></a>miscellaneous</h4><ul>
<li>var2:0 的意义是这个name为 var2 的运算（节点）的第一个结果</li>
<li>一个回合： 就是全部的训练集数据都参与了运算就算是一次。</li>
<li>Why does c = tf.matmul(a, b) not execute the matrix multiplication immediately?<br>In the TensorFlow Python API, a, b, and c are tf.Tensor objects. A Tensor object is a symbolic handle to the result of an operation, but does not actually hold the values of the operation’s output. Instead, TensorFlow encourages users to build up complicated expressions (such as entire neural networks and its gradients) as a dataflow graph. You then offload the computation of the entire dataflow graph (or a subgraph of it) to a TensorFlow tf.Session, which is able to execute the whole computation much more efficiently than executing the operations one-by-one.</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2017/12/05/Learning-Simpy-3/">
                Learning Simpy 3
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-12-05</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            
        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2017/11/21/Pandas-加载数据的I-O性能比较/">
                Pandas 加载数据的I/O性能比较
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-11-21</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="Pandas-加载数据的I-O性能比较"><a href="#Pandas-加载数据的I-O性能比较" class="headerlink" title="Pandas 加载数据的I/O性能比较"></a>Pandas 加载数据的I/O性能比较</h3><p>在使用阿里巴巴集群数据时，由于数据量比较大，对数据进行分析前加载数据需要花费较长的时间，因此测试了 Pandas 读取数据不同方法的 I/O 性能。<br>测试数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">batch_instance.csv 819M</div><div class="line"></div><div class="line">wc -l batch_instance.csv </div><div class="line">16094656 batch_instance.csv</div></pre></td></tr></table></figure></p>
<p>首先测试了 read_csv 和 read_sql_query (mysql) 的读取性能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import pandas as pd </div><div class="line">from sqlalchemy import create_engine</div><div class="line">import time</div><div class="line"></div><div class="line">tic = time.time()</div><div class="line">df = pd.read_csv(&quot;/home/shark/Codes/Sigma/batch_instance.csv&quot;)</div><div class="line">toc = time.time()</div><div class="line">print(&quot;read_csv costed &#123;:.3f&#125;s&quot;.format(toc - tic))</div><div class="line"></div><div class="line">engine = create_engine(&quot;mysql://root:lexis@localhost:3306/Alibaba&quot;)</div><div class="line">query = &quot;select * from batch_instance&quot;</div><div class="line">tic = time.time()</div><div class="line">df = pd.read_sql_query(query, engine)</div><div class="line">toc = time.time()</div><div class="line">print(&quot;read_sql_query costed &#123;:.3f&#125;s&quot;.format(toc - tic))</div></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">read_csv costed 12.897s</div><div class="line">read_sql_query costed 134.118s</div></pre></td></tr></table></figure></p>
<p>相比 read_csv ，read_sql_query 的速度要慢的很，这是因为此处做的是表扫描的工作，并不能充分发挥数据库的索引查询的强大功能。CSV 和 SQL 本来就不是用来做相同的工作的。<br>想象有一个从 1920 到 2017的时间序列，而你只需要从 2010 到 2017 的数据，CSV 的方式是将数据全部加载然后选择 2010 到 2017 年的数据，而SQL 是事先筛选数据然后再返回，如果将时间这一列设置为 index，会获得<strong>极大</strong>的性能提升。</p>
<p>下面是根据 Pandas 文档进行的测试：<br>test_pd_io.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> sqlite3</div><div class="line"><span class="keyword">from</span> pandas.io <span class="keyword">import</span> sql</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_sql_write</span><span class="params">(df)</span>:</span></div><div class="line">    <span class="keyword">if</span> os.path.exists(<span class="string">'test.sql'</span>):</div><div class="line">        os.remove(<span class="string">'test.sql'</span>)</div><div class="line">    sql_db = sqlite3.connect(<span class="string">'test.sql'</span>)</div><div class="line">    df.to_sql(name=<span class="string">'test_table'</span>, con=sql_db)</div><div class="line">    sql_db.close()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_sql_read</span><span class="params">()</span>:</span></div><div class="line">    sql_db = sqlite3.connect(<span class="string">'test.sql'</span>)</div><div class="line">    pd.read_sql_query(<span class="string">"select * from test_table"</span>, sql_db)</div><div class="line">    sql_db.close()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_hdf_fixed_write</span><span class="params">(df)</span>:</span></div><div class="line">    df.to_hdf(<span class="string">'test_fixed.hdf'</span>,<span class="string">'test'</span>,mode=<span class="string">'w'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_hdf_fixed_read</span><span class="params">()</span>:</span></div><div class="line">    pd.read_hdf(<span class="string">'test_fixed.hdf'</span>,<span class="string">'test'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_hdf_fixed_write_compress</span><span class="params">(df)</span>:</span></div><div class="line">    df.to_hdf(<span class="string">'test_fixed_compress.hdf'</span>,<span class="string">'test'</span>,mode=<span class="string">'w'</span>,complib=<span class="string">'blosc'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_hdf_fixed_read_compress</span><span class="params">()</span>:</span></div><div class="line">    pd.read_hdf(<span class="string">'test_fixed_compress.hdf'</span>,<span class="string">'test'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_hdf_table_write</span><span class="params">(df)</span>:</span></div><div class="line">    df.to_hdf(<span class="string">'test_table.hdf'</span>,<span class="string">'test'</span>,mode=<span class="string">'w'</span>,format=<span class="string">'table'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_hdf_table_read</span><span class="params">()</span>:</span></div><div class="line">    pd.read_hdf(<span class="string">'test_table.hdf'</span>,<span class="string">'test'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_hdf_table_write_compress</span><span class="params">(df)</span>:</span></div><div class="line">    df.to_hdf(<span class="string">'test_table_compress.hdf'</span>,<span class="string">'test'</span>,mode=<span class="string">'w'</span>,complib=<span class="string">'blosc'</span>,format=<span class="string">'table'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_hdf_table_read_compress</span><span class="params">()</span>:</span></div><div class="line">    pd.read_hdf(<span class="string">'test_table_compress.hdf'</span>,<span class="string">'test'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_csv_write</span><span class="params">(df)</span>:</span></div><div class="line">    df.to_csv(<span class="string">'test.csv'</span>,mode=<span class="string">'w'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_csv_read</span><span class="params">()</span>:</span></div><div class="line">    pd.read_csv(<span class="string">'test.csv'</span>,index_col=<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_feather_write</span><span class="params">(df)</span>:</span></div><div class="line">    df.to_feather(<span class="string">'test.feather'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_feather_read</span><span class="params">()</span>:</span></div><div class="line">    pd.read_feather(<span class="string">'test.feather'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_pickle_write</span><span class="params">(df)</span>:</span></div><div class="line">    df.to_pickle(<span class="string">'test.pkl'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_pickle_read</span><span class="params">()</span>:</span></div><div class="line">    pd.read_pickle(<span class="string">'test.pkl'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_pickle_write_compress</span><span class="params">(df)</span>:</span></div><div class="line">    df.to_pickle(<span class="string">'test.pkl.compress'</span>, compression=<span class="string">'xz'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_pickle_read_compress</span><span class="params">()</span>:</span></div><div class="line">    pd.read_pickle(<span class="string">'test.pkl.compress'</span>, compression=<span class="string">'xz'</span>)</div></pre></td></tr></table></figure></p>
<p>测试写性能：<br>ipython<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">In [2]: import pandas as pd</div><div class="line"></div><div class="line">In [3]: df = pd.read_csv(&quot;/home/shark/Codes/Sigma/batch_instance.csv&quot;)</div><div class="line"></div><div class="line">In [4]: from test_pd_io import *</div><div class="line"></div><div class="line">In [5]: %timeit test_sql_write(df)</div><div class="line">1 loop, best of 3: 2min 20s per loop</div><div class="line"></div><div class="line">In [6]: %timeit test_hdf_fixed_write(df)</div><div class="line">1 loop, best of 3: 6.14 s per loop</div><div class="line"></div><div class="line">In [7]: %timeit test_hdf_fixed_write_compress(df)</div><div class="line">1 loop, best of 3: 5.6 s per loop</div><div class="line"></div><div class="line">In [8]: %timeit test_hdf_table_write(df)</div><div class="line">1 loop, best of 3: 25.9 s per loop</div><div class="line"></div><div class="line">In [9]:  %timeit test_hdf_table_write_compress(df)</div><div class="line">1 loop, best of 3: 21.8 s per loop</div><div class="line"></div><div class="line">In [10]: %timeit test_csv_write(df)</div><div class="line">1 loop, best of 3: 2min 44s per loop</div><div class="line"></div><div class="line">In [11]: %timeit test_feather_write(df)</div><div class="line">1 loop, best of 3: 3.99 s per loop</div><div class="line"></div><div class="line">In [12]: %timeit test_pickle_write(df)</div><div class="line">1 loop, best of 3: 4.43 s per loop</div><div class="line"></div><div class="line">In [13]: %timeit test_pickle_write_compress(df)</div><div class="line">1 loop, best of 3: 6min 27s per loop</div></pre></td></tr></table></figure></p>
<p>测试读性能：<br>ipython<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">In [7]: %timeit test_sql_read()</div><div class="line">1 loop, best of 3: 1min 17s per loop</div><div class="line"></div><div class="line">In [8]: %timeit test_hdf_fixed_read()</div><div class="line">1 loop, best of 3: 972 ms per loop</div><div class="line"></div><div class="line">In [9]: %timeit test_hdf_fixed_read_compress()</div><div class="line">1 loop, best of 3: 2.41 s per loop</div><div class="line"></div><div class="line">In [10]: %timeit test_hdf_table_read()</div><div class="line">1 loop, best of 3: 17.5 s per loop</div><div class="line"></div><div class="line">In [11]: %timeit test_hdf_table_read_compress()</div><div class="line">1 loop, best of 3: 18.1 s per loop</div><div class="line"></div><div class="line">In [12]: %timeit test_csv_read()</div><div class="line">1 loop, best of 3: 17.1 s per loop</div><div class="line"></div><div class="line">In [13]: %timeit test_feather_read()</div><div class="line">1 loop, best of 3: 1.99 s per loop</div><div class="line"></div><div class="line">In [14]: %timeit test_pickle_read()</div><div class="line">1 loop, best of 3: 1.14 s per loop</div><div class="line"></div><div class="line">In [15]: %timeit test_pickle_read_compress()</div><div class="line">1 loop, best of 3: 9.72 s per loop</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>数据格式</th>
<th>空间</th>
<th>写性能</th>
<th>读性能</th>
</tr>
</thead>
<tbody>
<tr>
<td>test.csv</td>
<td>1.0G</td>
<td>2min 44s</td>
<td>17.1 s</td>
</tr>
<tr>
<td>test.feather</td>
<td>1.6G</td>
<td><strong>3.99 s</strong></td>
<td>1.99 s</td>
</tr>
<tr>
<td>test_fixed_compress.hdf</td>
<td>423M</td>
<td>5.6 s</td>
<td>2.41 s</td>
</tr>
<tr>
<td>test_fixed.hdf</td>
<td>1.6G</td>
<td>6.14 s</td>
<td><strong>972 ms</strong></td>
</tr>
<tr>
<td>test.pkl</td>
<td>1.4G</td>
<td>4.43 s</td>
<td>1.14 s</td>
</tr>
<tr>
<td>test.pkl.compress</td>
<td>66M</td>
<td>6min 27s</td>
<td>9.72 s</td>
</tr>
<tr>
<td>test.sql</td>
<td>1.2G</td>
<td>2min 20s</td>
<td>1min 17s</td>
</tr>
<tr>
<td>test_table_compress.hdf</td>
<td>299M</td>
<td>21.8 s</td>
<td>18.1 s</td>
</tr>
<tr>
<td>test_table.hdf</td>
<td>1.7G</td>
<td>25.9 s</td>
<td>17.5 s</td>
</tr>
</tbody>
</table>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2017/11/20/Alibaba-集群数据导入MySQL数据库/">
                Alibaba 集群数据导入MySQL数据库
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-11-20</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="Alibaba-集群数据导入MySQL数据库"><a href="#Alibaba-集群数据导入MySQL数据库" class="headerlink" title="Alibaba-集群数据导入MySQL数据库"></a>Alibaba-集群数据导入MySQL数据库</h2><h3 id="安装-MySQL-数据库"><a href="#安装-MySQL-数据库" class="headerlink" title="安装 MySQL 数据库"></a>安装 MySQL 数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install mysql-server </div><div class="line">密码：lexis</div><div class="line">sudo apt-get install mysql-client</div><div class="line">sudo apt-get install libmysqlclient-dev</div></pre></td></tr></table></figure>
<p>检查是否安装成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">sudo netstat -tap | grep mysqld</div><div class="line">输出：</div><div class="line">tcp        0      0 localhost:mysql         *:*                     LISTEN      21248/mysqld</div><div class="line"></div><div class="line">mysql -u root -p</div><div class="line">show databases;</div><div class="line">输出：</div><div class="line">+--------------------+</div><div class="line">| Database           |</div><div class="line">+--------------------+</div><div class="line">| information_schema |</div><div class="line">| mysql              |</div><div class="line">| performance_schema |</div><div class="line">| sys                |</div><div class="line">+--------------------+</div><div class="line">4 rows in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>安装 python-mysqldb, <code>sudo apt-get install python-mysqldb</code></p>
<h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><ol>
<li><p><code>mysql&gt; create database Alibaba;</code></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">show databases;</div><div class="line">+--------------------+</div><div class="line">| Database           |</div><div class="line">+--------------------+</div><div class="line">| information_schema |</div><div class="line">| Alibaba            |</div><div class="line">| mysql              |</div><div class="line">| performance_schema |</div><div class="line">| sys                |</div><div class="line">+--------------------+</div><div class="line">5 rows in set (0.00 sec)</div></pre></td></tr></table></figure>
</li>
<li><p>新建 batch_instance 表</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">mysql&gt; use Alibaba;</div><div class="line">CREATE TABLE `batch_instance`(</div><div class="line">   `start_timestamp` INT NOT NULL,</div><div class="line">   `end_timestamp` INT,</div><div class="line">   `job_id` INT NOT NULL,</div><div class="line">   `task_id` INT NOT NULL,</div><div class="line">   `machine_id` INT NOT NULL,</div><div class="line">   `status` VARCHAR(30) NOT NULL,</div><div class="line">   `sequence_number` INT NOT NULL,</div><div class="line">   `total_sequence_number` INT NOT NULL,</div><div class="line">   `maximum_real_cpu_number` FLOAT,</div><div class="line">   `average_real_cpu_number` FLOAT,</div><div class="line">   `maximum_normalized_memory_usage` FLOAT,</div><div class="line">   `average_normalized_memory_usage` FLOAT</div><div class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</div></pre></td></tr></table></figure>
<p> 检查 batch_instance 表新建成功</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mysql&gt; show tables;</div><div class="line">+-------------------+</div><div class="line">| Tables_in_Alibaba |</div><div class="line">+-------------------+</div><div class="line">| batch_instance    |</div><div class="line">+-------------------+</div><div class="line">1 row in set (0.00 sec)</div></pre></td></tr></table></figure>
<p> 导入数据</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LOAD DATA LOCAL INFILE &apos;/home/shark/Codes/Sigma/batch_instance.csv&apos; INTO TABLE batch_instance FIELDS TERMINATED BY &apos;,&apos; LINES TERMINATED BY &apos;\n&apos;;</div><div class="line">Query OK, 16094656 rows affected, 65535 warnings (1 min 44.68 sec)</div><div class="line">Records: 16094656  Deleted: 0  Skipped: 0  Warnings: 42434301</div></pre></td></tr></table></figure>
</li>
<li><p>新建 batch_task 表</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `batch_task`(</div><div class="line">    `task_create_time` INT NOT NULL,</div><div class="line">    `task_end_time` INT NOT NULL,</div><div class="line">    `job_id` INT NOT NULL,</div><div class="line">    `task_id` INT NOT NULL,</div><div class="line">    `number_of_instances` INT NOT NULL,</div><div class="line">    `status` VARCHAR(30) NOT NULL,</div><div class="line">    `number_of_cpus_requested_per_instance_in_the_task` INT NOT NULL,</div><div class="line">    `normalized_memory_requested_per_instance_in_the_task` DOUBLE NOT NULL</div><div class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</div></pre></td></tr></table></figure>
<p> 导入数据</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LOAD DATA LOCAL INFILE &apos;/home/shark/Codes/Sigma/batch_task.csv&apos; INTO TABLE batch_task FIELDS TERMINATED BY &apos;,&apos; LINES TERMINATED BY &apos;\n&apos;;</div><div class="line">Query OK, 80553 rows affected, 18034 warnings (0.48 sec)</div><div class="line">Records: 80553  Deleted: 0  Skipped: 0  Warnings: 18034</div><div class="line">这里的 18034 个警告是因为阿里巴巴给出的 schema 描述中 `number_of_cpus_requested_per_instance_in_the_task` 和 `normalized_memory_requested_per_instance_in_the_task` 是强制非空的，我也是这样建的表，但是实际上在 batch_task.csv 是存在 9017 个这两个数据对为空的，因此共 9017 * 2 = 18034 个警告。</div></pre></td></tr></table></figure>
</li>
<li><p>新建 container_event 表</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `container_event`(</div><div class="line">    `timestamp` INT NOT NULL,</div><div class="line">    `event_type` VARCHAR(30) NOT NULL,</div><div class="line">    `instance_id` INT NOT NULL,</div><div class="line">    `machine_id` INT NOT NULL,</div><div class="line">    `number_of_cpu_requested` INT NOT NULL,</div><div class="line">    `normalized_memory_requested` FLOAT NOT NULL,</div><div class="line">    `normalized_disk_space_requested` FLOAT NOT NULL,</div><div class="line">    `cpu_id_of_allocated_cpus` VARCHAR(100) NOT NULL</div><div class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</div></pre></td></tr></table></figure>
<p> 导入数据</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LOAD DATA LOCAL INFILE &apos;/home/shark/Codes/Sigma/container_event.csv&apos; INTO TABLE container_event FIELDS TERMINATED BY &apos;,&apos; LINES TERMINATED BY &apos;\n&apos;;</div><div class="line">Query OK, 11102 rows affected (0.14 sec)</div><div class="line">Records: 11102  Deleted: 0  Skipped: 0  Warnings: 0</div></pre></td></tr></table></figure>
</li>
<li><p>新建 container_usage 表</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `container_usage`(</div><div class="line">    `start_time_of_measurement_interval` INT NOT NULL,</div><div class="line">    `online_instance_id` INT NOT NULL,</div><div class="line">    `used_percent_of_requested_cpus` FLOAT NOT NULL,</div><div class="line">    `used_percent_of_requested_memory` FLOAT NOT NULL,</div><div class="line">    `used_percent_of_requested_disk_space` FLOAT,</div><div class="line">    `linux_cpu_load_average_of_1_minute` FLOAT NOT NULL,</div><div class="line">    `linux_cpu_load_average_of_5_minute` FLOAT NOT NULL,</div><div class="line">    `linux_cpu_load_average_of_15_minute` FLOAT NOT NULL,</div><div class="line">    `averaged_cycles_per_instruction` FLOAT,</div><div class="line">    `average_last_level_cache_misses_per_1000_instructions` FLOAT,</div><div class="line">    `maximum_cycles_per_instruction` FLOAT,</div><div class="line">    `maximum_last_level_cache_misses_per_1000_instructions` FLOAT</div><div class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</div></pre></td></tr></table></figure>
<p> 导入数据</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LOAD DATA LOCAL INFILE &apos;/home/shark/Codes/Sigma/container_usage.csv&apos; INTO TABLE container_usage FIELDS TERMINATED BY &apos;,&apos; LINES TERMINATED BY &apos;\n&apos;;</div><div class="line">Query OK, 1480906 rows affected, 23 warnings (13.77 sec)</div><div class="line">Records: 1480906  Deleted: 0  Skipped: 0  Warnings: 23</div></pre></td></tr></table></figure>
</li>
<li><p>新建 server_event 表</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `server_event`(</div><div class="line">    `timestamp` INT NOT NULL,</div><div class="line">    `machine_id` INT NOT NULL,</div><div class="line">    `event_type` VARCHAR(30) NOT NULL,</div><div class="line">    `event_detail` VARCHAR(30),</div><div class="line">    `number_of_cpus` INT,</div><div class="line">    `normalized_memory` FLOAT,</div><div class="line">    `normalized_disk_space` FLOAT</div><div class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</div></pre></td></tr></table></figure>
<p> 导入数据</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LOAD DATA LOCAL INFILE &apos;/home/shark/Codes/Sigma/server_event.csv&apos; INTO TABLE server_event FIELDS TERMINATED BY &apos;,&apos; LINES TERMINATED BY &apos;\n&apos;;</div><div class="line">Query OK, 1352 rows affected (0.02 sec)</div><div class="line">Records: 1352  Deleted: 0  Skipped: 0  Warnings: 0</div></pre></td></tr></table></figure>
</li>
<li><p>新建 server_usage 表</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE `server_usage`(</div><div class="line">    `timestamp` INT NOT NULL,</div><div class="line">    `machine_id` INT NOT NULL,</div><div class="line">    `used_percent_of_cpus` FLOAT NOT NULL,</div><div class="line">    `used_percent_of_memory` FLOAT NOT NULL,</div><div class="line">    `used_percent_of_disk_space` FLOAT NOT NULL,</div><div class="line">    `linux_cpu_load_average_of_1_minute` INT NOT NULL,</div><div class="line">    `linux_cpu_load_average_of_5_minute` FLOAT NOT NULL,</div><div class="line">    `linux_cpu_load_average_of_15_minute` FLOAT NOT NULL</div><div class="line">)ENGINE=InnoDB DEFAULT CHARSET=utf8;</div></pre></td></tr></table></figure>
<p> 导入数据</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LOAD DATA LOCAL INFILE &apos;/home/shark/Codes/Sigma/server_usage.csv&apos; INTO TABLE server_usage FIELDS TERMINATED BY &apos;,&apos; LINES TERMINATED BY &apos;\n&apos;;</div><div class="line">Query OK, 187963 rows affected, 5 warnings (1.03 sec)</div><div class="line">Records: 187963  Deleted: 0  Skipped: 0  Warnings: 5</div></pre></td></tr></table></figure></li>
</ol>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2017/11/20/仿真系统：A-Dynamic-Service-Allocation-Algorithm-in-Mobile-Edge-Computing-for-ICTC-2017/">
                仿真系统：A Dynamic Service Allocation Algorithm in Mobile Edge Computing for ICTC 2017
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-11-20</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">system 模块</div><div class="line">|</div><div class="line">+-  system.CommonObject</div><div class="line">|   |</div><div class="line">|   +- system.Machine</div><div class="line">|   |   |</div><div class="line">|   |   +- system.Backend</div><div class="line">|   |</div><div class="line">|   +- system.Service</div><div class="line">|   |</div><div class="line">|   +- system.Request</div><div class="line">|   |</div><div class="line">|   +- system.District</div><div class="line">|</div><div class="line">+- system.Simulator</div><div class="line">|</div><div class="line">+- ram_generator_factory</div><div class="line">|</div><div class="line">+- bandwidth_generator_factory</div><div class="line">|</div><div class="line">+- request_generator_factory</div><div class="line">|</div><div class="line">+- position_generator_factory</div><div class="line"></div><div class="line"></div><div class="line">dispatcher 模块</div><div class="line">|</div><div class="line">+- dispatcher.Dispatcher</div><div class="line"></div><div class="line">naive_dispatcher 模块</div><div class="line">|</div><div class="line">+- naive_dispatcher.NaiveDispatcher</div><div class="line"></div><div class="line">random_dispatcher 模块</div><div class="line">+- random_dispatcher.RandomDispatcher</div></pre></td></tr></table></figure>
<ol>
<li><code>system.CommonObject</code> 提供唯一 id 标识的基类。继承该基类的子类都能获得唯一 id 标识的 <code>setter</code> 和 <code>getter</code>。</li>
<li><p><code>system.Machine</code> 具有内存（<code>_ram</code>），带宽(<code>_bandwidth</code>)，位置(<code>_position</code>)等固有属性，机器的当前状态是通过维护<br>当前可用内存、可用带宽、请求队列、服务中请求列表、外派请求列表、可用服务池等进行更新的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">system.Machine</div><div class="line">|</div><div class="line">+- receive_request 接受请求，更新请求队列</div><div class="line">+- serve_request 服务请求，更新请求队列，服务中请求列表，带宽等</div><div class="line">+- stop_serving_request 停止服务请求，更新请求队列，服务中请求列表，带宽等</div><div class="line">+- deploy_service 部署服务，更新可用服务池，内存等。</div><div class="line">+- undeploy_service 卸载服务，更新可用服务池，内存等。</div><div class="line">+- send_request 将请求发送出去，更新请求列表和外派请求列表</div><div class="line">+- find_nearest_machine 寻找“临近”机器并使用 send_request 将请求发送至其他机器或者后台进行处理</div></pre></td></tr></table></figure>
</li>
<li><p><code>system.Backend</code> 是资源和处理能力无限的“机器”。</p>
</li>
<li><p><code>system.Service</code> 具有消耗内存（<code>_ram</code>），消耗带宽（<code>_bandwidth</code>）等固有属性，服务的部署机器列表（<code>_deployment</code>)会随着部署和卸载而更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">system.Service</div><div class="line">|</div><div class="line">+- deploy</div><div class="line">|</div><div class="line">+- undeploy</div></pre></td></tr></table></figure>
</li>
<li><p><code>system.Request</code> 具有请求者（<code>_source</code>），请求目标机器（<code>_machine</code>），请求服务（<code>_service</code>）等属性。</p>
</li>
<li><code>system.District</code> 具有主机（<code>_master</code>）和从机列表（<code>_slaves</code>）等固有属性，可以通过方法 <code>add_slave</code> 将某个机器加入从机列表从而将这个机器加入这个区域划分。类方法 <code>average_load</code> 可以计算所有区域的平均负载。</li>
<li><code>system.Simulator</code>搭建了整个仿真的环境，按照给定的分布和数量实例化了机器，服务，请求，区域等，为进行调度算法的测试做好了准备。</li>
<li><code>naive_dispatcher.NaiveDispatcher</code> 实现了一个朴素调度器，通过 <code>service_deploy</code> 方法按照服务的热度从高到低将服务部署到对该服务请求最多的机器上。</li>
<li><code>random_dispatcher.RandomDispatcher</code> 实现了一个随机调度器，通过 <code>service_deploy</code> 方法将服务随机部署到各个机器上。</li>
<li><p><code>dispatcher.Dispatcher</code> 实现了一个调度器，可以通过传入一个 <code>system.Simulator</code> 对象，实例化一个调度器，调度器的调度算法分为两个阶段 <code>stage_1</code> 和 <code>stage_2</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">dispatcher.Dispatcher</div><div class="line">|</div><div class="line">+- stage_1</div><div class="line">+- stage_2</div><div class="line">+- machine_slave_dispatch_round_0</div><div class="line">+- machine_slave_dispatch_round_1</div><div class="line">+- machine_slave_dispatch_round_2</div></pre></td></tr></table></figure>
<ol>
<li><p><code>dispatcher.Dispatcher.stage_1</code> 完成区域的划分并将各个机器划入不同的区域。</p>
<ul>
<li><code>dispatcher.Dispatcher.machine_slave_dispatch_round_0</code> 根据机器的负载选出 <code>machine_master_num</code> 个主机并围绕这些主机进行区域的划分。</li>
<li><p><code>dispatcher.Dispatcher.machine_slave_dispatch_round_1</code>将未被选中作为主机的机器分配进各个区域。<br>首先找出最空闲的区域，并找出与其最邻近的一台未分配机器，如果这台机器的划入不会引起该区域负载高于所有区域的平均负载，则将其指定为该区域的从机并划入该区域，否则将这台机器指定为重负载机器并加入繁忙机器列表，即该机器划入区域失败。</p>
</li>
<li><p><code>dispatcher.Dispatcher.machine_slave_dispatch_round_2</code>对于<code>dispatcher.Dispatcher.machine_slave_dispatch_round_1</code>划入区域失败的机器找到其最邻近的区域并划入。</p>
</li>
</ul>
</li>
<li><p><code>dispatcher.Dispatcher.stage_2</code> 在各个区域将服务部署到各个机器<br>通过 <code>get_service_spots_num_in_district</code> 方法得到一个服务需要部署的机器数目，通过 Dispatcher 的静态方法 <code>init_service_server_in_district</code> 将服务部署到允许部署且对该服务请求最热的机器上，从而完成服务的服务器初始化。</p>
</li>
<li><code>dispatcher.Dispatcher.stage_2_ergodic</code> 在 <code>dispatcher.Dispatcher.stage_2</code> 的基础上在每个区域中进行服务的服务器微调。</li>
</ol>
</li>
</ol>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2017/11/20/Learning-Simpy-2/">
                Learning Simpy 2
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-11-20</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="SimPy-基础"><a href="#SimPy-基础" class="headerlink" title="SimPy 基础"></a>SimPy 基础</h3><h4 id="进程间交互"><a href="#进程间交互" class="headerlink" title="进程间交互"></a>进程间交互</h4><ol>
<li><p>睡眠直至被唤醒<br> Imagine you want to model an electric vehicle with an intelligent battery-charging controller. While the vehicle is driving, the controller can be passive but needs to be reactivate once the vehicle is connected to the power grid in order to charge the battery.</p>
<p> In SimPy 2, this pattern was known as passivate / reactivate. In SimPy 3, you can accomplish that with a simple, <strong>shared <code>Event</code></strong>:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">from random import seed, randint</div><div class="line">seed(23)</div><div class="line">import simpy</div><div class="line">class EV:</div><div class="line">    def __init__(self, env):</div><div class="line">        self.env = env</div><div class="line">        self.drive_proc = env.process(self.drive(env))</div><div class="line">        self.bat_ctrl_proc = env.process(self.bat_ctrl(env))</div><div class="line">        self.bat_ctrl_reactivate = env.event()</div><div class="line"></div><div class="line">    def drive(self, env):</div><div class="line">        while True:</div><div class="line">            # Drive for 20-40 min</div><div class="line">            yield env.timeout(randint(20, 40))</div><div class="line"></div><div class="line">            # Park for 1–6 hours</div><div class="line">            print(&apos;Start parking at&apos;, env.now)</div><div class="line">            self.bat_ctrl_reactivate.succeed()  # &quot;reactivate&quot;</div><div class="line">            self.bat_ctrl_reactivate = env.event()</div><div class="line">            yield env.timeout(randint(60, 360))</div><div class="line">            print(&apos;Stop parking at&apos;, env.now)</div><div class="line"></div><div class="line">    def bat_ctrl(self, env):</div><div class="line">        while True:</div><div class="line">            print(&apos;Bat. ctrl. passivating at&apos;, env.now)</div><div class="line">            yield self.bat_ctrl_reactivate  # &quot;passivate&quot;</div><div class="line">            print(&apos;Bat. ctrl. reactivated at&apos;, env.now)</div><div class="line"></div><div class="line">            # Intelligent charging behavior here …</div><div class="line">            yield env.timeout(randint(30, 90))</div><div class="line"></div><div class="line">env = simpy.Environment()</div><div class="line">ev = EV(env)</div><div class="line">env.run(until=150)</div><div class="line"></div><div class="line">Bat. ctrl. passivating at 0</div><div class="line">Start parking at 29</div><div class="line">Bat. ctrl. reactivated at 29</div><div class="line">Bat. ctrl. passivating at 60</div><div class="line">Stop parking at 131</div><div class="line">[Finished in 0.4s]</div></pre></td></tr></table></figure>
</li>
<li><p>等待另一个进程结束<br> The example above has a problem: it may happen that the vehicles wants to park for a shorter duration than it takes to charge the battery (this is the case if both, charging and parking would take 60 to 90 minutes).</p>
<p> To fix this problem we have to slightly change our model. A new bat_ctrl() will be started every time the EV starts parking. The EV then waits until the parking duration is over <strong>and</strong> until the charging has stopped:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">from random import seed, randint</div><div class="line">seed(23)</div><div class="line">import simpy</div><div class="line">class EV:</div><div class="line">    def __init__(self, env):</div><div class="line">        self.env = env</div><div class="line">        self.drive_proc = env.process(self.drive(env))</div><div class="line"></div><div class="line">    def drive(self, env):</div><div class="line">        while True:</div><div class="line">            # Drive for 20-40 min</div><div class="line">            yield env.timeout(randint(20, 40))</div><div class="line"></div><div class="line">            # Park for 1–6 hours</div><div class="line">            print(&apos;Start parking at&apos;, env.now)</div><div class="line">            charging = env.process(self.bat_ctrl(env))</div><div class="line">            parking = env.timeout(randint(60, 360))</div><div class="line">            yield charging &amp; parking</div><div class="line">            print(&apos;Stop parking at&apos;, env.now)</div><div class="line"></div><div class="line">    def bat_ctrl(self, env):</div><div class="line">        print(&apos;Bat. ctrl. started at&apos;, env.now)</div><div class="line">        # Intelligent charging behavior here …</div><div class="line">        yield env.timeout(randint(30, 90))</div><div class="line">        print(&apos;Bat. ctrl. done at&apos;, env.now)</div><div class="line"></div><div class="line">env = simpy.Environment()</div><div class="line">ev = EV(env)</div><div class="line">env.run(until=310)</div><div class="line"></div><div class="line">Start parking at 29</div><div class="line">Bat. ctrl. started at 29</div><div class="line">Bat. ctrl. done at 60</div><div class="line">Stop parking at 131</div><div class="line">Start parking at 169</div><div class="line">Bat. ctrl. started at 169</div><div class="line">Bat. ctrl. done at 226</div><div class="line">[Finished in 0.2s]</div></pre></td></tr></table></figure>
</li>
<li><p>中断其他的进程<br> As usual, we now have another problem: Imagine, a trip is very urgent, but with the current implementation, we always need to wait until the battery is fully charged. If we could somehow interrupt that …</p>
<p> Fortunate coincidence, there is indeed a way to do exactly this. You can call interrupt() on a Process. This will throw an Interrupt exception <strong>into</strong> that process, resuming it immediately:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">class EV:</div><div class="line">    def __init__(self, env):</div><div class="line">        self.env = env</div><div class="line">        self.drive_proc = env.process(self.drive(env))</div><div class="line"></div><div class="line">    def drive(self, env):</div><div class="line">        while True:</div><div class="line">            # Drive for 20-40 min</div><div class="line">            yield env.timeout(randint(20, 40))</div><div class="line"></div><div class="line">            # Park for 1 hour</div><div class="line">            print(&apos;Start parking at&apos;, env.now)</div><div class="line">            charging = env.process(self.bat_ctrl(env))</div><div class="line">            parking = env.timeout(60)</div><div class="line">            yield charging | parking</div><div class="line">            if not charging.triggered:</div><div class="line">                # Interrupt charging if not already done.</div><div class="line">                charging.interrupt(&apos;Need to go!&apos;)</div><div class="line">            print(&apos;Stop parking at&apos;, env.now)</div><div class="line"></div><div class="line">    def bat_ctrl(self, env):</div><div class="line">        print(&apos;Bat. ctrl. started at&apos;, env.now)</div><div class="line">        try:</div><div class="line">            yield env.timeout(randint(60, 90))</div><div class="line">            print(&apos;Bat. ctrl. done at&apos;, env.now)</div><div class="line">        except simpy.Interrupt as i:</div><div class="line">            # Onoes! Got interrupted before the charging was done.</div><div class="line">            print(&apos;Bat. ctrl. interrupted at&apos;, env.now, &apos;msg:&apos;,</div><div class="line">                  i.cause)</div><div class="line"></div><div class="line">env = simpy.Environment()</div><div class="line">ev = EV(env)</div><div class="line">env.run(until=100)</div><div class="line"></div><div class="line">Start parking at 29</div><div class="line">Bat. ctrl. started at 29</div><div class="line">Stop parking at 89</div><div class="line">Bat. ctrl. interrupted at 89 msg: Need to go!</div><div class="line">[Finished in 0.2s]</div></pre></td></tr></table></figure>
<p> What <code>process.interrupt()</code> actually does is scheduling an <code>Interruption</code> event for immediate execution. If this event is executed it will remove the victim process’ <code>_resume()</code> method from the callbacks of the event that it is currently waiting for (see <a href="http://simpy.readthedocs.io/en/latest/api_reference/simpy.events.html#simpy.events.Process.target" target="_blank" rel="external">target</a>). 这里的受害者进程就是 bat_ctrl，将它的<code>_resume()</code>方法从它正在等待的事件（超时事件）中移除，这是为了防止当超时事件被处理完毕后（processed为True，超时事件会自我调度并触发，这里等待的是超时事件从事件队列中出队进行处理并处理完毕）再次恢复执行受害者进程。Following that it will throw the <code>Interrupt</code> exception into the process.<br> Since we don’t do anything special to the original target event of the process, the interrupted process can yield the same event again after catching the Interrupt – Imagine someone waiting for a shop to open. The person may get interrupted by a phone call. After finishing the call, he or she checks if the shop already opened and either enters or continues to wait.</p>
</li>
</ol>
<h4 id="共享资源"><a href="#共享资源" class="headerlink" title="共享资源"></a>共享资源</h4><p>Shared resources are another way to model <strong>Process Interaction</strong>. They form a <strong>congestion point</strong> where processes queue up in order to use them.</p>
<p>SimPy defines three categories of resources:</p>
<ul>
<li>Resources – Resources that can be used by a limited number of processes at a time (e.g., a gas station with a limited number of fuel pumps).</li>
<li>Containers – Resources that model the production and consumption of a homogeneous, undifferentiated bulk. It may either be continuous (like water) or discrete (like apples).</li>
<li>Stores – Resources that allow the production and consumption of Python objects.</li>
</ul>
<ol>
<li><p>The basic concept of resources<br> All resources share the same basic concept: The resource itself is some kind of a container with a, usually limited, capacity. Processes can either try to put something into the resource or try to get something out. If the resource is full or empty, they have to queue up and wait.</p>
<p> This is roughly how every resource looks:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">BaseResource(capacity):</div><div class="line">   put_queue</div><div class="line">   get_queue</div><div class="line"></div><div class="line">   put(): event</div><div class="line">   get(): event</div></pre></td></tr></table></figure>
<p> Every resource has a maximum capacity and two queues: one for processes that want to put something into it and one for processes that want to get something out. The put() and get() methods both return an event that is triggered when the corresponding action was successful.</p>
</li>
<li><p>Resources and interrupts<br> While a process is waiting for a put or get event to succeed, it may be interrupted by another process. After catching the interrupt, the process has two possibilities:</p>
<ol>
<li>It may continue to wait for the request (by yielding the event again).</li>
<li><p>It may stop waiting for the request. In this case, it has to call the event’s cancel() method.</p>
<p>Since you can easily forget this, all resources events are context managers (see the Python docs for details).<br>The resource system is modular and extensible. Resources can, for example, use specialized queues and event types. This allows them to use sorted queues, to add priorities to events, or to offer preemption.</p>
</li>
</ol>
</li>
<li><p>Resources<br> Resources can be used by a limited number of processes at a time (e.g., a gas station with a limited number of fuel pumps). Processes request these resources to become a user (or to “own” them) and have to release them once they are done (e.g., vehicles arrive at the gas station, use a fuel-pump, if one is available, and leave when they are done).</p>
<p> Requesting a resource is modeled as “putting a process’ token into the resource” and releasing a resource correspondingly as “getting a process’ token out of the resource”. Thus, calling request()/release() is equivalent to calling put()/get(). Releasing a resource will always succeed immediately.</p>
<p> SimPy implements three resource types:</p>
<ol>
<li>Resource</li>
<li>PriorityResource, where queueing processes are sorted by priority</li>
<li>PreemptiveResource, where processes additionally may preempt other processes with a lower priority</li>
</ol>
</li>
<li><p>Resource<br> The Resource is conceptually a semaphore. Its only parameter – apart from the obligatory reference to an Environment – is its capacity. It must be a positive number and defaults to 1: Resource(env, capacity=1).</p>
<p> Instead of just counting its current users, it stores the request event as an “access token” for each user. This is, for example, useful for adding preemption (see below).</p>
<p> Here is a basic example for using a resource:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def resource_user(env, resource):</div><div class="line">    request = resource.request()  # Generate a request event</div><div class="line">    yield request                 # Wait for access</div><div class="line">    yield env.timeout(1)          # Do something</div><div class="line">    resource.release(request)     # Release the resource</div><div class="line"></div><div class="line">env = simpy.Environment()</div><div class="line">res = simpy.Resource(env, capacity=1)</div><div class="line">user = env.process(resource_user(env, res))</div><div class="line">env.run()</div></pre></td></tr></table></figure>
<p> Note, that you have to release the resource under all conditions; for example, if you got interrupted while <strong>waiting for</strong>（下面代码中的 yield req） or <strong>using</strong>（下面代码中的 yield env.timeout(1)）the resource. In order to help you with that and to avoid too many try: … finally: … constructs, request events can be used as context manager:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def resource_user(env, resource):</div><div class="line">    with resource.request() as req:  # Generate a request event</div><div class="line">        yield req                    # Wait for access</div><div class="line">        yield env.timeout(1)         # Do something</div><div class="line">                                     # Resource released automatically</div><div class="line">user = env.process(resource_user(env, res))</div><div class="line">env.run()</div></pre></td></tr></table></figure>
<p> Resources allow you to retrieve lists of the current users or queued users, the number of current users and the resource’s capacity:<br> 下面的代码修改自官方文档，更加清晰地展示了整个仿真过程</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">import simpy</div><div class="line">env = simpy.Environment()</div><div class="line">res = simpy.Resource(env, capacity=1)</div><div class="line"></div><div class="line">def print_stats(nth, res):</div><div class="line">    print(&apos;%dth user process: %d of %d slots are allocated.&apos; % (nth, res.count, res.capacity))</div><div class="line">    print(&apos;%dth user process: Users: &apos; %nth, res.users)</div><div class="line">    print(&apos;%dth user process: Queued events: &apos; %nth, res.queue)</div><div class="line"></div><div class="line"></div><div class="line">def user(res, nth):</div><div class="line">    print_stats(nth, res)</div><div class="line">    with res.request() as req:</div><div class="line">        yield req</div><div class="line">        print_stats(nth, res)</div><div class="line">    print_stats(nth, res)</div><div class="line"></div><div class="line">procs = [env.process(user(res, 0)), env.process(user(res, 1))]</div><div class="line">env.run()</div><div class="line"></div><div class="line">0th user process: 0 of 1 slots are allocated.</div><div class="line">0th user process: Users:  []</div><div class="line">0th user process: Queued events:  []</div><div class="line">1th user process: 1 of 1 slots are allocated.</div><div class="line">1th user process: Users:  [&lt;Request() object at 0x23d1bdf0a90&gt;]</div><div class="line">1th user process: Queued events:  []</div><div class="line">0th user process: 1 of 1 slots are allocated.</div><div class="line">0th user process: Users:  [&lt;Request() object at 0x23d1bdf0a90&gt;]</div><div class="line">0th user process: Queued events:  [&lt;Request() object at 0x23d1bdf0080&gt;]</div><div class="line">0th user process: 0 of 1 slots are allocated.</div><div class="line">0th user process: Users:  []</div><div class="line">0th user process: Queued events:  [&lt;Request() object at 0x23d1bdf0080&gt;]</div><div class="line">1th user process: 1 of 1 slots are allocated.</div><div class="line">1th user process: Users:  [&lt;Request() object at 0x23d1bdf0080&gt;]</div><div class="line">1th user process: Queued events:  []</div><div class="line">1th user process: 0 of 1 slots are allocated.</div><div class="line">1th user process: Users:  []</div><div class="line">1th user process: Queued events:  []</div><div class="line">[Finished in 0.2s]</div></pre></td></tr></table></figure>
</li>
<li><p>PriorityResource<br> Priority is expressed by integer numbers; smaller numbers mean a higher priority.</p>
</li>
<li><p>PreemptiveResource<br> Sometimes, new requests are so important that queue-jumping is not enough and they need to kick existing users out of the resource (this is called preemption). The PreemptiveResource allows you to do exactly this</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">import simpy</div><div class="line">def resource_user(name, env, resource, wait, prio):</div><div class="line">    yield env.timeout(wait)</div><div class="line">    with resource.request(priority=prio) as req:</div><div class="line">        print(&apos;%s requesting at %s with priority=%s&apos; % (name, env.now, prio))</div><div class="line">        yield req</div><div class="line">        print(&apos;%s got resource at %s&apos; % (name, env.now))</div><div class="line">        try:</div><div class="line">            yield env.timeout(3)</div><div class="line">        except simpy.Interrupt as interrupt:</div><div class="line">            by = interrupt.cause.by</div><div class="line">            usage = env.now - interrupt.cause.usage_since</div><div class="line">            print(&apos;%s got preempted by %s at %s after %s&apos; %</div><div class="line">                  (name, by, env.now, usage))</div><div class="line"></div><div class="line">env = simpy.Environment()</div><div class="line">res = simpy.PreemptiveResource(env, capacity=1)</div><div class="line">p1 = env.process(resource_user(1, env, res, wait=0, prio=0))</div><div class="line">p2 = env.process(resource_user(2, env, res, wait=1, prio=0))</div><div class="line">p3 = env.process(resource_user(3, env, res, wait=2, prio=-1))</div><div class="line">env.run()</div><div class="line"></div><div class="line">1 requesting at 0 with priority=0</div><div class="line">1 got resource at 0</div><div class="line">2 requesting at 1 with priority=0</div><div class="line">3 requesting at 2 with priority=-1</div><div class="line">1 got preempted by &lt;Process(resource_user) object at 0x298f124e128&gt; at 2 after 2</div><div class="line">3 got resource at 2</div><div class="line">2 got resource at 5</div><div class="line">[Finished in 0.2s]</div></pre></td></tr></table></figure>
<p> <code>PreemptiveResource</code> inherits from <code>PriorityResource</code> and adds a <code>preempt</code> flag (that defaults to <code>True</code>) to request(). By setting this to False (resource.request(priority=x, preempt=False)), a process can decide to not preempt another resource user. It will still be put in the queue according to its priority, though.</p>
<p> The implementation of <code>PreemptiveResource</code> <strong>values priorities higher than preemption</strong>. That means preempt requests are not allowed to cheat and jump over a higher prioritized request.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">import simpy</div><div class="line">def user(name, env, res, prio, preempt):</div><div class="line">    with res.request(priority=prio, preempt=preempt) as req:</div><div class="line">        try:</div><div class="line">            print(&apos;%s requesting at %d&apos; % (name, env.now))</div><div class="line">            yield req</div><div class="line">            print(&apos;%s got resource at %d&apos; % (name, env.now))</div><div class="line">            yield env.timeout(3)</div><div class="line">        except simpy.Interrupt:</div><div class="line">            print(&apos;%s got preempted at %d&apos; % (name, env.now))</div><div class="line"></div><div class="line">env = simpy.Environment()</div><div class="line">res = simpy.PreemptiveResource(env, capacity=1)</div><div class="line">A = env.process(user(&apos;A&apos;, env, res, prio=0, preempt=True))</div><div class="line">env.run(until=1)  # Give A a head start</div><div class="line">B = env.process(user(&apos;B&apos;, env, res, prio=-2, preempt=False))</div><div class="line">C = env.process(user(&apos;C&apos;, env, res, prio=-1, preempt=True))</div><div class="line">env.run()</div><div class="line"></div><div class="line">A requesting at 0</div><div class="line">A got resource at 0</div><div class="line">B requesting at 1</div><div class="line">C requesting at 1</div><div class="line">B got resource at 3</div><div class="line">C got resource at 6</div><div class="line">[Finished in 0.2s]</div></pre></td></tr></table></figure>
<ul>
<li>Process A requests the resource with priority 0. It immediately becomes a user.</li>
<li>Process B requests the resource with priority -2 but sets preempt to False. It will queue up and wait.</li>
<li><p>Process C requests the resource with priority -1 but leaves preempt True. Normally, it would preempt A but in this case, B is queued up before C and prevents C from preempting A. C can also not preempt B since its priority is not high enough.<br>Thus, the behavior in the example is the same as if no preemption was used at all. Be careful when using mixed preemption!</p>
<p>Due to the higher priority of process B, no preemption occurs in this example. Note that an additional request with a priority of -3 would be able to preempt A.</p>
<p>If your use-case requires a different behaviour, for example queue-jumping or valuing preemption over priorities, you can subclass PreemptiveResource and override the default behaviour.</p>
</li>
</ul>
</li>
<li><p>Containers 生产者消费者<br>a homogeneous, undifferentiated bulk</p>
</li>
</ol>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2017/11/16/Learning-Simpy/">
                Learning Simpy
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-11-16</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="SimPy-基础"><a href="#SimPy-基础" class="headerlink" title="SimPy 基础"></a>SimPy 基础</h3><h4 id="How-SimPy-works"><a href="#How-SimPy-works" class="headerlink" title="How SimPy works"></a>How SimPy works</h4><p>SimPy 就是一个异步事件调度器，使用者要做的就是生成事件并指定事件在什么情况下触发及调度。<br><strong>事件</strong>按照优先级和仿真时间排序，拥有递增的事件id。一个事件有一个回调列表，这些回调会在事件触发时被执行。事件可以有返回值。<br>另一个概念就是<strong>进程函数</strong>，进程函数就是一个 <code>yield</code> 出 <code>Event</code> 实例的 Python 生成器函数。<br><strong>环境</strong>将事件存储在事件列表中，并 keeps track of 当前的仿真时间。<br>关键流程：当一个进程函数 yield 出一个事件时，SimPy 会将进程函数加入事件的回调列表，并挂起进程函数直到事件触发。当等待事件触发的进程函数恢复执行时就会得到事件的返回值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> simpy</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">example</span><span class="params">(env)</span>:</span></div><div class="line">    event = simpy.events.Timeout(env, delay=<span class="number">1</span>, value=<span class="number">42</span>)</div><div class="line">    value = <span class="keyword">yield</span> event</div><div class="line">    print(<span class="string">'now=%d, value=%d'</span> % (env.now, value))</div><div class="line"></div><div class="line">env = simpy.Environment()</div><div class="line">example_gen = example(env)</div><div class="line">p = simpy.events.Process(env, example_gen)</div><div class="line">env.run()</div><div class="line"></div><div class="line">now=<span class="number">1</span>, value=<span class="number">42</span></div></pre></td></tr></table></figure></p>
<p>The <code>example()</code> process function above first creates a <code>Timeout</code> event. It passes the environment, a delay, and a value to it. The Timeout schedules itself at <code>now + delay</code> (that’s why the environment is required); other event types usually schedule themselves at the current simulation time.<br>（<code>Timeout</code> 事件，超时事件，这个事件的调度时间是 <code>env.now + delay</code>， 也就是在 <code>env._queue</code> 中的时间标签是 <code>env.now + delay</code>，因此会 <code>env.now + delay</code> 时出队并调用其回调。其他类型的事件通常的调度时间是 current simulation time <code>env.now</code>，即在 <code>env._queue</code> 中的时间标签就是那时的<code>env.now</code>，在 <code>env._queue</code> 中的时间标签和触发时间有关，也就是被触发加入 <code>env._queue</code> 时的 <code>env.now</code>。）<br>Starting a process function involves two things:</p>
<ol>
<li>You have to call the process function to create a generator object（在 JS 的忍者秘术中将其称之为生成器迭代器）. (This will not execute any code of that function yet.)</li>
<li>进程的实例化会触发一个 <code>Initialize</code> 事件，并将其加入事件队列，这个事件的调度时间是 <code>current simulation time</code>，即其在 <code>env._queue</code> 中的时间标签就是那时的 <code>env.now</code>。进程也是一个事件，会在进程函数返回时触发并加入事件队列，这个事件的调度时间也是 <code>current simulation time</code>，即其在 <code>env._queue</code> 中的时间标签就是那时的 <code>env.now</code>。<br>“Best practice” version of the example above<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> simpy</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">example</span><span class="params">(env)</span>:</span></div><div class="line">    value = <span class="keyword">yield</span> env.timeout(<span class="number">1</span>, value=<span class="number">42</span>)</div><div class="line">    print(<span class="string">'now=%d, value=%d'</span> % (env.now, value))</div><div class="line"></div><div class="line">env = simpy.Environment()</div><div class="line">p = env.process(example(env))</div><div class="line">env.run()</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><ol>
<li><p>仿真控制<br> SimPy 的仿真控制十分的灵活，可以运行仿真直到事件列表为空、直到某个仿真时间、直到某个事件触发，也可以逐个事件运行仿真。</p>
<p> <code>env.run()</code> 会运行仿真直到事件列表为空。</p>
<blockquote>
<p>If your processes run forever (<code>while True: yield env.timeout(1)</code>), this method will never terminate (unless you kill your script by e.g., pressing <code>Ctrl-C</code>).</p>
</blockquote>
<p> <code>env.run(until=10)</code> 仿真会在内部时钟到达 10 时停止，但是不会处理 time 10 的事件。<br> If you want to integrate your simulation in a GUI and want to draw a process bar, you can repeatedly call this function with increasing until values and update your progress bar after each call:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for i in range(100):</div><div class="line">    env.run(until=i)</div><div class="line">    progressbar.update(i)</div></pre></td></tr></table></figure>
<p> <code>env.run(event)</code> or <code>env.run(process)</code> 会运行仿真直到事件触发（进程函数返回）。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import simpy</div><div class="line">def my_proc(env):</div><div class="line">    yield env.timeout(1)</div><div class="line">    return &apos;Monty Python’s Flying Circus&apos;</div><div class="line">env = simpy.Environment()</div><div class="line">proc = env.process(my_proc(env))</div><div class="line">print(env.run(until=proc))</div></pre></td></tr></table></figure>
<p> <code>peek()</code> returns the time of the next scheduled event or infinity (<code>float(&#39;inf&#39;)</code>) if no future events are scheduled.</p>
<p> <code>step()</code> processes the next scheduled event. It raises an <code>EmptySchedule</code> exception if no event is available.</p>
<p> In a typical use case, you use these methods in a loop like:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">until = 10</div><div class="line">while env.peek() &lt; until:</div><div class="line">   env.step()</div></pre></td></tr></table></figure>
</li>
<li><p>状态访问<br> <code>Environment.now</code> 可以获得仿真时间，仿真时间是没有单位的，并且只会通过 <code>Timeout</code> 事件增加。<br> <code>Environment.active_process</code> is comparable to <code>os.getpid()</code> and is either <code>None</code> or pointing at the currently active <code>Process</code>. A process is active when its process function is being executed. <strong>It becomes inactive (or suspended) when it yields an event.</strong><br> Thus, it only makes sense to access this property from within a process function or a function that is called by your process function:<br> 如果不是这样的话，在进程函数外（即执行流在进程函数外）时，访问到的<code>Environment.active_process</code>肯定是 <code>None</code>。被进程函数调用的函数可以通过这个属性获得调用者（进程）的信息。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import simpy</div><div class="line">def subfunc(env):</div><div class="line">    print(env.active_process)  # will print &quot;p1&quot;</div><div class="line"></div><div class="line">def my_proc(env):</div><div class="line">    while True:</div><div class="line">        print(env.active_process)  # will print &quot;p1&quot;</div><div class="line">        subfunc(env)</div><div class="line">        yield env.timeout(1)</div><div class="line"></div><div class="line">env = simpy.Environment()</div><div class="line">p1 = env.process(my_proc(env))</div><div class="line">print(env.active_process)</div><div class="line">env.step()</div><div class="line">print(env.active_process)</div><div class="line"></div><div class="line">None</div><div class="line">&lt;Process(my_proc) object at 0x183956c9278&gt;</div><div class="line">&lt;Process(my_proc) object at 0x183956c9278&gt;</div><div class="line">None</div></pre></td></tr></table></figure>
<p> An exemplary use case for this is the resource system: If a process function calls request() to request a resource, the resource determines the requesting process via env.active_process.</p>
</li>
<li><p>事件的创建<br> 创建事件 normally 需要导入 <code>simpy.events</code>，实例化一个事件类，并传入一个对环境的引用。SimPy 也提供了一下快捷方式，例如 <code>env.event()</code> 等效于<code>simpy.events.Event(env)</code>。其他的快捷方式还有:</p>
<ol>
<li>env.process()</li>
<li>env.timeout()</li>
<li>env.all_of()</li>
<li>env.any_of()</li>
</ol>
</li>
<li><p>Miscellaneous<br> 自从 Python 3.3 ，一个生成器函数可以有一个返回值。<br> 在 SimPy 中，一个进程通过这种方式提供可以被其他进程使用的返回值。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def my_proc(env):</div><div class="line">    yield env.timeout(1)</div><div class="line">    return 42</div><div class="line">def other_proc(env):</div><div class="line">    ret_val = yield env.process(my_proc(env))</div><div class="line">    assert ret_val == 42</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>SimPy 的内建事件层次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">events.Event</div><div class="line">|</div><div class="line">+— events.Timeout</div><div class="line">|</div><div class="line">+— events.Initialize</div><div class="line">|</div><div class="line">+— events.Process</div><div class="line">|</div><div class="line">+— events.Condition</div><div class="line">|  |</div><div class="line">|  +— events.AllOf</div><div class="line">|  |</div><div class="line">|  +— events.AnyOf</div><div class="line">.</div><div class="line">.</div><div class="line">.</div></pre></td></tr></table></figure></p>
<p>资源定义了额外的事件。这一部分的内容主要聚焦在 <code>simpy.events</code>模块中的事件。</p>
<ol>
<li><p>事件基础<br> SimPy 的事件和 deferreds、futures 或者 promises 十分类似。一个事件会处于下面状态中的一个：</p>
<ul>
<li>might happen (not triggered),</li>
<li>is going to happen (triggered) or</li>
<li><p>has happened (processed).</p>
<p>事件会逐一按序经历上面的状态，事件和时间紧密结合，时间引起事件状态的更新。<br>初始的时候，事件没有被触发，它们仅仅是内存中的对象。<br>当一个事件触发，事件就会 insert into SimPy 的事件队列，事件的 <code>triggered</code> 属性变为 <code>True</code>。<br>As long as the event is not processed, you can add callbacks to an event. <strong>Callbacks are callables that accept an event as parameter and are stored in the Event.callbacks list</strong>.<br>An event becomes processed when SimPy pops it from the event queue and calls all of its callbacks. It is now no longer possible to add callbacks. The property Event.processed becomes True.<br>Events also have a value. The value can be set before or when the event is triggered and can be retrieved via Event.value or, within a process, by yielding the event (value = yield event).<br>事件被触发，就会加入事件队列，<code>triggered</code> 属性就会变为 <code>True</code>。<br>事件未被触发，就不会加入事件队列，<code>triggered</code> 属性就仍为 <code>False</code>。<br>一旦事件被加入队列，队列中的事件之间就会按序（创建次序，时间，优先级等）被调度处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> simpy</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_callback</span><span class="params">(event)</span>:</span></div><div class="line">    print(<span class="string">'Called back from'</span>, event)</div><div class="line"></div><div class="line">env = simpy.Environment()</div><div class="line">event = env.event()</div><div class="line">event.callbacks.append(my_callback)</div><div class="line">print(event.triggered)</div><div class="line">print(event.processed)</div><div class="line">env.run(event)</div><div class="line"></div><div class="line"><span class="keyword">False</span></div><div class="line">Traceback (most recent call last):</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure>
<p>上面的代码会抛出运行时错误<code>RuntimeError: No scheduled events left but &quot;until&quot; event was not triggered: &lt;Event() object at 0x18e07e36c18&gt;</code>这是因为<code>env.event()</code>也就是<code>simpy.events.Event(env)</code>并不会触发自身，事件队列为空，因此会报错，env.timeout(1) 就会把自己加入事件列表，并在 now + 1 时被调度处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> simpy</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_callback</span><span class="params">(event)</span>:</span></div><div class="line">    print(<span class="string">'Called back from'</span>, event)</div><div class="line">env = simpy.Environment()</div><div class="line"><span class="comment"># event = env.event()</span></div><div class="line">event = env.timeout(<span class="number">1</span>)</div><div class="line">event.callbacks.append(my_callback)</div><div class="line"></div><div class="line">print(env.now)</div><div class="line">print(env._queue)</div><div class="line">print(event.triggered)</div><div class="line">print(event.processed)</div><div class="line">env.run(event)</div><div class="line">print(env.now)</div><div class="line">print(env._queue)</div><div class="line">print(event.triggered)</div><div class="line">print(event.processed)</div><div class="line"></div><div class="line"></div><div class="line"><span class="number">0</span></div><div class="line">[(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, &lt;Timeout(<span class="number">1</span>) object at <span class="number">0x2a67fa677f0</span>&gt;)]</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="keyword">False</span></div><div class="line">Called back <span class="keyword">from</span> &lt;Timeout(<span class="number">1</span>) object at <span class="number">0x2a67fa677f0</span>&gt;</div><div class="line"><span class="number">1</span></div><div class="line">[]</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Adding callbacks to an event<br> The most common way to add a callback to an event is yielding it from your process function (yield event). This will add the process’ _resume() method as a callback. That’s how your process gets resumed when it yielded an event.<br> However, you can add any callable object (function) to the list of callbacks as long as it accepts an event instance as its <strong>single</strong> parameter。<br> If an event has been processed, all of its Event.callbacks have been executed and the attribute is set to None. This is to prevent you from adding more callbacks。<br> Processes are smart about this, though. If you yield a processed event, _resume() will immediately resume your process with the value of the event (because there is nothing to wait for).也就是 _resume() 方法加不进事件的回调列表了。 </p>
</li>
<li><p>Triggering events</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">import simpy</div><div class="line">class School:</div><div class="line">    def __init__(self, env):</div><div class="line">        self.env = env</div><div class="line">        print(&quot;1: &quot;, self.env._queue)</div><div class="line">        self.class_ends = env.event()</div><div class="line">        print(&quot;2: &quot;, self.env._queue)</div><div class="line">        self.pupil_procs = [env.process(self.pupil()) for i in range(3)]</div><div class="line">        print(&quot;3: &quot;, self.env._queue)</div><div class="line">        self.bell_proc = env.process(self.bell())</div><div class="line">        print(&quot;4: &quot;, self.env._queue)</div><div class="line"></div><div class="line">    def bell(self):</div><div class="line">        for i in range(2):</div><div class="line">            print(&quot;5: &quot;, i, self.env._queue)</div><div class="line">            yield self.env.timeout(45)</div><div class="line">            print(&quot;6: &quot;, i, self.env._queue)</div><div class="line">            self.class_ends.succeed()</div><div class="line">            print(&quot;7: &quot;, i, self.env._queue)</div><div class="line">            self.class_ends = self.env.event()</div><div class="line">            print(&quot;8: &quot;, i, self.env._queue)</div><div class="line">            print(&quot;bell is ringing...&quot;)</div><div class="line"></div><div class="line">    def pupil(self):</div><div class="line">        for i in range(2):</div><div class="line">            print(&apos;ZaZa...ZaZa...&apos;, end=&apos;&apos;)</div><div class="line">            print(&quot;9: &quot;, i, self.env._queue)</div><div class="line">            yield self.class_ends</div><div class="line">            print(&quot;10: &quot;, i, self.env._queue)</div><div class="line"></div><div class="line">env = simpy.Environment()</div><div class="line">school = School(env)</div><div class="line">print(&quot;Before runing...&quot;, env._queue, &quot;\n&quot;)</div><div class="line">env.run()</div><div class="line">print(&quot;After runing...&quot;, env._queue)</div></pre></td></tr></table></figure>
<p> 输出结果如下，逐一分析就可以看出，只有在有 yield 时才会发生执行流在协程之间的切换，env.event() 只有在显式地调用<code>.succeed()</code>方法时<strong>才会被触发，加入事件队列</strong> ，它在队列中的时间标签就是 <code>current simulation time</code>，也就是调用 <code>succeed()</code> 方法时的系统仿真时间。 </p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">1:  []</div><div class="line">2:  []</div><div class="line">3:  [(0, 0, 0, &lt;Initialize() object at 0x1b74a129a58&gt;), (0, 0, 1, &lt;Initialize() object at 0x1b74a163e10&gt;), (0, 0, 2, &lt;Initialize() object at 0x1b74a170240&gt;)]</div><div class="line">4:  [(0, 0, 0, &lt;Initialize() object at 0x1b74a129a58&gt;), (0, 0, 1, &lt;Initialize() object at 0x1b74a163e10&gt;), (0, 0, 2, &lt;Initialize() object at 0x1b74a170240&gt;), (0, 0, 3, &lt;Initialize() object at 0x1b74a1706a0&gt;)]</div><div class="line"></div><div class="line">Before runing... [(0, 0, 0, &lt;Initialize() object at 0x1b74a129a58&gt;), (0, 0, 1, &lt;Initialize() object at 0x1b74a163e10&gt;), (0, 0, 2, &lt;Initialize() object at 0x1b74a170240&gt;), (0, 0, 3, &lt;Initialize() object at 0x1b74a1706a0&gt;)] </div><div class="line"></div><div class="line">ZaZa...ZaZa...9:  0 [(0, 0, 1, &lt;Initialize() object at 0x1b74a163e10&gt;), (0, 0, 3, &lt;Initialize() object at 0x1b74a1706a0&gt;), (0, 0, 2, &lt;Initialize() object at 0x1b74a170240&gt;)]</div><div class="line">ZaZa...ZaZa...9:  0 [(0, 0, 2, &lt;Initialize() object at 0x1b74a170240&gt;), (0, 0, 3, &lt;Initialize() object at 0x1b74a1706a0&gt;)]</div><div class="line">ZaZa...ZaZa...9:  0 [(0, 0, 3, &lt;Initialize() object at 0x1b74a1706a0&gt;)]</div><div class="line">5:  0 []</div><div class="line">6:  0 []</div><div class="line">7:  0 [(45, 1, 5, &lt;Event() object at 0x1b74a129f98&gt;)]</div><div class="line">8:  0 [(45, 1, 5, &lt;Event() object at 0x1b74a129f98&gt;)]</div><div class="line">bell is ringing...</div><div class="line">5:  1 [(45, 1, 5, &lt;Event() object at 0x1b74a129f98&gt;)]</div><div class="line">10:  0 [(90, 1, 6, &lt;Timeout(45) object at 0x1b74a1706d8&gt;)]</div><div class="line">ZaZa...ZaZa...9:  1 [(90, 1, 6, &lt;Timeout(45) object at 0x1b74a1706d8&gt;)]</div><div class="line">10:  0 [(90, 1, 6, &lt;Timeout(45) object at 0x1b74a1706d8&gt;)]</div><div class="line">ZaZa...ZaZa...9:  1 [(90, 1, 6, &lt;Timeout(45) object at 0x1b74a1706d8&gt;)]</div><div class="line">10:  0 [(90, 1, 6, &lt;Timeout(45) object at 0x1b74a1706d8&gt;)]</div><div class="line">ZaZa...ZaZa...9:  1 [(90, 1, 6, &lt;Timeout(45) object at 0x1b74a1706d8&gt;)]</div><div class="line">6:  1 []</div><div class="line">7:  1 [(90, 1, 7, &lt;Event() object at 0x1b74a1706a0&gt;)]</div><div class="line">8:  1 [(90, 1, 7, &lt;Event() object at 0x1b74a1706a0&gt;)]</div><div class="line">bell is ringing...</div><div class="line">10:  1 [(90, 1, 8, &lt;Process(bell) object at 0x1b74a170668&gt;)]</div><div class="line">10:  1 [(90, 1, 8, &lt;Process(bell) object at 0x1b74a170668&gt;), (90, 1, 9, &lt;Process(pupil) object at 0x1b74a129fd0&gt;)]</div><div class="line">10:  1 [(90, 1, 8, &lt;Process(bell) object at 0x1b74a170668&gt;), (90, 1, 9, &lt;Process(pupil) object at 0x1b74a129fd0&gt;), (90, 1, 10, &lt;Process(pupil) object at 0x1b74a163b00&gt;)]</div><div class="line">After runing... []</div><div class="line">[Finished in 0.2s]</div></pre></td></tr></table></figure>
<p> 上面的倒数第二条打印可以看到只有两个 Process(pupil) 对象，这是为什么呢？这是因为我们有三个 pupil 进程，进程只有结束时才会在事件队列中加入一个结束事件，也就是说这里的两个 Process(pupil) 是由第三个进程打印的前两个进程，由于第三个进程并没有结束，因此尚未将自己的结束事件加入事件列表。</p>
</li>
<li><p>Let time pass by: the Timeout<br> To <strong>actually</strong> let time pass in a simulation, there is the timeout event. A timeout has two parameters: a delay and an optional value: Timeout(delay, value=None). It triggers itself during its creation and schedules itself at now + delay. Thus, the succeed() and fail() methods cannot be called again.</p>
</li>
<li><p>Processes are events, too<br> SimPy processes (as created by Process or env.process()) have the nice property of being events, too.<br> That means, that a process can yield another process. 将第一个进程的 _resume() 方法加入第二个进程（作为事件）的回调列表。<br> It will then be resumed when the other process ends. The event’s value will be the return value of that process:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">import simpy</div><div class="line"></div><div class="line">def sub(env):</div><div class="line">    print(&quot;sub 1: &quot;, env.active_process.__repr__())</div><div class="line">    print(&quot;sub 1: &quot;, env.active_process.triggered)</div><div class="line">    print(&quot;sub 1: &quot;, env.active_process.processed)</div><div class="line">    print(&quot;sub 1: &quot;, env._queue)</div><div class="line">    yield env.timeout(1)</div><div class="line">    print(&quot;sub 2: &quot;, env.active_process.triggered)</div><div class="line">    print(&quot;sub 2: &quot;, env.active_process.processed)</div><div class="line">    print(&quot;sub 2: &quot;, env._queue)</div><div class="line">    return 23</div><div class="line">def parent(env):</div><div class="line">    print(&quot;parent 1: &quot;, env.active_process.__repr__())</div><div class="line">    print(&quot;parent 1: &quot;, env.active_process.triggered)</div><div class="line">    print(&quot;parent 1: &quot;, env.active_process.processed)</div><div class="line">    print(&quot;parent 1: &quot;, env._queue)</div><div class="line">    sp = env.process(sub(env))</div><div class="line">    print(&quot;parent 2: &quot;, env._queue)</div><div class="line">    ret = yield sp</div><div class="line">    print(&quot;parent 3: &quot;, env._queue)</div><div class="line">    print(&quot;parent 2: &quot;, env.active_process.processed)</div><div class="line">    print(&quot;parent 2: &quot;, env.active_process.processed)</div><div class="line">    return ret</div><div class="line">env = simpy.Environment()</div><div class="line">pp = env.process(parent(env))</div><div class="line">print(&quot;main: &quot;, env._queue)</div><div class="line">print(env.run(pp))</div><div class="line">print(pp.triggered)</div><div class="line">print(pp.processed)</div><div class="line"></div><div class="line">main:  [(0, 0, 0, &lt;Initialize() object at 0x2b6ea6f98d0&gt;)]</div><div class="line">parent 1:  &lt;Process(parent) object at 0x2b6ea6f9898&gt;</div><div class="line">parent 1:  False</div><div class="line">parent 1:  False</div><div class="line">parent 1:  []</div><div class="line">parent 2:  [(0, 0, 1, &lt;Initialize() object at 0x2b6ea7339e8&gt;)]</div><div class="line">sub 1:  &lt;Process(sub) object at 0x2b6ea6f9e10&gt;</div><div class="line">sub 1:  False</div><div class="line">sub 1:  False</div><div class="line">sub 1:  []</div><div class="line">sub 2:  False</div><div class="line">sub 2:  False</div><div class="line">sub 2:  []</div><div class="line">parent 3:  []</div><div class="line">parent 2:  False</div><div class="line">parent 2:  False</div><div class="line">23</div><div class="line">True</div><div class="line">True</div><div class="line">[Finished in 0.2s]</div></pre></td></tr></table></figure>
<p> <code>env.active_process.triggered</code> 和 <code>env.active_process.processed</code> 为什么总是返回 <code>False</code>, 从 <code>parent 1:  &lt;Process(parent) object at 0x2b6ea6f9898&gt;</code> 和 <code>sub 1:  &lt;Process(sub) object at 0x2b6ea6f9e10&gt;</code> 就可以看出来了，进程的 <code>triggered</code> 和 <code>processed</code> 只有在进程函数返回时才会被置为 <code>True</code>，因为进程作为事件标识的是结束事件。<br> The example above will only work in Python &gt;= 3.3. As a workaround for older Python versions, you can use env.exit(23) with the same effect.<br> If you don’t want a process to start immediately but after a certain delay, you can use simpy.util.start_delayed(). This method returns a helper <strong>process</strong> that uses a timeout before actually starting a process.</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> simpy</div><div class="line">env = simpy.Environment()</div><div class="line"><span class="keyword">from</span> simpy.util <span class="keyword">import</span> start_delayed</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(env)</span>:</span></div><div class="line">    <span class="keyword">yield</span> env.timeout(<span class="number">10</span>)</div><div class="line">    <span class="keyword">return</span> <span class="number">23</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parent</span><span class="params">(env)</span>:</span></div><div class="line">    start = env.now</div><div class="line">    print(<span class="string">"2: "</span>, env._queue)</div><div class="line">    sp = start_delayed(env, sub(env), delay=<span class="number">3</span>)</div><div class="line">    print(<span class="string">"3: "</span>, env._queue)</div><div class="line">    sub_proc = <span class="keyword">yield</span> sp</div><div class="line">    print(<span class="string">"4: "</span>, env._queue)</div><div class="line">    <span class="keyword">assert</span> env.now - start == <span class="number">3</span></div><div class="line">    ret = <span class="keyword">yield</span> sub_proc</div><div class="line">    print(<span class="string">"6: "</span>, env._queue)</div><div class="line">    <span class="keyword">return</span> ret</div><div class="line">pp = env.process(parent(env))</div><div class="line">print(<span class="string">"1: "</span>, env._queue)</div><div class="line">print(env.run(pp))</div><div class="line"></div><div class="line"></div><div class="line"><span class="number">1</span>:  [(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &lt;Initialize() object at <span class="number">0x1d4ae1e7b70</span>&gt;)]</div><div class="line"><span class="number">2</span>:  []</div><div class="line"><span class="number">3</span>:  [(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, &lt;Initialize() object at <span class="number">0x1d4ae2302e8</span>&gt;)]</div><div class="line"><span class="number">4</span>:  [(<span class="number">13</span>, <span class="number">1</span>, <span class="number">5</span>, &lt;Timeout(<span class="number">10</span>) object at <span class="number">0x1d4ae1e7b70</span>&gt;)]</div><div class="line"><span class="number">6</span>:  []</div><div class="line"><span class="number">23</span></div></pre></td></tr></table></figure>
</li>
<li><p>Waiting for multiple events at once</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">import simpy</div><div class="line">env = simpy.Environment()</div><div class="line">def test_condition(env):</div><div class="line">    t1, t2 = env.timeout(1, value=&apos;spam&apos;), env.timeout(2, value=&apos;eggs&apos;)</div><div class="line">    ret = yield t1 | t2</div><div class="line">    assert ret == &#123;t1: &apos;spam&apos;&#125;</div><div class="line">    t1, t2 = env.timeout(1, value=&apos;spam&apos;), env.timeout(2, value=&apos;eggs&apos;)</div><div class="line">    ret = yield t1 &amp; t2</div><div class="line">    assert ret == &#123;t1: &apos;spam&apos;, t2: &apos;eggs&apos;&#125;</div><div class="line">    # You can also concatenate &amp; and |</div><div class="line">    e1, e2, e3 = [env.timeout(i) for i in range(3)]</div><div class="line">    yield (e1 | e2) &amp; e3</div><div class="line">    assert all(e.processed for e in [e1, e2, e3])</div><div class="line"></div><div class="line">proc = env.process(test_condition(env))</div><div class="line">print(env._queue[0][-1].triggered)</div><div class="line">print(env._queue[0][-1].processed)</div><div class="line">print(proc.triggered)</div><div class="line">print(proc.processed)</div><div class="line">print(env.run())</div><div class="line"></div><div class="line">True</div><div class="line">False</div><div class="line">False</div><div class="line">False</div><div class="line">None</div><div class="line">[Finished in 0.2s]</div></pre></td></tr></table></figure>
</li>
</ol>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2017/11/13/Ubuntu-2-1080Ti-深度学习环境配置/">
                Ubuntu + 2*1080Ti 深度学习环境配置
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-11-13</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="Ubuntu-2-1080Ti-深度学习环境配置"><a href="#Ubuntu-2-1080Ti-深度学习环境配置" class="headerlink" title="Ubuntu + 2*1080Ti 深度学习环境配置"></a>Ubuntu + 2*1080Ti 深度学习环境配置</h2><h3 id="配置及环境"><a href="#配置及环境" class="headerlink" title="配置及环境"></a>配置及环境</h3><table>
<thead>
<tr>
<th>配件</th>
<th>型号</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>机箱</td>
<td>美商海盗船 AIR740 中塔机箱</td>
<td>1</td>
</tr>
<tr>
<td>电源</td>
<td>美商海盗船 HX1000 80plus 1000W</td>
<td>1</td>
</tr>
<tr>
<td>主板</td>
<td>华硕（ASUS） X99-M WS (Intel X99/LGA 2011-V3)</td>
<td>1</td>
</tr>
<tr>
<td>CPU</td>
<td>英特尔 至强 E5-2620</td>
<td>1</td>
</tr>
<tr>
<td>散热</td>
<td>猫头鹰NH-U9S CPU散热器</td>
<td>1</td>
</tr>
<tr>
<td>硬盘</td>
<td>西部数据 红盘 3T</td>
<td>2</td>
</tr>
<tr>
<td>SSD</td>
<td>英特尔 600P 256G M.2</td>
<td>1</td>
</tr>
<tr>
<td>内存</td>
<td>美商海盗船 DDR4 3000 16G</td>
<td>2</td>
</tr>
<tr>
<td>GPU</td>
<td>技嘉 AORUS GTX 1080Ti Xtreme Edition</td>
<td>2</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ubuntu</td>
<td>16.04.1</td>
</tr>
<tr>
<td>Nvidia driver</td>
<td>384.98</td>
</tr>
</tbody>
</table>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol>
<li><p>禁用 UEFI Secure Boot，不同的主板有不同的方法。Rod Smith 在 <a href="http://www.rodsbooks.com/efi-bootloaders/secureboot.html#disable" target="_blank" rel="external">Managing EFI Boot Loaders for Linux: Dealing with Secure Boot</a> 中描述的很细致。如果不禁用的话，会出现：</p>
<ol>
<li>驱动安装成功后并不会被成功地启动。<code>nvidia-smi</code>并不能成功地查看到 GPU 的信息。而是会报出 <code>NVIDIA-SMI has failed because it couldn&#39;t communicate with the NVIDIA driver. Make sure that the latest NVIDIA driver is installed and running.</code> 的错误。</li>
<li><p>开机后，在图形登录界面即使密码正确，也不能成功地登录（仍可以通过终端成功地登陆），而是不断地循环在输入密码、再次要求输入密码之间。</p>
<blockquote>
<p>Unified Extensible Firmware Interface<br>The Unified Extensible Firmware Interface (UEFI) is a specification(规格, 标准) that defines a software interface between an operating system and platform firmware. UEFI replaces the Basic Input/Output System (BIOS) firmware interface originally present in all IBM PC-compatible personal computers, with most UEFI firmware implementations providing legacy support for BIOS services. UEFI can support remote diagnostics and repair of computers, even with no operating system installed. The user can enter a setup utility by pressing their manufacturers specific setup keys. Most common keys are Delete,F2, F12,esc etc.</p>
</blockquote>
</li>
</ol>
</li>
<li><p>关闭 X server。由于我是使用 Xshell 通过 ssh 登陆的，因此此处我就直接通过 <code>service lightdm stop</code> 关闭了图形界面，此时可以看到远端机器的屏幕黑屏了。这里命令需要根据具体的图形桌面是kdm，gdm，还是 lightdm 而定。<br>如果不关闭X server 就会报出 <code>You appear to be running an X server; please exit X before installing.</code>。</p>
<blockquote>
<p>X server 是 Linux 系统里图形接口服务器的简称。Windows 系统的界面是其系统构成不可分割的一部分，各种窗口操作的界面显示都是由系统核心直接管理的，而 Linux 的图形界面并不是系统的必要组成部分，Linux 可以在无界面的条件下运行。当需要 Linux 提供界面的时候，系统就会建立一个或者数个 X server，通过 X 协议跟窗口管理器交互，由独立于系统的应用程序来产生窗口，状态栏，按钮之类的交互界面。</p>
<p>比较常见的 Linux 图形界面操作环境有 KDE 和 GNOME，为它们提供系统支持的就是 X server，而并非 Linux 核心。总结一下 Linux 图形界面层次关系：Linux本身–&gt;X服务器&lt;-[通过X协议交谈]-窗口管理器–&gt;X应用程序。</p>
</blockquote>
</li>
</ol>
<h3 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h3><ol>
<li>到英伟达<a href="http://www.nvidia.cn/Download/index.aspx?lang=cn" target="_blank" rel="external">驱动程序下载官网</a>下载对应于显卡型号的驱动。</li>
<li><p>安装</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chmod a+x NVIDIA-Linux-x86_64-384.98.run</div><div class="line">./NVIDIA-Linux-x86_64-384.98.run</div></pre></td></tr></table></figure>
<p> 安装过程中会询问是否通过 x-config 屏蔽开源驱动 nouveau，选择接受通过 x-config 进行备份，这样安装失败时，通过 <code>./NVIDIA-Linux-x86_64-384.98.run --uninstall</code> 卸载驱动，恢复使用 nouveau 就仍然可以使用图形界面。</p>
</li>
<li><code>nvidia-smi</code>查看显卡信息。<br> <img src="http://oytnj8g2y.bkt.clouddn.com/nvidia_smi.png" alt="显卡信息"></li>
</ol>
<h3 id="安装CUDA"><a href="#安装CUDA" class="headerlink" title="安装CUDA"></a>安装CUDA</h3><ol>
<li>按照 <a href="http://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html" target="_blank" rel="external">CUDA TOOLKIT DOCUMENTATION</a> 给出的步骤进行 Pre-installation Actions，Package Manager Installation，Post-installation Actions 安装。</li>
<li>到英伟达<a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="external">CUDA Toolkit Download 官网</a>下载对应操作系统的 CUDA 。</li>
<li>如果安装失败，需要重新尝试时通过 <code>sudo apt-get --purge remove cuda</code> 对 CUDA 进行卸载。</li>
<li>最新版的 CUDA 是 9.0，但是 TensorFlow 目前并不支持 9.0，只好从 <a href="https://developer.nvidia.com/cuda-80-download-archive" target="_blank" rel="external">Legacy Releases</a> 下载 CUDA 8.0。</li>
</ol>
<h3 id="安装CUDNN"><a href="#安装CUDNN" class="headerlink" title="安装CUDNN"></a>安装CUDNN</h3><ol>
<li>按照 <a href="http://docs.nvidia.com/deeplearning/sdk/cudnn-install/index.html" target="_blank" rel="external">DEEP LEARNING DOCUMENTATION</a> 给出的步骤进行。</li>
</ol>
<h3 id="安装tensorflow"><a href="#安装tensorflow" class="headerlink" title="安装tensorflow"></a>安装tensorflow</h3><ol>
<li><code>sudo apt-get install libcupti-dev</code></li>
<li><code>pip install tensorflow-gpu</code> 但是由于 tensorflow 目前只支持 3.5，所以会报出运行时和编译时 Python 版本不匹配的问题。</li>
<li>改用 Installing with Anaconda： <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">conda create -n tensorflow python=3.5</div><div class="line">source activate tensorflow</div><div class="line">pip install tensorflow</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="挂载磁盘"><a href="#挂载磁盘" class="headerlink" title="挂载磁盘"></a>挂载磁盘</h3><ol>
<li>查看一下磁盘信息 <code>sudo lshw -C disk</code></li>
<li>格式化磁盘，将磁盘格式化为 ext3 格式 <code>sudo mke2fs -j /dev/hdd1</code></li>
<li>查看一下分区类型 <code>sudo blkid</code></li>
<li><p>设置启动自动挂载磁盘</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/fstab</div><div class="line">/dev/sda /home/shark/Codes ext3 defaults 0 0</div><div class="line">/dev/sdb /home/wjx/Codes ext3 defaults 0 0</div></pre></td></tr></table></figure>
</li>
<li><p><code>sudo reboot</code></p>
</li>
</ol>
<h3 id="监视NVIDIA的GPU"><a href="#监视NVIDIA的GPU" class="headerlink" title="监视NVIDIA的GPU"></a>监视NVIDIA的GPU</h3><ol>
<li><code>watch -n 1 nvidia-smi</code><blockquote>
<p>whatis watch<br>watch (1) - execute a program periodically, showing output fullscreen</p>
</blockquote>
</li>
</ol>
<h3 id="新增一个用户，将其家目录链接到硬盘挂载点下的一个目录上"><a href="#新增一个用户，将其家目录链接到硬盘挂载点下的一个目录上" class="headerlink" title="新增一个用户，将其家目录链接到硬盘挂载点下的一个目录上"></a>新增一个用户，将其家目录链接到硬盘挂载点下的一个目录上</h3><p>之前一直是我和师弟一人一个 1T 的硬盘，为了给同学新建一个用户，且为其分配足够的空间，需要将其家目录链接到硬盘挂载点下的一个目录上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo useradd -d /home/hz -m -s /bin/bash hz</div><div class="line">mkdir /home/wjx/Codes/HZ</div><div class="line">sudo chown -R hz:hz HZ/</div><div class="line">ln -s /home/hz /home/wjx/Codes/HZ/</div></pre></td></tr></table></figure></p>
<p>验证链接成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ls /home/wjx/Codes/HZ/hz</div><div class="line">examples.desktop</div><div class="line">ls /home/hz/</div><div class="line">examples.desktop</div><div class="line">ll /home/hz/</div><div class="line">总用量 32</div><div class="line">drwxr-xr-x 2 hz   hz   4096 11月 29 20:08 ./</div><div class="line">drwxr-xr-x 5 root root 4096 11月 29 20:08 ../</div><div class="line">-rw-r--r-- 1 hz   hz    220 9月   1  2015 .bash_logout</div><div class="line">-rw-r--r-- 1 hz   hz   3771 9月   1  2015 .bashrc</div><div class="line">-rw-r--r-- 1 hz   hz   8980 4月  20  2016 examples.desktop</div><div class="line">-rw-r--r-- 1 hz   hz    655 6月  24  2016 .profile</div><div class="line">ll /home/wjx/Codes/HZ/hz</div><div class="line">lrwxrwxrwx 1 root root 8 11月 29 20:11 /home/wjx/Codes/HZ/hz -&gt; /home/hz/</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>软链接与硬链接的区别：</strong></p>
<ol>
<li>对于一个文件来说，有唯一的索引节点与之对应，而对于一个索引节点号，却可以有多个文件名与之对应。因此，在磁盘上的同一个文件可以通过不同的路径去访问。注意在Linux下是一切皆文件。<br>链接有软链接和硬链接(hard link)之分的，软链接(symbolic link)又叫符号链接。符号链接相当于 Windows下的快捷方式。<br><code>ln -s source dist</code>        # 建立软链接<br><code>ln -s /mnt/hgfs/ /home/luo/</code>    # 注意后面的 “/”，是将目录里所有的文件链接过去，必须加上，否则，建立的目录显示颜色异常，不能正常访问，比如 cd 进不去<br><code>ln source dist</code>           # 建立硬链接</li>
<li>软链接实际上只是一段文字，里面包含着它所指向的文件的名字，系统看到软链接后自动跳到对应的文件位置处进行处理；相反，硬链接为文件开设一个新的目录项，硬链接与文件原有的名字是平权的，在Linux看来它们是等价的。由于这个原因，硬链接不能链接两个不同文件系统上的文件。<br>软链接可以跨文件系统 ，硬链接不可以。</li>
<li>关于 I 节点的问题 。硬链接不管有多少个，都指向的是同一个 I 节点，会把节点链接数增加，只要节点的链接数不是 0，文件就一直存在，不管你删除的是源文件还是链接的文件 。只要有一个存在 ，文件就存在 （其实也不分什么源文件,链接文件的 ，因为他们指向都是同一个 I 节点）。当你修改源文件或者链接文件任何一个的时候 ，其他的文件都会做同步的修改。<br>软链接不直接使用 I 节点号作为文件指针,而是使用文件路径名作为指针。所以删除链接文件 对源文件无影响，但是删除源文件，链接文件就会找不到要指向的文件。软链接有自己的 I 节点,并在磁盘上有一小片空间存放路径名。</li>
<li>I 节点 :它是UNIX内部用于描述文件特性的数据结构。我们通常称 I 节点为文件索引节点(信息节点)。I 节点含有关于文件的大部分的重要信息,包括文件数据块在磁盘上的地址.每一个 I 节点有它自己的标志号,我们称为文件顺序号。I 节点包含的信息 1.文件类型 2.文件属主关系 3.文件的访问权限 4.文件的时间截。</li>
</ol>
</blockquote>
<h3 id="安装CUDA-9-0"><a href="#安装CUDA-9-0" class="headerlink" title="安装CUDA 9.0"></a>安装CUDA 9.0</h3><p>tensorflow 1.4 使用的 cuda 8.0，在更新至 1.8 之后，tensorflow 1.8 使用的是 cuda 9.0，因此有必要进行 cuda 的更新。</p>
<ol>
<li><code>sudo apt-get --purge remove cuda</code><br>An incomplete installation of libglvnd was found. Do you want to install a</li>
</ol>
<p>full copy of libglvnd? This will overwrite any existing libglvnd libraries.</p>
<p>(Answer: Abort installation.)<br>To uninstall the CUDA Toolkit, run the uninstall script in /usr/local/cuda-9.0/bin<br>To uninstall the NVIDIA Driver, run nvidia-uninstall</p>
<p>Please see CUDA_Installation_Guide_Linux.pdf in /usr/local/cuda-9.0/doc/pdf for detailed information on setting up CUDA.<br>sudo /usr/local/cuda-9.0/bin/uninstall_cuda_9.0.pl </p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2017/11/05/Python-threads-communication-and-stopping/">
                Python threads: communication and stopping
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-11-05</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h4 id="如何停止-杀死一个线程？如何安全地从一个线程传入传出数据？"><a href="#如何停止-杀死一个线程？如何安全地从一个线程传入传出数据？" class="headerlink" title="如何停止/杀死一个线程？如何安全地从一个线程传入传出数据？"></a>如何停止/杀死一个线程？如何安全地从一个线程传入传出数据？</h4><p>下面是一个 worker 线程实现的例子，可以给它任务，这里的每一个任务就是一个目录名，它就会进行工作，这里的工作就是罗列出给定目录及其子目录下的文件名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">import os, time</div><div class="line">import threading, Queue</div><div class="line">class WorkerThread(threading.Thread):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    A worker thread that takes directory names from a queue, finds all files in them </div><div class="line">    recursively and reports the result. </div><div class="line">    </div><div class="line">    Input is done by placing directory names (as strings) into the Queue passed in dir_q. </div><div class="line">    </div><div class="line">    Output is done by placing tuples into the Queue passed in result_q. Each tuple </div><div class="line">    is (thread name, dirname, [list of files]). </div><div class="line">    </div><div class="line">    Ask the thread to stop by calling its join() method. </div><div class="line">    &quot;&quot;&quot;</div><div class="line">    </div><div class="line">    def __init__(self, dir_q, result_q):</div><div class="line">        super(WorkerThread, self).__init__()</div><div class="line">        self.dir_q = dir_q</div><div class="line">        self.result_q = result_q</div><div class="line">        self.stoprequest = threading.Event()</div><div class="line">    </div><div class="line">    def run(self):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        As long as we weren&apos;t asked to stop, try to take new tasks from the queue. </div><div class="line">        The tasks are taken with a blocking &apos;get&apos;, so no CPU cycles are wasted </div><div class="line">        while waiting. Also, &apos;get&apos; is given a timeout, so stoprequest is always </div><div class="line">        checked, even if there&apos;s nothing in the queue. </div><div class="line">        &quot;&quot;&quot;</div><div class="line">        while not self.stoprequest.isSet():</div><div class="line">            try:</div><div class="line">                dirname = self.dir_q.get(True, 0.05)</div><div class="line">                filenames = list(self._files_in_dir(dirname))</div><div class="line">                self.result_q.put((self.name, dirname, filenames))</div><div class="line">            except Queue.Empty:</div><div class="line">                continue</div><div class="line"></div><div class="line">    def join(self, timeout=None):</div><div class="line">        self.stoprequest.set()</div><div class="line">        super(WorkerThread, self).join(timeout)</div><div class="line"></div><div class="line"></div><div class="line">    def _files_in_dir(self, dirname):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        Given a directory name, yields the names of all files (not dirs) </div><div class="line">        contained in this directory and its sub-directories.</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        for path, dirs, files in os.walk(dirname):</div><div class="line">            for file in files:</div><div class="line">                yield os.path.join(path, file)</div></pre></td></tr></table></figure>
<p>下面让我们依次谈一下如何解决上面提及到的两个问题：</p>
<ol>
<li>首先是杀死一个线程，这是通过礼貌地请求线程停止完成的。线程的 <code>join</code> 方法被重写了，在调用父类的 <code>join</code> 之前，首先设置了 <code>self.stoprequest</code> 属性，它是一个线程事件 <code>threading.Event</code>，在线程 <code>run</code> 方法中的主循环中会检查这个 flag，如果这个 flag 被设置了就退出循环。可以把这个 <code>threading.Event</code> 当作一个同步的布尔型 flag 。记住 <code>join</code> 方法是在主线程的上下文中被调用的，而 <code>run</code> 方法的函数体是在 worker 线程的上下文中执行的。</li>
<li>第二点，从一个线程传入传出数据。最佳实践就是使用 Python Queue 包中的 Queue 对象（在 Python 3 中这个包名是 queue）。当 worker 线程被创建时，输入一个输入队列的引用和一个输出队列的引用。队列对象可以在任意数量的线程间安全地共享，并且提供了一个同步的 FIFO 队列接口。这里的同步要注意和异步区分，异步比如 JS 的 promise 机制。</li>
</ol>
<p>代码中最重要的几行是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">while not self.stoprequest.isSet():</div><div class="line">    try:</div><div class="line">        dirname = self.dir_q.get(True, 0.05)</div><div class="line">        filenames = list(self._files_in_dir(dirname))</div><div class="line">        self.result_q.put((self.name, dirname, filenames))</div><div class="line">    except Queue.Empty:</div><div class="line">        continue</div></pre></td></tr></table></figure></p>
<p>除非我们要求它停止，线程不会停止，即使队列中并没有任务可做了。<br><code>Queue.get</code> 是这样使用的，它的 <code>blocking</code> 参数被设置为 <code>true</code>，因此它会堵塞 worker 线程直到在队列中有了新的任务或者 <code>timeout</code> 过期。<code>timeout</code> 被设置为 0.05s，意味着 <code>get</code> 堵塞 worker 线程最多 0.05s，如果在这段时间内，队列中还没有任务，就会抛出 <code>Queue.Empty</code> 异常。这里可以看出，<code>while not self.stoprequest.isSet()</code> 这条判断当队列中没有任务时，被检查的频率是 0.05s 一次。如果队列中有任务，那么被检查的频率就是任务执行时间，或长于或短于 0.05s。<br>在这里既能够不耗费 CPU 指令周期地等待队列，又能周期性地检查 <code>stoprequest</code> 事件（<code>get</code> 使用特定于操作系统的底层技术来实现不耗费 CPU 指令周期的等待）。这里有一个问题就是，如果 work 需要花费大量的时间，那么下一次对于 <code>stoprequest</code> 的检查就会被相应地推后。如果这一点对你的应用很敏感，可以考虑将长时 work 切成几块，在每一块完成之后对 <code>stoprequest</code> 进行检查。<br>下面是一个使用上面定义的 worker 线程的例子，创建了一个有 4 个线程的线程池，启动每个 work 并等待所有的结果被返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">def main(args):</div><div class="line">    # Create a single input and a single output queue for all threads.</div><div class="line">    dir_q = Queue.Queue()</div><div class="line">    result_q = Queue.Queue()</div><div class="line">    # Create the &quot;thread pool&quot;</div><div class="line">    pool = [WorkerThread(dir_q=dir_q, result_q=result_q) for i in range(4)]</div><div class="line">    # Start all threads</div><div class="line">    for thread in pool:</div><div class="line">        thread.start()</div><div class="line">    # Give the workers some work to do</div><div class="line">    work_count = 0</div><div class="line">    for dir in args:</div><div class="line">        if os.path.exists(dir):</div><div class="line">            work_count += 1</div><div class="line">            dir_q.put(dir)</div><div class="line">            print &apos;Assigned %s dirs to workers&apos; % work_count</div><div class="line">    # Now get all the results</div><div class="line">    while work_count &gt; 0:</div><div class="line">        # Blocking &apos;get&apos; from a Queue.</div><div class="line">        result = result_q.get()</div><div class="line">        print &apos;From thread %s: %s files found in dir %s&apos; \</div><div class="line">            % ( result[0], len(result[2]), result[1])</div><div class="line">        work_count -= 1</div><div class="line">    # Ask threads to die and wait for them to do it</div><div class="line">    # the threads will nerver die unless we ask them to stop</div><div class="line">    for thread in pool:</div><div class="line">        thread.join()</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    import sys</div><div class="line">    main(sys.argv[1:])</div></pre></td></tr></table></figure></p>
<p>所有的 worker 线程共享输入和输出队列，这完全没有问题，这使得这样一个简单的线程池功能却很强大。<br>最后需要注意的一点是，在 Python 中这样的 worker 线程只有在 work 不是 CPU 密集型时才有用。上面就是一个很好的例子，罗列出文件夹和文件是一个 I/O 密集型任务。另外的比如 socket I/O，用户交互，以及任何涉及到 web 的任务（从 HTTP 或者 RPC 服务抓取数据），都是很好的应用场景。</p>
<p>CPU 密集型的任务对于 Python 线程并不太合适，这是因为 GIL（Global Interpreter Lock）。Python 并行计算应该使用多进程而不是多线程，比如可以使用 multiprocessing 模块去管理 worker 进程。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2017/11/04/翻译-Learning-from-Imbalanced-Classes/">
                翻译 Learning from Imbalanced Classes
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-11-04</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>在参加数据挖掘的比赛时，遇到了类别不平衡的问题，在着手解决这个问题的过程中发现了来自 <a href="https://www.svds.com/" target="_blank" rel="external">Silicon Valley Data Science(svds)</a> <a href="https://www.svds.com/team/tom-fawcett/" target="_blank" rel="external">TOM FAWCETT</a> 的一篇博客 <a href="https://www.svds.com/learning-imbalanced-classes/" target="_blank" rel="external">Learning from Imbalanced Classes</a> 写的着实精彩，因此决定将其翻译过来。</p>
<h2 id="Learning-from-Imbalanced-Classes"><a href="#Learning-from-Imbalanced-Classes" class="headerlink" title="Learning from Imbalanced Classes"></a>Learning from Imbalanced Classes</h2><p>如果你刚刚上完一门机器学习的课程，你使用的大部分数据集可能是很简单的。当你拟合分类器时，样本的类别是平衡的，也就是说这些类别的样本量大体相等。导师通常是使用清洗过的数据集进行教学，从而能够集中精力在讲解特定的算法和技术上。通常你看到的样本是下面这样的，点代表样本，不同的颜色或者形状代表不同的类型。<br><img src="http://oytnj8g2y.bkt.clouddn.com/clean.png" alt="clean.png"><br>分类算法的目的是尝试学习出一个分类器能够区分这两者。基于不同的数学、统计或者几何假设，会有很多不同的算法。<br><img src="http://oytnj8g2y.bkt.clouddn.com/ImbalancedClasses_fig2.png" alt="ImbalancedClasses_fig2.png"><br>但是当你接触到真实的未清洗的数据时，你会注意到的第一件事情就是数据会含有很多的噪声，并且类别不平衡。真实数据的散点图可能是下面这样的：<br><img src="http://oytnj8g2y.bkt.clouddn.com/messy.png" alt="messy.png"><br>这个数据的主要问题是类别不平衡，红色点几乎被蓝色点淹没了。<br>学术界在研究不平衡类别问题时少数类样本量会占到10%到20%。但是真实数据集会比这更加失衡。下面是几个这样的例子：</p>
<ol>
<li>每年有大约2%的信用卡遭到欺诈（大部分的欺诈检测领域是严重失衡的） [1][1] 。</li>
<li>对疾病进行医学筛查通常是在没有疾病的大规模人群中进行的，检测出的患者是很少的一部分。</li>
<li>硬盘的坏损率每年大概是~1%。</li>
<li>在线广告的转化率大约在 $10_-3$ 到 $10_-6$ 之间。</li>
<li>工厂产品的瑕疵率大约0.1%。</li>
</ol>
<p>这些领域都是类别不平衡的，我称之为“稻草堆中的针”问题，在这样的问题中，分类器需要从大量的负样本中找到少量的正样本。当你遇到这样的问题时，使用标准的算法会遇到问题。传统的算法通常会偏向多数类，因为它们的损失函数是为优化像错误率这样的指标而设计的，并没有考虑进数据分布[2][2]。在极坏的情况下，少数类会被当作多数类的异常值而被忽略，学习算法会产生一个将所有样本分类为多数类的没有价值的分类器。</p>
<p>这看起来是一个病态行为，但是实际上并不是，特别是当你的目标是最大化最简单的指标准确率时，此时忽略少数类就是一个可以被接受的方式。但是如果我们假设分类出少数类样本才是更重要的，我们就必须更加小心地处理这个类别不平衡问题了。</p>
<h3 id="处理类别不平衡数据"><a href="#处理类别不平衡数据" class="headerlink" title="处理类别不平衡数据"></a>处理类别不平衡数据</h3><p>从类别不平衡数据中学习是一个研究了很久的问题。人们尝试了大量的技术，有或好或坏的结果，并没有一个清晰的答案。第一次遇到这个问题的数据科学家们通常的第一个问题是“数据类别不平衡时我该怎么办？”，但是这就像“哪一个学习算法才是最好的一样”，没有准确的答案，需要根据数据而定。下面大概依据实施的工作量给出了一个提纲：</p>
<ul>
<li>什么也不做。有的时候，你很幸运，什么也不用做，直接在原始自然（或者称之为分层）分布的数据上进行训练。</li>
<li>对训练集进行平衡：<ul>
<li>过采样少数类样本</li>
<li>下采样多数类样本</li>
<li>生成新的少数类样本</li>
</ul>
</li>
<li>丢弃少数类样本，采用异常检测框架</li>
<li>在算法层面，或者在算法之后：<ul>
<li>调整类别的权重（错误分类的代价）</li>
<li>调整决策的门限</li>
<li>调整算法使其对少数类更加的敏感</li>
</ul>
</li>
<li>构建全新的算法</li>
</ul>
<h3 id="离题：评估的-dos-与-don’ts"><a href="#离题：评估的-dos-与-don’ts" class="headerlink" title="离题：评估的 dos 与 don’ts"></a>离题：评估的 dos 与 don’ts</h3><p>在谈论如何使用类别不平衡的数据训练分类器之前，先讨论一下如何正确的评估一个分类器。这一点如何强调也不足为过。只有考核正确的指标你才能取得进步。</p>
<ol>
<li>不要使用准确率（或者错误率）去评估你的分类器。因为这有两大缺陷。准确率朴素地应用了一个 0.50 的门限去决定样本到底属于哪一类，这在类别不平衡时通常是错误的。第二点是，分类准确率仅仅是基于错误分类的计数，你应该知道的更多，比如哪些类经常被混淆，在评分曲线的高的一端，低的一端，还是整个曲线上都被混淆着。如果你不懂这些点，你可以去看一下这篇博客 <a href="http://www.svds.com/classifiers2/" target="_blank" rel="external">The Basics of Classifier Evaluation, Part 2</a>。你应该使用 ROC 曲线，precision-recall 曲线，lift 曲线，或者 profit（gain）曲线去可视化分类器的性能。<br><img src="http://oytnj8g2y.bkt.clouddn.com/Sample-ROC.png" alt="Sample-ROC"><br>ROC curve<br><img src="http://oytnj8g2y.bkt.clouddn.com/Sample-PR-1.png" alt="Sample-PR"><br>PR curve</li>
<li>不要使用<code>score</code>[3][3]或者<code>predict</code>从分类器得到硬的分类标签，而应该使用<code>proba</code>或者<code>predict_proba</code>得到概率估计。</li>
<li>当你得到概率估计，不要盲目地使用一个 0.50 的决策门限来区分类别。看一下性能曲线来决定一个合适的门限。</li>
<li>不管你在训练时做了什么，一定要在自然（分层）的分布上测试。看一下<code>sklearn.cross_validation.StratifiedKFold</code>。</li>
<li>你可以不使用概率估计，但是如果你需要它们，使用校准。看一下<code>sklearn.calibration.CalibratedClassifierCV</code>。</li>
</ol>
<p>上面展示的二维图表要比一个准确率数值含有更多的信息。但是如果必须要一个数字度量，下面的指标比准确率更可取。</p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic#Area_under_the_curve" target="_blank" rel="external">The Area Under the ROC curve (AUC)</a> is a good general statistic. It is equal to the probability that a random positive example will be ranked above a random negative example.</li>
<li>The <a href="https://en.wikipedia.org/wiki/F1_score" target="_blank" rel="external">F1 Score</a> is the harmonic mean of precision and recall. It is commonly used in text processing when an aggregate measure is sought.</li>
<li><a href="https://en.wikipedia.org/wiki/Cohen%27s_kappa" target="_blank" rel="external">Cohen’s Kappa</a> is an evaluation statistic that takes into account how much agreement would be expected by chance.</li>
</ol>
<h3 id="过采样或者下采样"><a href="#过采样或者下采样" class="headerlink" title="过采样或者下采样"></a>过采样或者下采样</h3><p>它们是最简单的方式，仅仅需要对处理步骤的很少改变，对样本集合进行调整直到达到平衡。过采样随机地重复少数类样本来增加少数类样本的数目，下采样随机地下采样多数类样本。一些数据科学家幼稚地认为过采样比下采样要好，因为过采样会产生更多的数据样本，而下采样却丢弃了数据样本。但是需要记住的是，重复数据并不是没有后果，重复数据会导致变量的方差变得比其真实方差要小，好的一面是，重复数据也增加了分类器所犯错误的计数，如果一个分类器在原始的数据集上犯了一个 false negative 的错误，并且数据集重复了 5 倍，那么分类器就会在新的数据集上犯 6 个错误。相反地，下采样会导致变量的方差变得比其真实方差要大。就因为如此，机器学习中过采样，下采样和使用自然分布都有应用。<br><img src="http://oytnj8g2y.bkt.clouddn.com/ImbalancedClasses_fig5.jpg" alt="ImbalancedClasses_fig5.png"><br>大部分的机器学习包能够进行简单的采样调整。R包<code>unbalanced</code>实现了一些专门用于类别不平衡数据集的采样技术，并且<code>scikit-learn.cross_validation</code>也有基本的采样算法。</p>
<h3 id="Bayesian-argument-of-Wallace-et-al"><a href="#Bayesian-argument-of-Wallace-et-al" class="headerlink" title="Bayesian argument of Wallace et al."></a>Bayesian argument of Wallace et al.</h3><p>在论文<em>Class Imbalance, Redux</em>, by Wallace, Small, Brodley and Trikalinos[4][4] 中提出了可能是最好的关于类别不平衡的理论证明和实践建议。他们支持下采样多数类。他们提出的证明是数学理论上的，但是在这里我仅会展示一个他们用来表达观点的例子。他们认为两个类别在一些具有解释性的变量分布的尾部必须可分辨的。假设有两个类别只有一个依赖变量<code>x</code>，每一个类别产生自一个标准差为 1 的高斯分布，类别 1 的高斯分布的均值为 1，类别 2 的高斯分布的均值为 2。它们看起来是这样的：<br><img src="http://oytnj8g2y.bkt.clouddn.com/ImbalancedClasses_fig6.png" alt="ImbalancedClasses_fig6.png"><br>给定一个 x 值，你会使用哪一个门限来确定这个样本来自于哪一个类别？很明显是中间的点 x=1.5，即图中的垂直线，如果一个新的样本 x 落在了小于 1.5 的一边，那么它可能就是类别 1，否则的话就是类别 2。当从这些样本中进行学习的时候，我们期望学习到的判别线就是 1.5。事实上，如果类别是平衡的话，这确实是我们会得到的结果。在 x 轴上的点是从每个分布得到的样本。<br>但是如果类别 1 是少数类，并假设我们有 10 个类别 1 的样本，50个类别 2 的样本，这种情况下，我们很可能学习到的就是一个发生了偏移的分隔线。<br><img src="http://oytnj8g2y.bkt.clouddn.com/ImbalancedClasses_fig7.png" alt="ImbalancedClasses_fig7.png"><br>我们可以通过下采样多数类的方式让其在数量上匹配少数类。问题是在于由于样本量的减少，学习出来的分割线会具有较高的易变性。做了10次采样，会导致10根不同的垂直线。<br><img src="http://oytnj8g2y.bkt.clouddn.com/ImbalancedClasses_fig8.png" alt="ImbalancedClasses_fig8.png"><br>因此最后一个步骤就是使用 <a href="https://en.wikipedia.org/wiki/Bootstrap_aggregating" target="_blank" rel="external">bagging</a> 的方式将这些分类器进行组合。整个过程看起来就是下面这样的：<br><img src="http://oytnj8g2y.bkt.clouddn.com/ImbalancedClasses_fig9.png" alt="ImbalancedClasses_fig9.png"><br>这个技术在 Scikit-learn 中并没有实现，但是一个叫做 <a href="https://github.com/silicon-valley-data-science/learning-from-imbalanced-classes/blob/master/blagging.py" target="_blank" rel="external"><code>blagging.py</code></a>（balanced bagging）实现了一个 <code>BlaggingClassifier</code>，它在聚合之前平衡了 bootstrap 之后的样本。</p>
<h3 id="Neighbor-based-approaches"><a href="#Neighbor-based-approaches" class="headerlink" title="Neighbor-based approaches"></a>Neighbor-based approaches</h3><p>上采样或者下采样使用随机选择样本的方式来调整样本的比例。一些其他的方式会仔细地检查样本空间，然后基于近邻关系采取一些行为。<br>例如，Tomek link 是指互为最近邻的分属两类的一对样本。换句话说，就是它们分属不同的类别但是却彼此很邻近。<br><img src="http://oytnj8g2y.bkt.clouddn.com/ImbalancedClasses_fig10.png" alt="ImbalancedClasses_fig10.png"><br>Tomek 算法找到这样的样本对，并且从中移除多数类的样本。思想就是让多数类和少数类之间的边界变得更加清晰，让少数类区域更加清楚。上面的图展示了一个简单的 Tomek link 移除的例子。R 包的<code>unbalanced</code>除了一些专门用于类别不平衡数据集的采样技术，也实现了 Tomek link 移除。 Scikit-learn 虽然没有内建的这种功能，但是有一些可用的独立包（比如<a href="https://github.com/ojtwist/TomekLink" target="_blank" rel="external">TomekLink</a>）。</p>
<h3 id="Synthesizing-new-examples-SMOTE-and-descendants"><a href="#Synthesizing-new-examples-SMOTE-and-descendants" class="headerlink" title="Synthesizing new examples: SMOTE and descendants"></a>Synthesizing new examples: SMOTE and descendants</h3><p>另外一个不涉及重采样样本的方式是合成新的样本。最著名的一个例子就是 Chawla 的<a href="https://www.cs.cmu.edu/afs/cs/project/jair/pub/volume16/chawla02a-html/chawla2002.html" target="_blank" rel="external">SMOTE</a> (Synthetic Minority Oversampling TEchnique)系统。思想就是通过在现存的少数类样本之间内插产生新的少数类样本。基本过程如下：<br><img src="http://oytnj8g2y.bkt.clouddn.com/ImbalancedClasses_fig11.png" alt="ImbalancedClasses_fig11.png"><br>SMOTE 很是成功，启发了很多的变种，扩展。在 R 的 <code>unbalanced</code> 和 Python 的 <a href="https://github.com/scikit-learn-contrib/imbalanced-learn" target="_blank" rel="external">UnbalancedDatasete</a> 中可以找到 SMOTE 及其扩展。<br>需要注意的是 SMOTE 的一个本质局限。由于是内插少数类样本，它仅仅能够在少数类样本的内部产生样本，外部是不行的。从形式上说， SMOTE 仅仅能够填充现存少数类样本的凸包，并不能创建新的少数类样本外部区域。</p>
<h3 id="Adjusting-class-weights"><a href="#Adjusting-class-weights" class="headerlink" title="Adjusting class weights"></a>Adjusting class weights</h3><p>许多机器学习工具包能够调整类别的重要性。例如， Scikit-learn 中的很多分类器有一个额外的参数<code>class_weight</code>，能够让一个类别的重要性高于其他的类别。下面就是一个直接来自 scikit-learn <a href="http://scikit-learn.org/stable/auto_examples/svm/plot_separating_hyperplane_unbalanced.html" target="_blank" rel="external">文档</a>的例子，展示了10倍增加少数类类别权重的作用。实线是使用默认设置（类别权重相同）时的边界，虚线是使用<code>class_weight</code>之后的效果。<br><img src="http://oytnj8g2y.bkt.clouddn.com/ImbalancedClasses_fig12.png" alt="ImbalancedClasses_fig12.png"><br>你可以看得到少数类在重要性上获得了增强，在少数类上犯下错误要比在其他类上犯下错误付出的代价更大，分隔超平面会进行调整去减少损失。需要注意的一点是，调整类别的重要性通常只在一种类别错误上具有作用（如果少数类是正例的话，那就是 False Negative 这种错误）。当然，如果分类器在训练集上没有犯下这样的错误，调整类别权重就没有作用。</p>
<h3 id="And-beyond"><a href="#And-beyond" class="headerlink" title="And beyond"></a>And beyond</h3><p>This post has concentrated on relatively simple, accessible ways to learn classifiers from imbalanced data. Most of them involve adjusting data before or after applying standard learning algorithms. It’s worth briefly mentioning some other approaches.</p>
<h4 id="New-algorithms"><a href="#New-algorithms" class="headerlink" title="New algorithms"></a>New algorithms</h4><p>Learning from imbalanced classes continues to be an ongoing area of research in machine learning with new algorithms introduced every year. Before concluding I’ll mention a few recent algorithmic advances that are promising.</p>
<p>In 2014 Goh and Rudin published a paper <em>Box Drawings for Learning with Imbalanced Data</em>[5][5] which introduced two algorithms for learning from data with skewed examples. These algorithms attempt to construct “boxes” (actually axis-parallel hyper-rectangles) around clusters of minority class examples:<br><img src="http://oytnj8g2y.bkt.clouddn.com/ImbalancedClasses_fig13.png" alt="ImbalancedClasses_fig13.png"><br>Their goal is to develop a concise, intelligible representation of the minority class. Their equations penalize the number of boxes and the penalties serve as a form of regularization.</p>
<p>They introduce two algorithms, one of which (Exact Boxes) uses mixed-integer programming to provide an exact but fairly expensive solution; the other (Fast Boxes) uses a faster clustering method to generate the initial boxes, which are subsequently refined. Experimental results show that both algorithms perform very well among a large set of test datasets.</p>
<p>Earlier I mentioned that one approach to solving the imbalance problem is to discard the minority examples and treat it as a single-class (or anomaly detection) problem. One recent anomaly detection technique has worked surprisingly well for just that purpose. Liu, Ting and Zhou introduced a technique called Isolation Forests[6][6] that attempted to identify anomalies in data by learning random forests and then measuring the average number of decision splits required to isolate each particular data point. The resulting number can be used to calculate each data point’s anomaly score, which can also be interpreted as the likelihood that the example belongs to the minority class. Indeed, the authors tested their system using highly imbalanced data and reported very good results. A follow-up paper by Bandaragoda, Ting, Albrecht, Liu and Wells[7][7] introduced Nearest Neighbor Ensembles as a similar idea that was able to overcome several shortcomings of Isolation Forests.</p>
<h4 id="Buying-or-creating-more-data"><a href="#Buying-or-creating-more-data" class="headerlink" title="Buying or creating more data"></a>Buying or creating more data</h4><p>As a final note, this blog post has focused on situations of imbalanced classes under the tacit assumption that you’ve been given imbalanced data and you just have to tackle the imbalance. In some cases, as in a Kaggle competition, you’re given a fixed set of data and you can’t ask for more.</p>
<p>But you may face a related, harder problem: you simply don’t have enough examples of the rare class. None of the techniques above are likely to work. What do you do?</p>
<p>In some real world domains you may be able to buy or construct examples of the rare class. This is an area of ongoing research in machine learning. If rare data simply needs to be labeled reliably by people, a common approach is to crowdsource it via a service like Mechanical Turk. Reliability of human labels may be an issue, but work has been done in machine learning to combine human labels to optimize reliability. Finally, Claudia Perlich in her Strata talk All The Data and Still Not Enough gives examples of how problems with rare or non-existent data can be finessed by using surrogate variables or problems, essentially using proxies and latent variables to make seemingly impossible problems possible. Related to this is the strategy of using transfer learning to learn one problem and transfer the results to another problem with rare examples, as described here.</p>
<h4 id="Comments-or-questions"><a href="#Comments-or-questions" class="headerlink" title="Comments or questions?"></a>Comments or questions?</h4><p>Here, I have attempted to distill most of my practical knowledge into a single post. I know it was a lot, and I would value your feedback. Did I miss anything important? Any comments or questions on this blog post are welcome.</p>
<h4 id="Resources-and-further-reading"><a href="#Resources-and-further-reading" class="headerlink" title="Resources and further reading"></a>Resources and further reading</h4><ol>
<li><p>Several Jupyter notebooks are available illustrating aspects of imbalanced learning.</p>
<ul>
<li>A notebook illustrating sampled Gaussians, above, is at <a href="https://github.com/silicon-valley-data-science/learning-from-imbalanced-classes/blob/master/Gaussians.ipynb" target="_blank" rel="external">Gaussians.ipynb</a>.</li>
<li>A simple implementation of Wallace’s method is available at <a href="https://github.com/silicon-valley-data-science/learning-from-imbalanced-classes/blob/master/blagging.py" target="_blank" rel="external">blagging.py</a>. It is a simple fork of the existing bagging implementation of sklearn, specifically ./sklearn/ensemble/bagging.py.</li>
<li>A notebook using this method is available at <a href="https://github.com/silicon-valley-data-science/learning-from-imbalanced-classes/blob/master/ImbalancedClasses.ipynb" target="_blank" rel="external">ImbalancedClasses.ipynb</a>. It loads up several domains and compares blagging with other methods under different distributions.</li>
</ul>
</li>
<li><p>Source code for Box Drawings in MATLAB is available from: <a href="http://web.mit.edu/rudin/www/code/BoxDrawingsCode.zip" target="_blank" rel="external">http://web.mit.edu/rudin/www/code/BoxDrawingsCode.zip</a></p>
</li>
<li>Source code for Isolation Forests in R is available at: <a href="https://sourceforge.net/projects/iforest/" target="_blank" rel="external">https://sourceforge.net/projects/iforest/</a></li>
</ol>
<p>[1] Natalie Hockham makes this point in her talk Machine learning with imbalanced data sets, which focuses on imbalance in the context of credit card fraud detection.<br>[2] By definition there are fewer instances of the rare class, but the problem comes about because the cost of missing them (a false negative) is much higher.<br>[3] The details in courier are specific to Python’s Scikit-learn.<br>[4] “Class Imbalance, Redux”. Wallace, Small, Brodley and Trikalinos. IEEE Conf on Data Mining. 2011.<br>[5] Box Drawings for Learning with Imbalanced Data.” Siong Thye Goh and Cynthia Rudin. KDD-2014, August 24–27, 2014, New York, NY, USA.<br>[6] “Isolation-Based Anomaly Detection”. Liu, Ting and Zhou. ACM Transactions on Knowledge Discovery from Data, Vol. 6, No. 1. 2012.<br>[7] “Efficient Anomaly Detection by Isolation Using Nearest Neighbour Ensemble.” Bandaragoda, Ting, Albrecht, Liu and Wells. ICDM-2014</p>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="" href="/page/4/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/6/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a href="https://github.com/klugjo">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2018/08/13/消失的梯度/">消失的梯度</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/11/MobileNet-V1-and-V2-带来的卷积结构革命/">MobileNet V1 and V2 带来的卷积</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/09/卷积转置卷积关系在-TensorFLow-中的验证/">卷积转置卷积关系在 TensorFLow 中的验证</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/08/转置卷积-Transposed-Convolution/">转置卷积 Transposed Convoluti</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/klugjo/hexo-theme-alpha-dust">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://twitter.com/?lang=en">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.facebook.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.instagram.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://dribbble.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://plus.google.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-google-plus"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.behance.net/">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://500px.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>