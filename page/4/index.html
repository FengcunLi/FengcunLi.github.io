<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    

    <!--Author-->
    
        <meta name="author" content="Robert Lexis">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="This is Robert Lexis."/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="This is Robert Lexis."/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>page - This is Robert Lexis.</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">This is Robert Lexis.</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/03/01/C-内存管理/">
                C++内存管理
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-03-01</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h2><p>内存管理在C++中无处不在，内存泄漏几乎在每个C++程序中都会发生，因此要想成为C++高手，内存管理一关是必须要过的，除非放弃C++，转到Java或者.NET，他们的内存管理基本是自动的，当然你也放弃了自由和对内存的支配权，还放弃了C++超绝的性能。<br>本期专题将从内存管理、内存泄漏、内存回收这三个方面来探讨C++内存管理问题。</p>
<h3 id="1-内存管理"><a href="#1-内存管理" class="headerlink" title="1. 内存管理"></a>1. 内存管理</h3><h4 id="1-1-C-内存管理详解"><a href="#1-1-C-内存管理详解" class="headerlink" title="1.1 C++内存管理详解"></a>1.1 C++内存管理详解</h4><h5 id="1-1-1-内存分配方式"><a href="#1-1-1-内存分配方式" class="headerlink" title="1.1.1 内存分配方式"></a>1.1.1 内存分配方式</h5><h5 id="1-1-1-1-分配方式简介"><a href="#1-1-1-1-分配方式简介" class="headerlink" title="1.1.1.1 分配方式简介"></a>1.1.1.1 分配方式简介</h5><p>　　在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。</p>
<p>　　栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>
<p>　　堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p>
<p>　　自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。</p>
<p>　　全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。</p>
<p>　　常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。</p>
<h6 id="1-1-1-2-明确区分堆与栈"><a href="#1-1-1-2-明确区分堆与栈" class="headerlink" title="1.1.1.2 明确区分堆与栈"></a>1.1.1.2 明确区分堆与栈</h6><p>首先，我们举一个例子：</p>
<p>void f() { int* p=new int[5]; }</p>
<p>　　这条短短的一句话就包含了堆与栈，看到new，我们首先就应该想到，我们分配了一块堆内存，那么指针p呢？他分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针p。在程序会先确定在堆中分配内存的大小，然后调用operator new分配内存，然后返回这块内存的首地址，放入栈中，他在VC6下的汇编代码如下：</p>
<p>00401028 push 14h</p>
<p>0040102A call operator new (00401060)</p>
<p>0040102F add esp,4</p>
<p>00401032 mov dword ptr [ebp-8],eax</p>
<p>00401035 mov eax,dword ptr [ebp-8]</p>
<p>00401038 mov dword ptr [ebp-4],eax</p>
<p>　　这里，我们为了简单并没有释放内存，那么该怎么去释放呢？是delete p么？澳，错了，应该是delete []p，这是为了告诉编译器：我删除的是一个数组，VC6就会根据相应的Cookie信息去进行释放内存的工作。</p>
<h6 id="1-1-1-3-堆和栈究竟有什么区别？"><a href="#1-1-1-3-堆和栈究竟有什么区别？" class="headerlink" title="1.1.1.3 堆和栈究竟有什么区别？"></a>1.1.1.3 堆和栈究竟有什么区别？</h6><p>堆和栈究竟有什么区别？<br>主要的区别由以下几点：</p>
<ol>
<li>管理方式不同；</li>
<li>空间大小不同；</li>
<li>能否产生碎片不同；</li>
<li>生长方向不同；</li>
<li>分配方式不同；</li>
<li>分配效率不同；<br>管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。<br>空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改：<br>打开工程，依次操作菜单如下：Project-&gt;Setting-&gt;Link，在Category 中选中Output，然后在Reserve中设定堆栈的最大值和commit。<br>注意：reserve最小值为4Byte；commit是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。<br>碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。<br>生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。<br>分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 alloca 函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。<br>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。<br>从这里我们可以看到，堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP(扩展基址指针寄存器(extended base pointer) 其内存放一个指针，该指针指向系统栈最上面一个栈帧的底部)和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。<br>虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。<br>无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果。</li>
</ol>
<h5 id="1-1-2-控制C-的内存分配"><a href="#1-1-2-控制C-的内存分配" class="headerlink" title="1.1.2 控制C++的内存分配"></a>1.1.2 控制C++的内存分配</h5><p>在嵌入式系统中使用C++的一个常见问题是内存分配，即对 new 和 delete 操作符的失控。<br>具有讽刺意味的是，问题的根源却是C++对内存的管理非常的容易而且安全。具体地说，当一个对象被消除时，它的析构函数能够安全的释放所分配的内存。这当然是个好事情，但是这种使用的简单性使得程序员们过度使用new 和 delete，而不注意在嵌入式C++环境中的因果关系。并且，在嵌入式系统中，由于内存的限制，频繁的动态分配不定大小的内存会引起很大的问题以及堆破碎的风险。<br>作为忠告，保守的使用内存分配是嵌入式环境中的第一原则。但当你必须要使用new 和delete时，你不得不控制C++中的内存分配。<strong>你需要用一个全局的new 和delete来代替系统的内存分配符，并且一个类一个类的重载new 和delete。<br>一个防止堆破碎的通用方法是从不同固定大小的内存池中分配不同类型的对象。对每个类重载new 和delete就提供了这样的控制。</strong></p>
<h6 id="1-1-2-1-重载全局的new和delete操作符"><a href="#1-1-2-1-重载全局的new和delete操作符" class="headerlink" title="1.1.2.1 重载全局的new和delete操作符"></a>1.1.2.1 重载全局的new和delete操作符</h6><p>可以很容易地重载new 和 delete 操作符，如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void * operator new(size_t size)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">void *p = malloc(size);</div><div class="line"></div><div class="line">return (p);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">void operator delete(void *p);</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">free(p);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码可以代替默认的操作符来满足内存分配的请求。<br>也可以对单个类的new 和 delete 操作符重载。这是你能灵活的控制对象的内存分配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">class A</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    A(): name(&quot;Jasmine&quot;) &#123;&#125;;</div><div class="line">    ~A()&#123;&#125;;</div><div class="line">    void * operator new(size_t);</div><div class="line">    void operator delete(void*);</div><div class="line">    string name;</div><div class="line">&#125;;</div><div class="line">void * A::operator new(size_t size) &#123;</div><div class="line">    cout &lt;&lt; &quot;Newing&quot; &lt;&lt; endl;</div><div class="line">    void * p = malloc(size);</div><div class="line">    return p;</div><div class="line">&#125;</div><div class="line">void A::operator delete(void *p) &#123;</div><div class="line">    cout &lt;&lt; &quot;Deleting&quot; &lt;&lt; endl;</div><div class="line">    free(p);</div><div class="line">&#125;</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    A * a = new A;</div><div class="line">    cout &lt;&lt; a-&gt;name &lt;&lt; endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Newing</div><div class="line">Jasmine</div></pre></td></tr></table></figure></p>
<p>所有A 对象的内存分配都采用这段代码。更进一步，任何从A 继承的类也都采用这一方式，除非它自己也重载了new 和 delete 操作符。通过重载new 和 delete 操作符的方法，你可以自由地采用不同的分配策略，从不同的内存池中分配不同的类对象。</p>
<h6 id="1-1-2-2-为单个的类重载-new-和delete"><a href="#1-1-2-2-为单个的类重载-new-和delete" class="headerlink" title="1.1.2.2 为单个的类重载 new[ ]和delete[ ]"></a>1.1.2.2 为单个的类重载 new[ ]和delete[ ]</h6><p>必须小心对象数组的分配。你可能希望调用到被你重载过的new 和 delete 操作符，但并不如此。内存的请求被定向到全局的new[ ]和delete[ ] 操作符，而这些内存来自于系统堆。<br>C++将对象数组的内存分配作为一个单独的操作，而不同于单个对象的内存分配。为了改变这种方式，你同样需要重载new[ ] 和 delete[ ]操作符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class TestClass &#123;</div><div class="line">public:</div><div class="line">void * operator new[ ](size_t size);</div><div class="line">void operator delete[ ](void *p);</div><div class="line">// .. other members here ..</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void *TestClass::operator new[ ](size_t size)</div><div class="line">&#123;</div><div class="line">void *p = malloc(size);</div><div class="line">return (p);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void TestClass::operator delete[ ](void *p)</div><div class="line">&#123;</div><div class="line">free(p);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">TestClass *p = new TestClass[10];</div><div class="line">// ... etc ...</div><div class="line">delete[ ] p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是注意，对于多数C++的实现，new[]操作符中的个数参数是数组的大小加上额外的存储对象数目的一些字节。在你的内存分配机制中要考虑的这一点。你应该尽量避免分配对象数组，从而使你的内存分配策略简单。</p>
<h5 id="1-1-3-常见的内存错误及其对策"><a href="#1-1-3-常见的内存错误及其对策" class="headerlink" title="1.1.3 常见的内存错误及其对策"></a>1.1.3 常见的内存错误及其对策</h5><p>发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。有时用户怒气冲冲地把你找来，程序却没有发生任何问题，你一走，错误又发作了。 常见的内存错误及其对策如下：</p>
<ol>
<li>内存分配未成功，却使用了它。<br>编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。</li>
<li>内存分配虽然成功，但是尚未初始化就引用它。<br>犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。</li>
<li>内存分配成功并且已经初始化，但操作越过了内存的边界。<br>例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。</li>
<li>忘记了释放内存，造成内存泄露。<br>含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。</li>
<li>释放了内存却继续使用它。<br>有三种情况：<ul>
<li>程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。</li>
<li>函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。</li>
<li>使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。<br>　　【规则1】用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。<br>　　【规则2】不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。<br>　　【规则3】避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。<br>　　【规则4】动态内存的申请与释放必须配对，防止内存泄漏。<br>　　【规则5】用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。</li>
</ul>
</li>
</ol>
<h5 id="1-1-4-指针与数组的对比"><a href="#1-1-4-指针与数组的对比" class="headerlink" title="1.1.4 指针与数组的对比"></a>1.1.4 指针与数组的对比</h5><p>C++/C程序中，指针和数组在不少地方可以相互替换着用，让人产生一种错觉，以为两者是等价的。<br>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而不是指向）一块内存，其地址与容量在生命期内保持不变，只有数组的内容可以改变。<br>指针可以随时指向任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。<br>下面以字符串为例比较指针与数组的特性。</p>
<h6 id="1-1-4-1-修改内容"><a href="#1-1-4-1-修改内容" class="headerlink" title="1.1.4.1 修改内容"></a>1.1.4.1 修改内容</h6><p>下面示例中，字符数组a的容量是6个字符，其内容为hello。a的内容可以改变，如a[0]= ‘X’。指针p指向常量字符串“world”（位于静态存储区，内容为world），常量字符串的内容是不可以被修改的。从语法上看，编译器并不觉得语句p[0]= ‘X’有什么不妥，但是该语句企图修改常量字符串的内容而导致运行错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">char a[] = &quot;hello&quot;;</div><div class="line">a[0] = &apos;X&apos;;</div><div class="line">cout &lt;&lt; a &lt;&lt; endl;</div><div class="line">char *p = &quot;world&quot;; // 注意p指向常量字符串</div><div class="line">p[0] = &apos;X&apos;; // 编译器不能发现该错误，有的编译器会报出警告：</div><div class="line">// warning: ISO C++ forbids converting a string constant to &apos;char*&apos; [-Wwrite-strings]</div><div class="line">// 编译能够通过，但是会导致运行时错误。</div><div class="line">cout &lt;&lt; p &lt;&lt; endl;</div></pre></td></tr></table></figure></p>
<h6 id="1-1-4-2-内容复制与比较"><a href="#1-1-4-2-内容复制与比较" class="headerlink" title="1.1.4.2 内容复制与比较"></a>1.1.4.2 内容复制与比较</h6><p>不能对数组名进行直接复制与比较。若想把数组a的内容复制给数组b，不能用语句 b = a ，否则将产生编译错误。应该用标准库函数strcpy进行复制。同理，比较b和a的内容是否相同，不能用if(b==a) 来判断，应该用标准库函数strcmp进行比较。<br>语句p = a 并不能把a的内容复制指针p，而是把a的地址赋给了p。要想复制a的内容，可以先用库函数malloc为p申请一块容量为strlen(a)+1个字符的内存，再用strcpy进行字符串复制。同理，语句if(p==a) 比较的不是内容而是地址，应该用库函数strcmp来比较。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 数组</div><div class="line">char a[] = &quot;hello&quot;;</div><div class="line">char b[10];</div><div class="line">strcpy(b, a); // 不能用 b = a;</div><div class="line">if(strcmp(b, a) == 0) // 不能用 if (b == a)</div><div class="line"></div><div class="line">// 指针</div><div class="line">int len = strlen(a);</div><div class="line">char *p = (char *)malloc(sizeof(char)*(len+1));</div><div class="line">strcpy(p,a); // 不要用 p = a;</div><div class="line">if(strcmp(p, a) == 0) // 不要用 if (p == a)</div></pre></td></tr></table></figure></p>
<h6 id="1-1-4-3-计算内存容量"><a href="#1-1-4-3-计算内存容量" class="headerlink" title="1.1.4.3 计算内存容量"></a>1.1.4.3 计算内存容量</h6><p>用运算符sizeof可以计算出数组的容量（字节数）。如下示例中，sizeof(a)的值是12（注意别忘了’’）。指针p指向a，但是sizeof(p)的值却是4。这是因为sizeof(p)得到的是一个指针变量的字节数，相当于sizeof(char*)，而不是p所指的内存容量。C++/C语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">char a[] = &quot;hello world&quot;;</div><div class="line">char *p = a;</div><div class="line">cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12字节</div><div class="line">cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4字节</div></pre></td></tr></table></figure></p>
<p>注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。如下示例中，不论数组a的容量是多少，sizeof(a)始终等于sizeof(char *)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void Func(char a[100])</div><div class="line">&#123;</div><div class="line">　cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4字节而不是100字节</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="1-1-5-杜绝“野指针”"><a href="#1-1-5-杜绝“野指针”" class="headerlink" title="1.1.5 杜绝“野指针”"></a>1.1.5 杜绝“野指针”</h5><p>“野指针”不是NULL指针，是指向“垃圾”内存的指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，if语句对它不起作用。 “野指针”的成因主要有两种：</p>
<ol>
<li><p>指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">char *p = NULL;</div><div class="line">char *str = (char *) malloc(100);</div></pre></td></tr></table></figure>
</li>
<li><p>指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。</p>
</li>
<li>指针操作超越了变量的作用域范围。这种情况让人防不胜防，示例程序如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">class A</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    void Func(void)&#123; cout &lt;&lt; &quot;Func of class A&quot; &lt;&lt; endl; &#125;</div><div class="line">&#125;;</div><div class="line">void Test(void)</div><div class="line">&#123;</div><div class="line">    A *p;</div><div class="line">    &#123;</div><div class="line">        A a;</div><div class="line">        p = &amp;a; // 注意 a 的生命期</div><div class="line">    &#125;</div><div class="line">    p-&gt;Func(); // p是“野指针”</div><div class="line">&#125;</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    Test();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>函数Test在执行语句p-&gt;Func()时，对象a已经消失，而p是指向a的，所以p就成了“野指针”。但奇怪的是我运行这个程序时居然没有出错，这可能与编译器有关。</p>
<h5 id="1-1-7-有了malloc-free为什么还要new-delete？"><a href="#1-1-7-有了malloc-free为什么还要new-delete？" class="headerlink" title="1.1.7 有了malloc/free为什么还要new/delete？"></a>1.1.7 有了malloc/free为什么还要new/delete？</h5><p>malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。<br>对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不能够把执行构造函数和析构函数的任务强加于malloc/free。</p>
<p>因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。我们先看一看malloc/free和new/delete如何实现对象的动态内存管理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Obj</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Obj(void)&#123; cout &lt;&lt; &quot;Initialization&quot; &lt;&lt; endl; &#125;</div><div class="line">    ~Obj(void)&#123; cout &lt;&lt; &quot;Destroy&quot; &lt;&lt; endl; &#125;</div><div class="line">    void Initialize(void)&#123; cout &lt;&lt; &quot;Initialization&quot; &lt;&lt; endl; &#125;</div><div class="line">    void Destroy(void)&#123; cout &lt;&lt; &quot;Destroy&quot; &lt;&lt; endl; &#125;</div><div class="line">&#125;;</div><div class="line">void UseMallocFree(void)</div><div class="line">&#123;</div><div class="line">    Obj *a = (Obj *)malloc(sizeof(Obj)); // 申请动态内存</div><div class="line">    a-&gt;Initialize(); // 初始化</div><div class="line">    //…</div><div class="line">    a-&gt;Destroy(); // 清除工作</div><div class="line">    free(a); // 释放内存</div><div class="line">&#125;</div><div class="line">void UseNewDelete(void)</div><div class="line">&#123;</div><div class="line">    Obj *a = new Obj; // 申请动态内存并且初始化</div><div class="line">    //…</div><div class="line">    delete a; // 清除并且释放内存</div><div class="line">&#125;</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    UseNewDelete();</div><div class="line">    UseMallocFree();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="1-1-8-内存耗尽怎么办？"><a href="#1-1-8-内存耗尽怎么办？" class="headerlink" title="1.1.8 内存耗尽怎么办？"></a>1.1.8 内存耗尽怎么办？</h5><p>如果在申请动态内存时找不到足够大的内存块，malloc和new将返回NULL指针，宣告内存申请失败。通常有三种方式处理“内存耗尽”问题。</p>
<ol>
<li>判断指针是否为NULL，如果是则马上用return语句终止本函数。</li>
<li>判断指针是否为NULL，如果是则马上用exit(1)终止整个程序的运行。</li>
<li>为new和malloc设置异常处理函数。例如Visual C++可以用_set_new_hander函数为new设置用户自己定义的异常处理函数，也可以让malloc享用与new相同的异常处理函数。</li>
</ol>
<h5 id="1-1-9-new-delete的使用要点"><a href="#1-1-9-new-delete的使用要点" class="headerlink" title="1.1.9 new/delete的使用要点"></a>1.1.9 new/delete的使用要点</h5><p>如果用new创建对象数组，那么只能使用对象的无参数构造函数。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Obj *objects = new Obj[100]; // 创建100个动态对象</div><div class="line">不能写成：</div><div class="line">Obj *objects = new Obj[100](1);// 创建100个动态对象的同时赋初值1</div></pre></td></tr></table></figure></p>
<h4 id="1-2-C-中的健壮指针和资源管理"><a href="#1-2-C-中的健壮指针和资源管理" class="headerlink" title="1.2 C++中的健壮指针和资源管理"></a>1.2 C++中的健壮指针和资源管理</h4><h4 id="2-3浅谈C-C-内存泄漏及其检测工具"><a href="#2-3浅谈C-C-内存泄漏及其检测工具" class="headerlink" title="2.3浅谈C/C++内存泄漏及其检测工具"></a>2.3浅谈C/C++内存泄漏及其检测工具</h4><h5 id="2-3-1-内存泄漏的定义"><a href="#2-3-1-内存泄漏的定义" class="headerlink" title="2.3.1 内存泄漏的定义"></a>2.3.1 内存泄漏的定义</h5><p>一般我们常说的内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的，大小任意的（内存块的大小可以在程序运行期决定），使用完后必须显示释放的内存。应用程序一般使用malloc，realloc，new等函数从堆中分配到一块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了。<br>广义的说，内存泄漏不仅仅包含堆内存的泄漏，还包含系统资源的泄漏(resource leak)，比如核心态HANDLE，GDI Object，SOCKET， Interface等，从根本上说这些由操作系统分配的对象也消耗内存，如果这些对象发生泄漏最终也会导致内存的泄漏。而且，某些对象消耗的是核心态内存，这些对象严重泄漏时会导致整个操作系统不稳定。所以相比之下，系统资源的泄漏比堆内存的泄漏更为严重。</p>
<h5 id="2-3-3-检测内存泄漏"><a href="#2-3-3-检测内存泄漏" class="headerlink" title="2.3.3 检测内存泄漏"></a>2.3.3 检测内存泄漏</h5><p>　　检测内存泄漏的关键是要能截获住对分配内存和释放内存的函数的调用。截获住这两个函数，我们就能跟踪每一块内存的生命周期，比如，每当成功的分配一块内存后，就把它的指针加入一个全局的list中；每当释放一块内存，再把它的指针从list中删除。这样，当程序结束的时候，list中剩余的指针就是指向那些没有被释放的内存。这里只是简单的描述了检测内存泄漏的基本原理，详细的算法可以参见Steve Maguire的&lt;<writing solid="" code="">&gt;。<br>　　如果要检测堆内存的泄漏，那么需要截获住malloc/realloc/free和new/delete就可以了（其实new/delete最终也是用malloc/free的，所以只要截获前面一组即可）。对于其他的泄漏，可以采用类似的方法，截获住相应的分配和释放函数。比如，要检测BSTR的泄漏，就需要截获SysAllocString/SysFreeString；要检测HMENU的泄漏，就需要截获CreateMenu/ DestroyMenu。（有的资源的分配函数有多个，释放函数只有一个，比如，SysAllocStringLen也可以用来分配BSTR，这时就需要截获多个分配函数）<br>　　在Windows平台下，检测内存泄漏的工具常用的一般有三种，MS C-Runtime Library内建的检测功能；外挂式的检测工具，诸如，Purify，BoundsChecker等；利用Windows NT自带的Performance Monitor。这三种工具各有优缺点，MS C-Runtime Library虽然功能上较之外挂式的工具要弱，但是它是免费的；Performance Monitor虽然无法标示出发生问题的代码，但是它能检测出隐式的内存泄漏的存在，这是其他两类工具无能为力的地方。</writing></p>
<h6 id="2-3-3-1-VC下内存泄漏的检测方法"><a href="#2-3-3-1-VC下内存泄漏的检测方法" class="headerlink" title="2.3.3.1 VC下内存泄漏的检测方法"></a>2.3.3.1 VC下内存泄漏的检测方法</h6><p>用 MFC 开发的应用程序，在DEBUG版模式下编译后，都会自动加入内存泄漏的检测代码。在程序结束后，如果发生了内存泄漏，在Debug窗口中会显示出所有发生泄漏的内存块的信息，以下两行显示了一块被泄漏的内存块的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">E:&quot;TestMemLeak&quot;TestDlg.cpp(70) : &#123;59&#125; normal block at 0x00881710, 200 bytes long.</div><div class="line"></div><div class="line">Data: &lt;abcdefghijklmnop&gt; 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F 70</div></pre></td></tr></table></figure></p>
<p>第一行显示该内存块由TestDlg.cpp文件，第70行代码分配，地址在0x00881710，大小为200字节，{59}是指调用内存分配函数的Request Order，关于它的详细信息可以参见MSDN中_CrtSetBreakAlloc()的帮助。第二行显示该内存块前16个字节的内容，尖括号内是以ASCII方式显示，接着的是以16进制方式显示。<br>一般大家都误以为这些内存泄漏的检测功能是由MFC提供的，其实不然。MFC只是封装和利用了MS C-Runtime Library的Debug Function。非MFC程序也可以利用MS C-Runtime Library的Debug Function加入内存泄漏的检测功能。MS C-Runtime Library在实现malloc/free，strdup等函数时已经内建了内存泄漏的检测功能。</p>
<p>注意观察一下由MFC Application Wizard生成的项目，在每一个cpp文件的头部都有这样一段宏定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#ifdef _DEBUG</div><div class="line"></div><div class="line">#define new DEBUG_NEW</div><div class="line"></div><div class="line">#undef THIS_FILE</div><div class="line"></div><div class="line">static char THIS_FILE[] = __FILE__;</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>注：这里的 static 是很有意义的，仅限于此编译单元的语义使得，每个实现文件即调用new的文件中的代码都能正确的知道各自所在的不同文件名。<br>有了这样的定义，在编译DEBUG版时，出现在这个cpp文件中的所有new都被替换成DEBUG_NEW了。那么DEBUG_NEW是什么呢？DEBUG_NEW也是一个宏，以下摘自afx.h，1632行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define DEBUG_NEW new(THIS_FILE, __LINE__)</div></pre></td></tr></table></figure></p>
<p>所以如果有这样一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">char* p = new char[200];</div></pre></td></tr></table></figure></p>
<p>经过宏替换就变成了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">char* p = new( THIS_FILE, __LINE__)char[200];</div></pre></td></tr></table></figure></p>
<p>根据C++的标准，对于以上的new的使用方法，编译器会去找这样定义的operator new：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void* operator new(size_t, LPCSTR, int)</div></pre></td></tr></table></figure></p>
<p>我们在afxmem.cpp 63行找到了一个这样的operator new 的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">void* AFX_CDECL operator new(size_t nSize, LPCSTR lpszFileName, int nLine)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">　return ::operator new(nSize, _NORMAL_BLOCK, lpszFileName, nLine);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">void* __cdecl operator new(size_t nSize, int nType, LPCSTR lpszFileName, int nLine)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">　…</div><div class="line"></div><div class="line">　pResult = _malloc_dbg(nSize, nType, lpszFileName, nLine);</div><div class="line"></div><div class="line">　if (pResult != NULL)</div><div class="line"></div><div class="line">　　return pResult;</div><div class="line"></div><div class="line">　…</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二个 operator new 函数比较长，为了简单期间，我只摘录了部分。很显然最后的内存分配还是通过_malloc_dbg函数实现的，这个函数属于MS C-Runtime Library 的Debug Function。这个函数不但要求传入内存的大小，另外还有文件名和行号两个参数。文件名和行号就是用来记录此次分配是由哪一段代码造成的。如果这块内存在程序结束之前没有被释放，那么这些信息就会输出到Debug窗口里。<br>这里顺便提一下<code>THIS_FILE</code>，<code>__FILE</code>和<code>__LINE__</code>。<code>__FILE__</code>和<code>__LINE__</code>都是编译器定义的宏。当碰到<code>__FILE__</code>时，编译器会把<code>__FILE__</code>替换成一个字符串，这个字符串就是当前在编译的文件的路径名。当碰到<code>__LINE__</code>时，编译器会把<code>__LINE__</code>替换成一个数字，这个数字就是当前这行代码的行号。在DEBUG_NEW的定义中没有直接使用<code>__FILE__</code>，而是用了<code>THIS_FILE</code>，其目的是为了减小目标文件的大小。假设在某个cpp文件中有100处使用了new，如果直接使用<code>__FILE__</code>，那编译器会产生100个常量字符串，这100个字符串都是文件的路径名，显然十分冗余。如果使用<code>THIS_FILE</code>，编译器只会产生一个常量字符串，那100处new的调用使用的都是指向常量字符串的指针。<br>再次观察一下由MFC Application Wizard生成的项目，我们会发现在cpp文件中只对new做了映射，如果你在程序中直接使用malloc函数分配内存，调用malloc的文件名和行号是不会被记录下来的。如果这块内存发生了泄漏，MS C-Runtime Library仍然能检测到，但是当输出这块内存块的信息，不会包含分配它的的文件名和行号。<br>要在非MFC程序中打开内存泄漏的检测功能非常容易，你只要在程序的入口处加入以下几行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );</div><div class="line"></div><div class="line">tmpFlag |= _CRTDBG_LEAK_CHECK_DF;</div><div class="line"></div><div class="line">_CrtSetDbgFlag( tmpFlag );</div></pre></td></tr></table></figure></p>
<p>这样，在程序结束的时候，也就是winmain，main或dllmain函数返回之后，如果还有内存块没有释放，它们的信息会被打印到Debug窗口里。<br>如果你试着创建了一个非MFC应用程序，而且在程序的入口处加入了以上代码，并且故意在程序中不释放某些内存块，你会在Debug窗口里看到以下的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;47&#125; normal block at 0x00C91C90, 200 bytes long.</div><div class="line"></div><div class="line">Data: &lt; &gt; 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F</div></pre></td></tr></table></figure></p>
<p>内存泄漏的确检测到了，但是和上面MFC程序的例子相比，缺少了文件名和行号。对于一个比较大的程序，没有这些信息，解决问题将变得十分困难。<br>为了能够知道泄漏的内存块是在哪里分配的，你需要实现类似MFC的映射功能，把new，maolloc等函数映射到_malloc_dbg函数上。这里我不再赘述，你可以参考MFC的源代码。<br>由于Debug Function实现在MS C-RuntimeLibrary中，所以它只能检测到堆内存的泄漏，而且只限于malloc，realloc或strdup等分配的内存，而那些系统资源，比如HANDLE，GDI Object，或是不通过C-Runtime Library分配的内存，比如VARIANT，BSTR的泄漏，它是无法检测到的，这是这种检测法的一个重大的局限性。另外，为了能记录内存块是在哪里分配的，源代码必须相应的配合，这在调试一些老的程序非常麻烦，毕竟修改源代码不是一件省心的事，这是这种检测法的另一个局限性。<br>对于开发一个大型的程序，MS C-Runtime Library提供的检测功能是远远不够的。接下来我们就看看外挂式的检测工具。我用的比较多的是BoundsChecker，一则因为它的功能比较全面，更重要的是它的稳定性。这类工具如果不稳定，反而会忙里添乱。到底是出自鼎鼎大名的NuMega，我用下来基本上没有什么大问题。</p>
<h6 id="2-3-3-2-使用BoundsChecker检测内存泄漏"><a href="#2-3-3-2-使用BoundsChecker检测内存泄漏" class="headerlink" title="2.3.3.2 使用BoundsChecker检测内存泄漏"></a>2.3.3.2 使用BoundsChecker检测内存泄漏</h6><p>BoundsChecker采用一种被称为 Code Injection的技术，来截获对分配内存和释放内存的函数的调用。简单地说，当你的程序开始运行时，BoundsChecker的DLL被自动载入进程的地址空间（这可以通过system-level的Hook实现），然后它会修改进程中对内存分配和释放的函数调用，让这些调用首先转入它的代码，然后再执行原来的代码。BoundsChecker在做这些动作的时，无须修改被调试程序的源代码或工程配置文件，这使得使用它非常的简便、直接。<br>这里我们以malloc函数为例，截获其他的函数方法与此类似。<br>需要被截获的函数可能在DLL中，也可能在程序的代码里。比如，如果静态连结C-Runtime Library，那么malloc函数的代码会被连结到程序里。为了截获住对这类函数的调用，BoundsChecker会动态修改这些函数的指令。<br>以下两段汇编代码，一段没有BoundsChecker介入，另一段则有BoundsChecker的介入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">126: _CRTIMP void * __cdecl malloc (</div><div class="line"></div><div class="line">127: size_t nSize</div><div class="line"></div><div class="line">128: )</div><div class="line"></div><div class="line">129: &#123;</div><div class="line"></div><div class="line">00403C10 push ebp</div><div class="line"></div><div class="line">00403C11 mov ebp,esp</div><div class="line"></div><div class="line">130: return _nh_malloc_dbg(nSize, _newmode, _NORMAL_BLOCK, NULL, 0);</div><div class="line"></div><div class="line">00403C13 push 0</div><div class="line"></div><div class="line">00403C15 push 0</div><div class="line"></div><div class="line">00403C17 push 1</div><div class="line"></div><div class="line">00403C19 mov eax,[__newmode (0042376c)]</div><div class="line"></div><div class="line">00403C1E push eax</div><div class="line"></div><div class="line">00403C1F mov ecx,dword ptr [nSize]</div><div class="line"></div><div class="line">00403C22 push ecx</div><div class="line"></div><div class="line">00403C23 call _nh_malloc_dbg (00403c80)</div><div class="line"></div><div class="line">00403C28 add esp,14h</div><div class="line"></div><div class="line">131: &#125;</div></pre></td></tr></table></figure></p>
<p>以下这一段代码有BoundsChecker介入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">126: _CRTIMP void * __cdecl malloc (</div><div class="line"></div><div class="line">127: size_t nSize</div><div class="line"></div><div class="line">128: )</div><div class="line"></div><div class="line">129: &#123;</div><div class="line"></div><div class="line">00403C10 jmp 01F41EC8</div><div class="line"></div><div class="line">00403C15 push 0</div><div class="line"></div><div class="line">00403C17 push 1</div><div class="line"></div><div class="line">00403C19 mov eax,[__newmode (0042376c)]</div><div class="line"></div><div class="line">00403C1E push eax</div><div class="line"></div><div class="line">00403C1F mov ecx,dword ptr [nSize]</div><div class="line"></div><div class="line">00403C22 push ecx</div><div class="line"></div><div class="line">00403C23 call _nh_malloc_dbg (00403c80)</div><div class="line"></div><div class="line">00403C28 add esp,14h</div><div class="line"></div><div class="line">131: &#125;</div></pre></td></tr></table></figure></p>
<p>当BoundsChecker介入后，函数malloc的前三条汇编指令被替换成一条jmp指令，原来的三条指令被搬到地址01F41EC8处了。当程序进入malloc后先jmp到01F41EC8，执行原来的三条指令，然后就是BoundsChecker的天下了。大致上它会先记录函数的返回地址（函数的返回地址在stack上，所以很容易修改），然后把返回地址指向属于BoundsChecker的代码，接着跳到malloc函数原来的指令，也就是在00403c15的地方。当malloc函数结束的时候，由于返回地址被修改，它会返回到BoundsChecker的代码中，此时BoundsChecker会记录由malloc分配的内存的指针，然后再跳转到到原来的返回地址去。<br>如果内存分配/释放函数在DLL中，BoundsChecker则采用另一种方法来截获对这些函数的调用。BoundsChecker通过修改程序的DLL Import Table让table中的函数地址指向自己的地址，以达到截获的目的。<br>截获住这些分配和释放函数，BoundsChecker就能记录被分配的内存或资源的生命周期。接下来的问题是如何与源代码相关，也就是说当BoundsChecker检测到内存泄漏，它如何报告这块内存块是哪段代码分配的。答案是调试信息（Debug Information）。当我们编译一个Debug版的程序时，编译器会把源代码和二进制代码之间的对应关系记录下来，放到一个单独的文件里(.pdb)或者直接连结进目标程序，通过直接读取调试信息就能得到分配某块内存的源代码在哪个文件，哪一行上。使用Code Injection和Debug Information，使BoundsChecker不但能记录呼叫分配函数的源代码的位置，而且还能记录分配时的Call Stack，以及Call Stack上的函数的源代码位置。</p>
<h4 id="3-1-4-禁止产生堆对象"><a href="#3-1-4-禁止产生堆对象" class="headerlink" title="3.1.4 禁止产生堆对象"></a>3.1.4 禁止产生堆对象</h4><p>禁止堆对象的产生就是禁止 new 表达式正常执行，new 表达式和 delete 表达式我们根本就不能自定义它们的行为。但是由于 new表达式实际执行的动作有三个，delete 实际执行的动作有两个，我们可以通过禁止 new 表达式的第一个动作 operator new 和 delete 的第二个动作 operator delete 来禁止 new 表达式和delete 表达式的执行。对于 operator new 运算符和 operator delete 运算符我们是可以重载的。通过将其声明为类的私有方法，我们可以组织 new 表达式和 delete表达式从外部对它们的访问，从而禁止 new 表达式和 delete表达式的正确执行，禁止堆对象的产生。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Resource</div><div class="line">&#123;</div><div class="line">&#125;;</div><div class="line">class ResourceManager</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    ResourceManager() &#123;</div><div class="line">        ptr = new Resource;</div><div class="line">    &#125;;</div><div class="line">    ~ResourceManager() &#123;</div><div class="line">        delete ptr;</div><div class="line">    &#125;;</div><div class="line">private:</div><div class="line">    Resource* ptr;</div><div class="line">    void* operator new(size_t size)&#123;&#125;;</div><div class="line">    void operator delete(void *p)&#123;&#125;;</div><div class="line">&#125;;</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    // ResourceManager* rm = new ResourceManager;</div><div class="line">    ResourceManager rm;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-1-5-禁止产生栈对象"><a href="#3-1-5-禁止产生栈对象" class="headerlink" title="3.1.5 禁止产生栈对象"></a>3.1.5 禁止产生栈对象</h4><p>禁止栈对象的产生，允许堆对象的产生，就只能通过将类的构造函数和析构函数声明为私有或者受保护，这样就不能直接通过外部代码实例化一个栈对象了，但同时也禁止了new 表达式和 delete表达式的正常执行，不能通过外部的new 表达式和delete表达式调用到私有或者受保护的构造函数和析构函数。解决这一个问题的方式是将 new 和 delete 表达式放到类的方法（静态方法和普通方法）中进行调用，这样就可以访问到类的私有或者受保护的构造函数或者析构函数了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Resource</div><div class="line">&#123;</div><div class="line">&#125;;</div><div class="line">class ResourceManager</div><div class="line">&#123;</div><div class="line">protected:</div><div class="line">    ResourceManager() &#123;</div><div class="line">        ptr = new Resource;</div><div class="line">    &#125;;</div><div class="line">    ~ResourceManager() &#123;</div><div class="line">        delete ptr;</div><div class="line">    &#125;;</div><div class="line">public:</div><div class="line">    static ResourceManager* create_instance();</div><div class="line">    void destory() &#123;</div><div class="line">        // 这样就可以访问到 ~ResourceManager() 析构函数了</div><div class="line">        delete this;</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    Resource* ptr;</div><div class="line">&#125;;</div><div class="line">ResourceManager* ResourceManager::create_instance()</div><div class="line">&#123;</div><div class="line">    // 这样就可以访问到 ResourceManager() 构造函数了</div><div class="line">    return new ResourceManager;</div><div class="line">&#125;</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    // ResourceManager* rm = new ResourceManager;</div><div class="line">    // ResourceManager rm;</div><div class="line">    ResourceManager* rm_ptr = ResourceManager::create_instance();</div><div class="line">    /*code*/</div><div class="line">    rm_ptr-&gt;destory();</div><div class="line">    // 防止悬挂指针的出现</div><div class="line">    rm_ptr = nullptr;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/02/19/C-类型转换/">
                C++类型转换
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-02-19</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="类型转换可以分为-隐式类型转换和显式类型转换-强制类型转换"><a href="#类型转换可以分为-隐式类型转换和显式类型转换-强制类型转换" class="headerlink" title="类型转换可以分为:隐式类型转换和显式类型转换(强制类型转换)"></a>类型转换可以分为:隐式类型转换和显式类型转换(强制类型转换)</h3><p>隐式类型转换比较常见，在混合类型表达式中经常发生，比如在表达式中存在 short 和 int，那么就会发生整型提升。</p>
<h4 id="四种强制类型转换操作符：static-cast、dynamic-cast、const-cast、reinterpret-cast。"><a href="#四种强制类型转换操作符：static-cast、dynamic-cast、const-cast、reinterpret-cast。" class="headerlink" title="四种强制类型转换操作符：static_cast、dynamic_cast、const_cast、reinterpret_cast。"></a>四种强制类型转换操作符：static_cast、dynamic_cast、const_cast、reinterpret_cast。</h4><h4 id="static-cast-与-dynamic-cast"><a href="#static-cast-与-dynamic-cast" class="headerlink" title="static_cast 与 dynamic_cast"></a>static_cast 与 dynamic_cast</h4><p>把这两个放在一起比较容易记忆，”一静一动”，从字面上也可以看出，前者提供的是编译时期的静态类型检测，后者提供的是<br>运行时检测。<br>static_cast 完成以下类型</p>
<ol>
<li>基础数据类型 </li>
<li>同一个继承体系中的类型</li>
<li>任意类型与空指针类型void*之间的转换。<br>dynamic_cast 使用多态的场景，增加了一层对真实调用对象类型的检查<br><strong>C-like 的强制类型转换太“随意”了，而 C++ 的这四个对类型转换提供了相应的类型检查。</strong></li>
</ol>
<h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast:"></a>static_cast:</h4><ol>
<li>基础数据类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    char c  = 65;</div><div class="line">    int *p = (int *)&amp;c;</div><div class="line">    cout &lt;&lt; *p &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; (char)*p &lt;&lt; endl; //&apos;A&apos;</div><div class="line">    *p = 1644054338;</div><div class="line">    cout &lt;&lt; (char)*p &lt;&lt; endl; //&apos;B&apos;</div><div class="line">    *p = 5;</div><div class="line">    // 下面这一行会导致**运行时**错误</div><div class="line">    // cout &lt;&lt; (char)*p &lt;&lt; endl; //&apos;B&apos;</div><div class="line">    // int *q = static_cast&lt;int *&gt;(&amp;c); //编译报错: error: invalid static_cast from type ‘char*’ to type ‘int*’</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>static_cast 可以将错误在编译时期检查出。</p>
<ol>
<li>自定义类型<br><strong>不同继承体系：</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">class A</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    A()&#123;&#125;</div><div class="line">    ~A()&#123;&#125;</div><div class="line">    void printA()</div><div class="line">    &#123;</div><div class="line">        std::cout &lt;&lt;&quot;call printA() in class A&quot; &lt;&lt;std::endl;</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    int i, j;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class C</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    C()&#123;&#125;</div><div class="line">    ~C()&#123;&#125;</div><div class="line">    void printC()</div><div class="line">    &#123;</div><div class="line">        std::cout &lt;&lt;&quot;call printC() in class C&quot; &lt;&lt;std::endl;</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    char c1, c2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    A* ptrA = new A();</div><div class="line">    C* ptrC = (C*)ptrA;</div><div class="line">    //---------------------------------------//</div><div class="line">    ptrC-&gt;printC(); // &quot;call printC() in class C&quot;</div><div class="line">    // 下面一行会报出 error: &apos;class C&apos; has no member named &apos;printA&apos;; did you mean &apos;printC&apos;?</div><div class="line">    // ptrC-&gt;printA();</div><div class="line"></div><div class="line">    //---------------------------------------//</div><div class="line">    ptrA-&gt;printA(); // &quot;call printA() in class A&quot;</div><div class="line">    // 下面一行会报出 error: &apos;class A&apos; has no member named &apos;printC&apos;; did you mean &apos;printA&apos;?</div><div class="line">    // ptrA-&gt;printC();</div><div class="line">    // 上面的测试证明，怎么和具体对象的类型没有了关系，而只与指针的类型有关了？</div><div class="line"></div><div class="line">    //ptrC = static_cast&lt;C*&gt;(ptrA); //编译报错: error: invalid static_cast from type &apos;A*’ to type C*’</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上面A、C是两个无关的类，然而使用 C-like 可以实现这种类型的强制转换，这是十分危险的! 使用static_cast 可以将这种潜在的危险在编译期找出来。<br><strong>同一继承体系：</strong></p>
<ul>
<li>upcast(向上转换即子类转成父类)：这个对象本身是子类对象，但是你“强行”将其 cast 成父类指针，当通过父类的指针调用父类的方法时，由于父类方法中所需的全部成员变量或者成员函数，都是有定义的，因此方法的行为是有定义的。</li>
<li>downcast(向下转换)：有可能会出现问题，编译时可能不会发现，这个对象本身是父类的对象，当通过子类的指针调用子类的方法时，方法所需的成员变量或者成员函数不一定在父类对象中有定义，所以就有可能导致方法的行为无定义。<br>上面是子类类型的指针调用子类的方法，父类类型的指针调用父类的方法。<br>下面是两者的交叉行为：</li>
<li>当通过父类的指针调用子类特有的方法时就会报出 has no member named 的错误。</li>
<li>当通过子类的指针调用父类的方法时，没有一点问题。<br>一个类的行为和自身的类型相关，就是一个A类型的指针总会优先调用自己A类内的函数，当然继承中的虚函数例外。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line">class A</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    A():i(1), j(1)&#123;&#125;</div><div class="line">    ~A()&#123;&#125;</div><div class="line">    void printA()</div><div class="line">    &#123;</div><div class="line">        std::cout &lt;&lt; &quot;call printA() in class A&quot; &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">    void printSum()</div><div class="line">    &#123;</div><div class="line">        std::cout &lt;&lt; &quot;sum = in class A: &quot; &lt;&lt; i+j &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    int i, j;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class B : public A</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    B():a(2), b(2) &#123;&#125;</div><div class="line">    ~B()&#123;&#125;</div><div class="line">    void printB()</div><div class="line">    &#123;</div><div class="line">        std::cout &lt;&lt; &quot;call printB() in class B&quot; &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">    void printSum()</div><div class="line">    &#123;</div><div class="line">        std::cout &lt;&lt; &quot;sum = in class B: &quot; &lt;&lt; a+b &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">    void Add()</div><div class="line">    &#123;</div><div class="line">        a++;</div><div class="line">        b++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private:</div><div class="line">  double a, b;</div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    A *ptrA=nullptr;</div><div class="line">    B *ptrB=nullptr;</div><div class="line">    </div><div class="line">    ptrB = new B;</div><div class="line">    ptrB -&gt; printSum();</div><div class="line">    ptrA = static_cast&lt;A *&gt;(ptrB);</div><div class="line">    ptrA -&gt; printA();</div><div class="line">    ptrA -&gt; printSum();</div><div class="line">    std::cout &lt;&lt; &quot;-------&quot; &lt;&lt; std::endl;</div><div class="line">    //打印结果：sum = 2</div><div class="line">    //在进行 upcast 的时候，行为与指针类型相关。</div><div class="line"></div><div class="line">    ptrA = new A;</div><div class="line">    ptrB = static_cast&lt;B *&gt;(ptrA);</div><div class="line">    ptrB -&gt; printB();</div><div class="line">    ptrB -&gt; printSum();</div><div class="line">    //打印结果：sum = 0</div><div class="line">    //在进行 downcast 的时候，调用的函数是对的，但是值不对，是因为确实无法正确地找到值。</div><div class="line"></div><div class="line">    std::cout &lt;&lt; &quot;#######&quot; &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    B b;</div><div class="line">    B &amp; rB = b;</div><div class="line">    rB.printSum();</div><div class="line">    A &amp; rA = static_cast&lt;A &amp;&gt;(b);</div><div class="line">    rA.printA();</div><div class="line">    rA.printSum();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; &quot;+++++++&quot; &lt;&lt; std::endl;</div><div class="line">    </div><div class="line">    A a;</div><div class="line">    A &amp; rA1 = a;</div><div class="line">    rA1.printSum();</div><div class="line">    B &amp; rB1 = static_cast&lt;B &amp;&gt;(a);</div><div class="line">    rB1.printB();</div><div class="line">    rB1.printSum();</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">sum = in class B: 4</div><div class="line">call printA() in class A</div><div class="line">sum = in class A: 2</div><div class="line">-------</div><div class="line">call printB() in class B</div><div class="line">sum = in class B: 2.01105e-317</div><div class="line">#######</div><div class="line">sum = in class B: 4</div><div class="line">call printA() in class A</div><div class="line">sum = in class A: 2</div><div class="line">+++++++</div><div class="line">sum = in class A: 2</div><div class="line">call printB() in class B</div><div class="line">sum = in class B: 2</div></pre></td></tr></table></figure></p>
<h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><ol>
<li>dynamic_cast 是在运行时检查的，用于在继承体系中进行安全的向下转换，即：基类指针/引用 -&gt; 派生类指针/引用，如果源和目标没有继承/被继承关系，编译器会报错！</li>
<li>dynamic_cast 是4个转换中唯一的RTTI操作符，提供运行时类型检查。</li>
<li>dynamic_cast不是强制转换，而是带有某种”咨询“性质的，如果不能转换，返回NULL。这是强制转换做不到的。</li>
<li>源类中必须要有虚函数，保证多态，才能使用dynamic_cast<source>(expression)。</li>
</ol>
<h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><p>仅仅是复制 n 的比特位到 d_r，没有进行必要的分析，interpret_cast 是映射到一个完全不同类型<br>的意思，这是所有映射中最危险的。</p>
<h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h4><p>去除 const 常量属性，使其可以修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class A &#123;</div><div class="line">    public:</div><div class="line">    A()&#123;&#125;;</div><div class="line">    int m_a;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class B &#123;</div><div class="line">    public:</div><div class="line">    int m_b;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class C : public A, public B &#123;&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    const A a;</div><div class="line">    // a.m_a = 1;</div><div class="line">    A &amp; a_ref = const_cast&lt;A &amp;&gt;(a);</div><div class="line">    a_ref.m_a = 2;</div><div class="line">    // a.m_a = 3; // 编译不能通过</div><div class="line">    cout &lt;&lt; a.m_a &lt;&lt;endl;</div><div class="line">    int n = 9;</div><div class="line">    double d_s = static_cast&lt;double&gt;(n);</div><div class="line">    double d_r = reinterpret_cast&lt;double&amp;&gt;(n);</div><div class="line">    cout &lt;&lt; d_s &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; d_r &lt;&lt; endl;//4.24399e-314</div><div class="line">    // 在进行计算以后, d_r 包含无用值. 这是因为 reinterpret_cast 仅仅是复制n的比特位到d_r, </div><div class="line">    // 没有进行必要的分析.</div><div class="line"></div><div class="line">    C c;</div><div class="line">    printf(&quot;%p, %p, %p\n&quot;, &amp;c, reinterpret_cast&lt;B*&gt;(&amp;c), static_cast&lt;B*&gt;(&amp;c));</div><div class="line">    // 前两个的输出值是相同的，最后一个则会在原基础上偏移4个字节，这是因为static_cast计算了父子类指针转换的偏移量,</div><div class="line">    // 并将之转换到正确的地址（c里面有m_a, m_b, 转换为 B* 指针后指到 m_b 处），而 reinterpret_cast 却不会做这一层转换.</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/02/17/多线程编程/">
                多线程编程
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-02-17</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h3><h4 id="lock-guard、unique-lock：互斥对象管理类模板"><a href="#lock-guard、unique-lock：互斥对象管理类模板" class="headerlink" title="lock_guard、unique_lock：互斥对象管理类模板"></a>lock_guard、unique_lock：互斥对象管理类模板</h4><ol>
<li>std::lock_guard，与 Mutex RAII 相关，方便线程对互斥量上锁。</li>
<li>std::unique_lock，与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。</li>
</ol>
<p>另外还提供了几个与锁类型相关的 Tag 类，分别如下:</p>
<ol>
<li>std::adopt_lock_t，一个空的标记类，定义为 <code>struct adopt_lock_t {};</code><br>该类型的常量对象adopt_lock，定义为 <code>constexpr adopt_lock_t adopt_lock {};</code>，通常作为参数传入给 unique_lock 或 lock_guard 的构造函数。</li>
<li>std::defer_lock_t，一个空的标记类，定义为 <code>structdefer_lock_t {};</code> 该类型的常量对象 defer_lock 定义为<br><code>constexpr defer_lock_t defer_lock {};</code>，通常作为参数传入给 unique_lock 或 lock_guard 的构造函数。</li>
<li>std::try_to_lock_t，一个空的标记类，定义为<code>structtry_to_lock_t {};</code>，该类型的常量对象 try_to_lock 定义为<br><code>constexpr try_to_lock_t try_to_lock {};</code>，通常作为参数传入给 unique_lock 或 lock_guard 的构造函数。</li>
</ol>
<h5 id="lock-guard-类模板-基于作用域"><a href="#lock-guard-类模板-基于作用域" class="headerlink" title="lock_guard 类模板 基于作用域"></a>lock_guard 类模板 基于作用域</h5><p>声明为 <code>template&lt;class Mutex&gt; class lock_guard;</code><br>在某个 lock_guard 对象的生命周期内，它所管理的锁对象会一直保持上锁状态；而 lock_guard 的生命周期结束之后，它所管理的锁对象会被解锁(注：类似 shared_ptr 等智能指针管理动态分配的内存资源 )。</p>
<p>模板参数 Mutex 代表互斥类型，例如 std::mutex 类型，它应该是一个基本的 BasicLockable 类型，标准库中定义几种基本的 BasicLockable 类型，分别 std::mutex, std::recursive_mutex, std::timed_mutex，std::recursive_timed_mutex 以及 std::unique_lock。</p>
<ol>
<li>BasicLockable 类型，只需满足两种操作 lock 和 unlock</li>
<li>Lockable 类型，在 BasicLockable 类型的基础上新增了 try_lock 操作</li>
<li>TimedLockable 类型，在 Lockable 类型的基础上又新增了 try_lock_for 和 try_lock_until 两种操作</li>
</ol>
<p>工作原理：</p>
<ol>
<li>在 lock_guard 对象构造时，传入的 Mutex 对象(即<strong>互斥对象管理模板类对象</strong>所管理的 Mutex 对象)会被当前线程锁住</li>
<li>在 lock_guard 对象被析构时，它所管理的 Mutex 对象会自动解锁</li>
<li>由于不需要程序员手动调用 lock 和 unlock 对 Mutex 对象 进行上锁和解锁操作，因此这也是最简单安全的上锁和解锁方式，尤其是在程序抛出异常后先前已被上锁的 Mutex 对象可以正确进行解锁操作，极大地简化了程序员编写与 Mutex 相关的异常处理代码。</li>
<li>值得注意的是，lock_guard 对象并不负责管理 Mutex 对象的生命周期<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;  // 使用复合语句块封装临界区操作，块结束时即释放局部对象</div><div class="line">    std::lock_guard&lt;std::mutex&gt;  locker( x );    //  构造对象的同时加锁</div><div class="line">    *r = _x + _y;</div><div class="line"> &#125; // 无需手工解锁，locker对象在析构时自动解锁</div></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="std-lock-guard-构造函数"><a href="#std-lock-guard-构造函数" class="headerlink" title="std::lock_guard 构造函数"></a>std::lock_guard 构造函数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">locking (1) </div><div class="line">explicit lock_guard (mutex_type&amp; m);</div><div class="line">adopting (2)    </div><div class="line">lock_guard (mutex_type&amp; m, adopt_lock_t tag);</div><div class="line">copy [deleted](3)   </div><div class="line">lock_guard (const lock_guard&amp;) = delete;</div></pre></td></tr></table></figure>
<ol>
<li>locking 初始化<br>lock_guard 对象管理 Mutex 对象 m，并在构造时对 m 进行上锁（调用 m.lock()）。<br>adopting初始化</li>
<li>lock_guard 对象管理 Mutex 对象 m，与 locking 初始化(1) 不同的是， 不加锁，假定<strong>当前</strong>线程已获得锁的所有权，即Mutex 对象 m 已被<strong>当前</strong>线程锁住。</li>
<li>拷贝构造<br>lock_guard 对象的拷贝构造和移动构造均被禁用，因此 lock_guard 对象不可被拷贝构造或移动构造，所有权不可转移。</li>
</ol>
<h5 id="unique-lock-（独一锁）类模板"><a href="#unique-lock-（独一锁）类模板" class="headerlink" title="unique_lock （独一锁）类模板"></a>unique_lock （独一锁）类模板</h5><p>unique_lock 对象以独占所有权的方式（unique owership）管理 Mutex 对象的上锁和解锁操作，所谓独占所有权，就是没有其他的 unique_lock 对象同时拥有某个 Mutex 对象的所有权。<br>在构造(或移动(move)赋值)时，unique_lock 需要传递一个 Mutex 对象作为它的参数，新创建的 unique_lock 对象负责传入的 Mutex 对象的上锁和解锁操作。<br>std::unique_lock 对象也能保证在其自身析构时它所管理的 Mutex 对象能够被正确地解锁（即使没有显式地调用 unlock 函数）。因此，和 lock_guard 一样，这也是一种简单安全的上锁和解锁方式，尤其是在程序抛出异常后先前已被上锁的 Mutex 对象可以正确进行解锁操作，极大地简化了程序员编写与 Mutex 相关的异常处理代码。<br>值得注意的是，unique_lock 对象同样也不负责管理 Mutex 对象的生命周期</p>
<h6 id="std-unique-lock-构造函数"><a href="#std-unique-lock-构造函数" class="headerlink" title="std::unique_lock 构造函数"></a>std::unique_lock 构造函数</h6><p>std::unique_lock 的构造函数的数目相对来说比 std::lock_guard 多：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">default (1) </div><div class="line">    unique_lock() noexcept;</div><div class="line">locking (2) </div><div class="line">    explicit unique_lock(mutex_type&amp; m);</div><div class="line">try-locking (3) </div><div class="line">    unique_lock(mutex_type&amp; m, try_to_lock_t tag);</div><div class="line">deferred (4)    </div><div class="line">    unique_lock(mutex_type&amp; m, defer_lock_t tag) noexcept;</div><div class="line">adopting (5)    </div><div class="line">    unique_lock(mutex_type&amp; m, adopt_lock_t tag);</div><div class="line">locking for (6) </div><div class="line">    template &lt;class Rep, class Period&gt;</div><div class="line">    unique_lock(mutex_type&amp; m, const chrono::duration&lt;Rep,Period&gt;&amp; rel_time);</div><div class="line">locking until (7)   </div><div class="line">    template &lt;class Clock, class Duration&gt;</div><div class="line">    unique_lock(mutex_type&amp; m, const chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time);</div><div class="line">copy [deleted] (8)  </div><div class="line">    unique_lock(const unique_lock&amp;) = delete;</div><div class="line">move (9)    </div><div class="line">    unique_lock(unique_lock&amp;&amp; x);</div></pre></td></tr></table></figure></p>
<p>下面来分别介绍以上各个构造函数：<br>(1) 默认构造函数<br>新创建的 unique_lock 对象不管理任何 Mutex 对象。<br>(2) locking 初始化<br>新创建的 unique_lock 对象管理 Mutex 对象 m，并尝试调用 m.lock() 对 Mutex 对象进行上锁，如果此时另外某个 unique_lock 对象已经管理了该 Mutex 对象 m，则当前线程将会被阻塞。<br>(3) try-locking 初始化<br>新创建的 unique_lock 对象管理 Mutex 对象 m，并尝试调用 m.try_lock() 对 Mutex 对象进行上锁，但如果上锁不成功，并不会阻塞当前线程。<br>(4) deferred 初始化<br>新创建的 unique_lock 对象管理 Mutex 对象 m，但是在初始化的时候并不锁住 Mutex 对象。 m 应该是一个没有<strong>当前</strong>线程锁住的 Mutex 对象。<br>(5) adopting 初始化<br>新创建的 unique_lock 对象管理 Mutex 对象 m， m 应该（假定）是一个已经被<strong>当前</strong>线程锁住的 Mutex 对象。(并且当前新创建的 unique_lock 对象拥有锁(Lock)的所有权)。<br>(6) locking 一段时间(duration)<br>新创建的 unique_lock 对象管理 Mutex 对象 m，并试图通过调用 m.try_lock_for(rel_time) 来锁住 Mutex 对象一段时间(rel_time)。<br>(7) locking 直到某个时间点(time point)<br>新创建的 unique_lock 对象管理 Mutex 对象m，并试图通过调用 m.try_lock_until(abs_time) 来在某个时间点(abs_time)之前锁住 Mutex 对象。<br>(8) 拷贝构造 [被禁用]<br>unique_lock 对象不能被拷贝构造。<br>(9) 移动(move)构造<br>新创建的 unique_lock 对象获得了由 x 所管理的 Mutex 对象的所有权(包括当前 Mutex 的状态)。调用 move 构造之后， x 对象如同是通过默认构造函数所创建的，就不再管理任何 Mutex 对象了，即被窃取了资源，之后 x 应该被析构或者去管理新的Mutex 对象（或者再将资源切窃取回来）。<br>综上所述，由 (2) 和 (5) 创建的 unique_lock 对象通常拥有 Mutex 对象的锁。而通过 (1) 和 (4) 创建的则不会拥有锁。通过 (3)，(6) 和 (7) 创建的 unique_lock 对象，则在 lock 成功时获得锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#include &lt;thread&gt;</div><div class="line">#include &lt;mutex&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">std::mutex foo,bar;  </div><div class="line">void task_a() &#123;  </div><div class="line">    std::lock(foo, bar);//foo和bar已被当前线程锁住  </div><div class="line">    /******************************************************* </div><div class="line">    *adopting 初始化: </div><div class="line">    *adopt_lock 是一个常量对象,通常作为参数传入给unique_lock 或  </div><div class="line">    *lock_guard 的构造函数。新创建的 unique_lock 对象管理 Mutex  </div><div class="line">    *对象 m， m 应该是一个已经被当前线程锁住的 Mutex 对象。 </div><div class="line">    *******************************************************/  </div><div class="line">    std::unique_lock&lt;std::mutex&gt; lck1(foo, std::adopt_lock);  </div><div class="line">    std::unique_lock&lt;std::mutex&gt; lck2(bar, std::adopt_lock);  </div><div class="line">    std::cout &lt;&lt; &quot;task a\n&quot;;  </div><div class="line">&#125;  </div><div class="line">void task_b() &#123;  </div><div class="line">    //新创建的 unique_lock 对象不管理任何 Mutex 对象。  </div><div class="line">    std::unique_lock&lt;std::mutex&gt; lck1, lck2;  </div><div class="line">    /****************************************************** </div><div class="line">    * deferred 初始化: </div><div class="line">    *新创建的 unique_lock 对象管理 Mutex 对象 m，但是在初始化 </div><div class="line">    *的时候并不锁住 Mutex 对象。 m 应该是一个没有**当前**线程锁住的  </div><div class="line">    *Mutex 对象。 </div><div class="line">    ******************************************************/  </div><div class="line">    // 等号右边是临时对象，即不具名，调用了移动赋值运算符，进行了资源的窃取（锁所有权的转移）</div><div class="line">    // 然后临时对象就被析构了，如此窃取其资源是安全的。</div><div class="line">    lck1 = std::unique_lock&lt;std::mutex&gt;(bar, std::defer_lock);  </div><div class="line">    lck2 = std::unique_lock&lt;std::mutex&gt;(foo, std::defer_lock);  </div><div class="line">    std::lock(lck1, lck2);</div><div class="line">    std::cout &lt;&lt; &quot;task b\n&quot;;</div><div class="line">&#125;  </div><div class="line">int main() &#123;  </div><div class="line">    std::thread th1(task_a);  </div><div class="line">    std::thread th2(task_b);  </div><div class="line">    th1.join();  </div><div class="line">    th2.join();  </div><div class="line">    return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="乐观锁和悲观锁的区别"><a href="#乐观锁和悲观锁的区别" class="headerlink" title="乐观锁和悲观锁的区别"></a>乐观锁和悲观锁的区别</h4><ol>
<li>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</li>
<li>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于 write_condition 机制的其实都是提供的乐观锁。</li>
<li>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，即写的太多了，上层应用会不断的进行 retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。<br>乐观锁，使用版本标识来确定<strong>读时读到的数据</strong>与<strong>提交时的数据</strong>是否一致。<br>提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。<br>记录1，id,status1,status2,stauts3,version，表示有三个不同的状态，以及数据当前的版本<br>操作1：update table set status1=1,status2=0,status3=0 where id=111;<br>操作2：update table set status1=0,status2=1,status3=0 where id=111;<br>操作3：update table set status1=0,status2=0,status3=1 where id=111;<br>没有任何控制的情况下，顺序执行3个操作，最后前两个操作会被直接覆盖。<br>加上version字段，每一次的操作都会更新version，提交时如果version不匹配，停止本次提交，可以尝试下一次的提交，以保证拿到的是操作1提交后的结果。</li>
</ol>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/02/11/C-类型转换操作符的重载/">
                C++类型转换操作符的重载
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-02-11</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="C-的类型转换运算符的重载"><a href="#C-的类型转换运算符的重载" class="headerlink" title="C++ 的类型转换运算符的重载"></a>C++ 的类型转换运算符的重载</h2><h3 id="类型转换可以通过类型转换运算符和构造函数两种方式完成"><a href="#类型转换可以通过类型转换运算符和构造函数两种方式完成" class="headerlink" title="类型转换可以通过类型转换运算符和构造函数两种方式完成"></a>类型转换可以通过类型转换运算符和构造函数两种方式完成</h3><p>在需要做数据类型转换时，一般显式的写法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">type2 d;  </div><div class="line">i = (type1)d; // 显式的类型转换，把 d 从 type2 类型转为 type1 类型</div></pre></td></tr></table></figure></p>
<p>这种写法不能做到隐式转换，也就是直接写 i = d。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">class Integer  </div><div class="line">&#123;  </div><div class="line">public:  </div><div class="line">    Integer(int v);  </div><div class="line">    Integer&amp; opetaror=(const int &amp;v); //重载赋值运算符，可以做到 Integer i = 10（错）; 这里原博文博主犯了一个错误，Integer it = 10 调用的是构造函数而不是赋值运算符，因为有新对象的生成必然有构造函数的调用。</div><div class="line">    Integer it; it=10; 也是错误的，这是因为 10 不是一个变量，不存在对其的引用。</div><div class="line">    正确的说法是： Integer it; int i=10; it=i;</div><div class="line">    operator int(); // 重载类型转换运算符，可以做到 int i; Integer it;  i = it;</div><div class="line">private:  </div><div class="line">    int data;</div><div class="line">&#125;;</div><div class="line">Integer::Integer(int v)</div><div class="line">&#123;  </div><div class="line">    data = v;</div><div class="line">&#125;  </div><div class="line"></div><div class="line">Integer&amp; Integer::opetaror =(const int &amp;v)  </div><div class="line">&#123;  </div><div class="line">    data = v;  </div><div class="line">    return *this;  </div><div class="line">&#125;  </div><div class="line">Integer::operator int()</div><div class="line">&#123;  </div><div class="line">    return data;  </div><div class="line">&#125;  </div><div class="line"> </div><div class="line">#include &lt;iostream&gt;  </div><div class="line">using namespace std;  </div><div class="line">  </div><div class="line">int main()  </div><div class="line">&#123;  </div><div class="line">    Integer integer1(10);</div><div class="line">    Integer integer2;  </div><div class="line">    int i1 = 10;  </div><div class="line">    integer2 = i1;</div><div class="line">  </div><div class="line">    int i2;  </div><div class="line">    i2 = integer1; //integer1是Integer类型，这里隐式把Integer类型转换为int，然后赋值给i2  </div><div class="line">                   //如果没有重载了int()，需要类型转换的话，这里必须写成 i2 = (int)integer1;</div><div class="line">    return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="重载类型转换需要注意的问题"><a href="#重载类型转换需要注意的问题" class="headerlink" title="重载类型转换需要注意的问题"></a>重载类型转换需要注意的问题</h3><p>转换函数采用如下通用形式: <code>operator type();</code><br>这里，type表示内置类型、类类型或有类型别名。一般而言，不允许转换为数组或函数类型，转换为指针类型(数组和函数指针)以及引用类型是可以的。</p>
<p>注解：</p>
<ol>
<li>转换函数必须是成员函数</li>
<li>不能指定返回类型</li>
<li>形参列表必须为空。<br>下述所有的声明都是错误的：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">operator int(Small Int&amp;); // error:nonmember</div><div class="line">class SmallInt</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    int operator int(); // error: return list</div><div class="line">    operator int(int = 0);  // error:parameter list</div><div class="line">// ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>虽然转换函数不能指定返回类型，但是每个转换函数必须显式返回一个指定的值。例如，operator int 返回一个int值；如果定义operator Sales_item,它将返回一个Sales_item对象，诸如此类。</p>
<h3 id="最佳实践-转换函数一般不应该改变被转换的对象。因此，类型转换运算符通常应定义为const成员。"><a href="#最佳实践-转换函数一般不应该改变被转换的对象。因此，类型转换运算符通常应定义为const成员。" class="headerlink" title="最佳实践: 转换函数一般不应该改变被转换的对象。因此，类型转换运算符通常应定义为const成员。"></a>最佳实践: 转换函数一般不应该改变被转换的对象。因此，类型转换运算符通常应定义为const成员。</h3><ol>
<li>使用类类型转换<br>只要存在转换，编译器将在可以使用隐式转换的地方自动调用它<br>在表达式中:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SmallInt si;</div><div class="line">double dval;</div><div class="line">si &gt;= dval // si converted to int and then convert to bool</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在条件中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if(si) // si convert to int and then convert to bool</div></pre></td></tr></table></figure></p>
<p>将实参传给函数或从函数返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int calc(int);</div><div class="line">SmallInt si;</div><div class="line">int i = calc(si); // convert si to int and call calc</div></pre></td></tr></table></figure></p>
<p>作为重载运算符的运算数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// convert si to int then call &lt;&lt; on the int value</div><div class="line"></div><div class="line">cout &lt;&lt; si &lt;&lt; endl;</div></pre></td></tr></table></figure></p>
<p>在显示类型转换中:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">int ival;</div><div class="line"></div><div class="line">SmallInt si = 3.54;</div><div class="line"></div><div class="line">// instruct compiler to cast si to int</div><div class="line"></div><div class="line">ival = static_cast&lt;int&gt;(si) + 3;</div></pre></td></tr></table></figure></p>
<ol>
<li>使用类类型转换和标准转换<br>使用转换函数时，被转换的类型不必与所在需要的类型完全匹配。必要时可在类类型转换之后跟上标准转换以获得想要的类型。例如，在一个SmallInt对象与一个double值的比较中：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SmallInt si;</div><div class="line"></div><div class="line">double dval;</div><div class="line"></div><div class="line">si &gt;= dval // si converted to int and then convert to double.</div></pre></td></tr></table></figure>
</li>
</ol>
<p>首先将si从SmallInt对象转换为int值，然后将该int值转换为double值。</p>
<ol>
<li>只能应用一个类类型转换<br>类类型转换之后再跟另一个类类型转换。如果需要多个类类型转换，则代码将出错。<br>例如，假定有一个类Integral,它可以转换为SmallInt但不能转换为int:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// class to hold unsigned integral values</div><div class="line">class Integral</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Integral(int i = 0):val(i)&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    operator SmallInt() const</div><div class="line">    &#123;</div><div class="line">        return val % 256; // 这里就存在一个构造函数的调用，完成了隐式类型转换。</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    std::size_t val;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>可以在需要 SmallInt 的地方使用 Integral，但不能再需要 int 的地方使用 Integral:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int calc(int);</div><div class="line">Integral intVal;</div><div class="line">SmallInt si(intVal); // ok:convert intVal to Small Int and copy to si</div><div class="line">int i = calc(si);  // ok:convert si to int and call calc</div><div class="line">int j = calc(intVal);// error:on convertion to int from Integral</div></pre></td></tr></table></figure></p>
<ol>
<li>标准转换可放在类类型转换之前<br>使用构造函数执行隐式转换的时候，构造函数的形参类型不必与所提供的类型完全匹配。例如，下面的代码调用SmallInt类中定义的构造函数SmallInt(int)将sobj转换为SmallInt类型:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void calc(SmallInt);</div><div class="line"></div><div class="line">short sobj;</div><div class="line"></div><div class="line">// sobj prometed from short to int </div><div class="line"></div><div class="line">// that int converted to SmallInt through the SmallInt(int) constructor</div><div class="line"></div><div class="line">calc(sobj);</div></pre></td></tr></table></figure>
</li>
</ol>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/02/10/C-const-extern-static-volatile/">
                C++ const/extern/static/volatile
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-02-10</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="C-C-中的-const-关键字"><a href="#C-C-中的-const-关键字" class="headerlink" title="C/C++ 中的 const 关键字"></a>C/C++ 中的 const 关键字</h2><p>const 可以用来修饰变量，指针，函数参数，函数返回值，成员函数本身。而后三者是 const 最具威力的用法。<br>const 成员函数有两个语义：</p>
<ol>
<li>使得 class 的接口更加容易被理解，方便的知道哪个函数可以修改调用对象的内容，哪个函数不行。</li>
<li>使得区别对待常量调用对象与非常量调用对象成为可能。（两个成员函数仅仅是常量性不同是可以被重载的）<br>改善 C++ 程序效率的一个根本办法是 pass-by-reference-to-const</li>
</ol>
<h2 id="C-C-中extern关键字详解"><a href="#C-C-中extern关键字详解" class="headerlink" title="C/C++中extern关键字详解"></a>C/C++中extern关键字详解</h2><h3 id="基本解释"><a href="#基本解释" class="headerlink" title="基本解释"></a>基本解释</h3><pre><code>+ extern 暗示这个变量/函数的定义存在于别的源文件中
+ 用来进行链接指定，当它与&quot;C&quot;一起连用时，如: extern &quot;C&quot; void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译，而不是C++的，因为C++支持函数重载。
</code></pre><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li>extern 变量<br>在一个源文件里定义了一个数组：char a[6];在另外一个文件里用下列语句进行了声明：extern char *a；<br>请问，这样可以吗？<br>答案与分析：<ol>
<li>不可以，程序运行时会告诉你非法访问。原因在于，类型T的指针并不等价于类型T的数组。extern char *a声明的是一个字符指针而不是字符数组，因此与实际的定义不同，从而造成运行时非法访问。应该将声明改为extern char a[]。</li>
<li>在使用extern时候要严格对应声明时的格式，在实际编程中，这样的错误屡见不鲜。你在* .c文件中声明了一个全局的变量，这个全局的变量如果要被其他*.c引用，就放在*.h中并用 extern 来声明。</li>
</ol>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//在.h文件的头上</div><div class="line">#ifdef __cplusplus</div><div class="line">#if __cplusplus</div><div class="line">extern &quot;C&quot;&#123;</div><div class="line">　#endif</div><div class="line">　#endif /* __cplusplus */ </div><div class="line">    ...............</div><div class="line">    ...............</div><div class="line">　#ifdef __cplusplus</div><div class="line">　#if __cplusplus</div><div class="line">&#125;</div><div class="line">#endif</div><div class="line">#endif /* __cplusplus */</div></pre></td></tr></table></figure>
</li>
<li><p>常常见extern放在函数的前面成为函数声明的一部分，那么，C语言的关键字extern在函数的声明中起什么作用？<br> 答案与分析：<br> 仅仅是暗示这个函数的定义存在于别的源文件中。</p>
</li>
<li>extern 和 static<ul>
<li>extern 暗示这个变量的定义存在于别的源文件中。</li>
<li>static 表示静态变量，分配内存的时候, 存储在静态区,不存储在栈上面。<br>static 修饰全局变量的作用域只是本编译单元，也就是说它的“全局”只对本编译单元有效，其他编译单元则看不到它。<br>h.h<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#ifndef H_H</div><div class="line">#define H_H</div><div class="line"></div><div class="line">static char str[] = &quot;SJY&quot;;</div><div class="line">void func1();</div><div class="line">void func2();</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>a.cpp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#include &quot;h.h&quot;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">void func1() &#123;</div><div class="line">    str[0] = &apos;L&apos;;</div><div class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>b.cpp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#include &quot;h.h&quot;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">void func2() &#123;</div><div class="line">    str[1] = &apos;F&apos;;</div><div class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>main.cpp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &quot;h.h&quot;</div><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    str[2] = &apos;C&apos;;</div><div class="line">    func1();</div><div class="line">    func2();</div><div class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>./main 输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">LJY</div><div class="line">SFY</div><div class="line">SJC</div></pre></td></tr></table></figure></p>
<h2 id="static是C和C-的关键词，static在C-中比在C中有着更丰富的用法。"><a href="#static是C和C-的关键词，static在C-中比在C中有着更丰富的用法。" class="headerlink" title="static是C和C++的关键词，static在C++中比在C中有着更丰富的用法。"></a>static是C和C++的关键词，static在C++中比在C中有着更丰富的用法。</h2><h3 id="static在C中的作用"><a href="#static在C中的作用" class="headerlink" title="static在C中的作用"></a>static在C中的作用</h3><ol>
<li>static 修饰局部变量<br>static 修饰局部变量时，使得被修饰的变量成为静态变量，存储在静态区。存储在静态区的数据生命周期与程序相同，在 main 函数之前初始化，在程序退出时销毁。（无论是局部静态还是全局静态）。局部静态变量使得该变量在退出函数后，不会被销毁，因此再次调用该函数时，该变量的值与上次退出函数时值相同。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void function()</div><div class="line">&#123;</div><div class="line">    /*实际上nCount的初始化不是在函数体第一次执行时完成，而是在编译期其值就已经被</div><div class="line">       确定，在main函数之前就完成了初始化，所以局部静态变量只会初始化一次*/</div><div class="line">    static int nCount(0);    </div><div class="line">    std::cout &lt;&lt; &quot;Call function &quot; &lt;&lt; ++nCount &lt;&lt; &quot; times&quot; &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    for (int i = 0; i &lt; 5; ++i) </div><div class="line">    &#123;</div><div class="line">        function();</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>输出结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Call function 1 times</div><div class="line">Call function 2 times</div><div class="line">Call function 3 times</div><div class="line">Call function 4 times</div><div class="line">Call function 5 times</div></pre></td></tr></table></figure></p>
<ol>
<li>static修饰全局变量<br>全局变量本来就存储在静态区，因此static并不能改变其存储位置。但是，static限制了其链接属性。static 修饰全局变量的作用域只是本编译单元，也就是说它的“全局”只对本编译单元有效，其他编译单元则看不到它。</li>
</ol>
<p>在头文件a.h中定义一个全局变量<br>a.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#ifndef A_H</div><div class="line">    #define A_H</div><div class="line">    int a = 1;</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>b.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#ifndef B_H</div><div class="line">    #define B_H</div><div class="line">    void func();</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>实现文件a.cpp,包含头文件a.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &quot;a.h&quot;</div><div class="line">#include &quot;b.h&quot;</div><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    func();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现文件b.cpp，包含头文件a.h<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#include &quot;a.h&quot;</div><div class="line">#include &quot;b.h&quot;</div><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">void func()</div><div class="line">&#123;   a = 2;</div><div class="line">    cout &lt;&lt; a &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译出现重定义错误，因为头文件a被包含两次，在a.cpp和b.cpp分别被定义了一次。 </p>
<p>要解决这样的冲突怎么办？两种解决办法。 </p>
<pre><code>1. 将a定义为静态的全局变量，每个编译单元各一份。
a.h
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#ifndef A_H</div><div class="line">    #define A_H</div><div class="line">    static int a = 1;</div><div class="line">#endif</div></pre></td></tr></table></figure>

b.h
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#ifndef B_H</div><div class="line">    #define B_H</div><div class="line">    void func();</div><div class="line">#endif</div></pre></td></tr></table></figure>

实现文件a.cpp,包含头文件a.h
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &quot;a.h&quot;</div><div class="line">#include &quot;b.h&quot;</div><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    func();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

实现文件b.cpp，包含头文件a.h
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#include &quot;a.h&quot;</div><div class="line">#include &quot;b.h&quot;</div><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">void func()</div><div class="line">&#123;</div><div class="line">    cout &lt;&lt; a &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

2. 使用extern，将a声明为extern类型的变量，所有的编译单元共用一个。
</code></pre><ol>
<li>static修饰函数<br>static 修饰函数的作用域只是本编译单元，也就是说它只对本编译单元有效，其他编译单元则看不到它。</li>
</ol>
<p><strong>不管是修饰函数或者变量，static 的语义就是仅限于此编译单元。</strong></p>
<h3 id="static在C-中的作用"><a href="#static在C-中的作用" class="headerlink" title="static在C++中的作用"></a>static在C++中的作用</h3><p>类属性 类方法<br>对于静态成员变量和静态成员函数，所有的对象都共享一份。 </p>
<h2 id="C-C-中的volatile-关键字"><a href="#C-C-中的volatile-关键字" class="headerlink" title="C/C++ 中的volatile 关键字"></a>C/C++ 中的volatile 关键字</h2><ol>
<li>volatile 是一个类型修饰符（type specifier），就像大家更熟悉的const一样，它是被设计用来修饰被不同线程访问和修改的变量。</li>
<li>volatile 的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。</li>
<li>volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。</li>
<li>精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。</li>
<li><p>下面是volatile变量的几个例子：</p>
<ul>
<li>并行设备的硬件寄存器（如：状态寄存器）</li>
<li>一个中断服务子程序中会访问到的非自动变量（Non-automatic variables)</li>
<li><p>多线程应用中被几个任务共享的变量<br>简单地说就是防止编译器对代码进行优化。比如如下程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">XBYTE[2]=0x55;</div><div class="line">XBYTE[2]=0x56;</div><div class="line">XBYTE[2]=0x57;</div><div class="line">XBYTE[2]=0x58;</div></pre></td></tr></table></figure>
<p>对外部硬件而言，上述四条语句分别表示不同的操作，会产生四种不同的动作，但是编译器却会对上述四条语句进行优化，认为只有XBYTE[2]=0x58（即忽略前三条语句，只产生一条机器代码）。如果键入volatile，则编译器会逐一地进行编译并产生相应的机器代码（产生四条代码）。</p>
</li>
</ul>
</li>
</ol>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/01/23/数据结构与算法分析C/">
                数据结构与算法分析C++
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-01-23</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>递归的前两个基本法则：</p>
<ol>
<li>基准情形（base cases），必须总有某些基准情形，它们不用递归就能求解。</li>
<li>不断推进（making progress），对于那些要被递归求解的情形，递归调用必须总能够朝着一个基准情形推进。<br>递归程序不仅简化了算法设计而且有助于给出更加简洁的代码，但是递归绝不应该作为简单for循环的代替物。<br>另外的两个法则是：</li>
<li>设计法则。假设所有的递归调用都能运行。</li>
<li>合成效益法则，在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。</li>
</ol>
<h4 id="接口与实现的分离"><a href="#接口与实现的分离" class="headerlink" title="接口与实现的分离"></a>接口与实现的分离</h4><p>接口列出了类及其成员（属性和方法），而实现则提供了函数的具体实现。<br>接口通常都放在以 .h 结尾的文件中，需要接口信息的源代码必须 #include 接口文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#ifndef IntCell_H</div><div class="line">#define IntCell_H</div><div class="line"></div><div class="line">class IntCell &#123;</div><div class="line">    public:</div><div class="line">        explicit IntCell(int initialValue = 0);</div><div class="line">        int read() const;</div><div class="line">        void write(int x);</div><div class="line">    private:</div><div class="line">        int storedValue;</div><div class="line">&#125;;</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>注意的一点是：默认参数仅在接口中被定义，在实现中则被忽略。<br>在 C++ 中有两种使用零参数构造函数创建对象的方式，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">m = new IntCell();</div><div class="line">m = new IntCell;</div></pre></td></tr></table></figure></p>
<p>C++ 没有自动的垃圾收集。<br>C 和 Java 都是值传递，而 Python 是对象传递。<br>C++ 提供了三种传参方式，值传递，引用传递，常量引用传递。<br>C++ 也提供了三种返回传递方式，值传递，引用传递，常量引用传递。尽量不要使用引用传递。<br>值传递一般来说是最安全的。使用常量引用传递或者引用传递只有在确保返回语句中的表达式在函数返回之后依然有效时才是安全的。<br>如果编译器没有注意到这个问题，对于局部变量的引用传递返回既可能是正确的，也可能是错误的，这会取决于编译器释放局部变量所使用的内存的速度。<br>复制构造函数 用于构造新的对象，并被初始化为相同类型对象的一个副本。<br>在以下三个情形下会被调用：</p>
<ol>
<li><p>声明的同时初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">IntCell B = C;</div><div class="line">IntCell B(C);</div><div class="line">而不是</div><div class="line">B = C; // 赋值运算符</div></pre></td></tr></table></figure>
</li>
<li><p>值传递传参</p>
</li>
<li>值传递返回<br>对于简单数据类型的数据成员，进行简单的赋值就可以了。对于对象数据成员，对象数据成员的复制构造函数依次被调用。<br>当 = 应用于两个已经构造的对象时，就会调用复制赋值运算符 operator=，默认情况下通过将其应用于每个数据成员的方式来实现。</li>
</ol>
<p>默认的析构函数、复制构造函数、operator= 都不会对指针指向的对象做任何的操作。<br>对于 IntCell，这些运算的签名是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">~IntCell();</div><div class="line">IntCell(const IntCell &amp; rhs);</div><div class="line">const IntCell &amp; operator=(const IntCell &amp; rhs);</div></pre></td></tr></table></figure></p>
<p>其中 operator= 的返回值类型和参数类型是一样的，是为了 a=b=c 这样的连续复制赋值运算符的调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">IntCell::~IntCell()&#123;</div><div class="line">    // Does nothing;</div><div class="line">    // If IntCell contained any class objects, their destructors would be called.</div><div class="line">&#125;</div><div class="line">IntCell::IntCell(const IntCell &amp; rhs):storedValue(rhs.storedValue)&#123;</div><div class="line">&#125;</div><div class="line">const IntCell &amp; operator=(const IntCell &amp; rhs)&#123;</div><div class="line">    // Standard alias test</div><div class="line">    if (this != &amp;rhs)&#123;</div><div class="line">        storedValue = rhs.storedValue;</div><div class="line">    &#125;</div><div class="line">    return *this;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="C-风格的数组和字符串"><a href="#C-风格的数组和字符串" class="headerlink" title="C 风格的数组和字符串"></a>C 风格的数组和字符串</h4><p><code>int arr[10];</code> 中 <code>arr</code> 实际上是一个指向足够存储10 个int的内存空间的指针，而且是常量指针。当 <code>arr</code> 传递给一个函数时，只有指针的值被传递，而数组的大小信息则丢失了，因此数组的大小必须作为一个附加参数进行传递，由于数组的大小未知，也就没有关于索引范围的检查。<br>在上面的定义中，在编译的时候数组的大小就必须被指定，如果数组的大小位置，就必须显式地声明一个指针，并用 new int[] 来分配内存。<br><code>int *arr = new int[n];</code>，<code>arr</code> 不再是常量指针，由于内存是动态分配地，需要使用 delete [] 进行释放，如果不释放，当数组很大时，泄露就会很严重。<br>内置的C风格字符串，就是字符数组来实现的，特殊的终止符’\0’用以标识字符串逻辑上的结束，以避免传递字符串的长度值。字符串可以使用’strcpy’，’strcmp’，’strlen’，这些字符串具有数组具有的所有问题，困难的内存管理问题。譬如当字符串进行复制的时候，总是假设目标数组数据空间是足够大的，如果空间不够大，常常会因为没有存储字符串终止符的空间而导致调试的极大困难。</p>
<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>这本书描述的算法和数据结构都是类型无关的，当编写 C++ 代码的类型无关的算法或者数据结构时，我们更愿意只写一次，而不是为不同的类型都写一遍。在 C++ 中使用模板来写类型无关的算法，即泛型编程。<br>函数模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Return the maximum item in array a.</div><div class="line"> * Assumes a.size() &gt; 0.</div><div class="line"> * Comparable objects must provide operator &gt; and operator =</div><div class="line">*/</div><div class="line">template &lt;typename Comparable&gt;</div><div class="line">const Comparable &amp; findMax(vector&lt;Comparable&gt; &amp; a)&#123;</div><div class="line">    int maxIndex = 0;</div><div class="line"></div><div class="line">    for(int i=1;i&lt;a.size();i++)&#123;</div><div class="line">        if(a[maxIndex] &lt; a[i])&#123;</div><div class="line">            maxIndex = i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return a[maxIndex];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int main()&#123;</div><div class="line">    vector&lt;int&gt; v1(37);</div><div class="line">    vector&lt;double&gt; v2(37);</div><div class="line">    vector&lt;string&gt; v3(37);</div><div class="line">    vector&lt;IntCell&gt; v4(37);</div><div class="line"></div><div class="line">    // Additional code to fill in the  vectors not shown;</div><div class="line"></div><div class="line">    cout &lt;&lt; findMax(v1) &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; findMax(v2) &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; findMax(v3) &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; findMax(v4) &lt;&lt; endl; // Illegal; operator &lt; undefined;</div><div class="line"></div><div class="line">    return 0;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类模板</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/01/18/机器学习工程师笔试面试/">
                机器学习工程师笔试面试
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-01-18</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="整体要求"><a href="#整体要求" class="headerlink" title="整体要求"></a>整体要求</h3><p>机器学习方面的面试主要分成三个部分：</p>
<ol>
<li>算法和理论基础</li>
<li>工程实现能力与编码水平</li>
<li>业务理解和思考深度</li>
</ol>
<h3 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h3><ol>
<li>理论方面，我推荐最经典的一本书《统计学习方法》，这书可能不是最全的，但是讲得最精髓，薄薄一本，适合面试前突击准备。</li>
</ol>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><ol>
<li>统计学习的核心步骤：模型、策略、算法，你应当对logistic、SVM、决策树、KNN及各种聚类方法有深刻的理解。能够随手写出这些算法的核心递归步的伪代码以及他们优化的函数表达式和对偶问题形式。</li>
<li>数学知识方面，你应当深刻理解矩阵的各种变换，尤其是特征值相关的知识。</li>
<li>算法方面，你应当深刻理解常用的优化方法：梯度下降、牛顿法、各种随机搜索算法（基因、蚁群等等），深刻理解的意思是你要知道梯度下降是用平面来逼近局部，牛顿法是用曲面逼近局部等等。 </li>
<li>工程实现能力与编码水平<br> 机器学习从工程实现一般来讲都是某种数据结构上的搜索问题。<br> 你应当深刻理解各种算法对应应该采用的数据结构和对应的搜索方法。比如KNN对应的KD树、如何给图结构设计数据结构？如何将算法map-reduce化等等。<br> 一般来说要么你会写C，而且会用MPI，要么你懂Hadoop，工程上基本都是在这两个平台实现。实在不济你也学个python吧。 </li>
</ol>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li>SVM的原理，SVM里面的核</li>
<li>K-means，如何用hadoop实现k-means</li>
<li>naive bayes和logistic regression的区别</li>
<li>LDA的原理和推导</li>
</ol>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ol>
<li>做广告点击率预测，用哪些数据、什么算法</li>
<li>推荐系统的算法中最近邻和矩阵分解各自适用场景</li>
<li>用户流失率预测怎么做（游戏公司的数据挖掘都喜欢问这个）</li>
<li>一个游戏的设计过程中该收集什么数据</li>
<li>如何从登陆日志中挖掘尽可能多的信息</li>
</ol>
<h3 id="其他人的一些经验总结"><a href="#其他人的一些经验总结" class="headerlink" title="其他人的一些经验总结"></a>其他人的一些经验总结</h3><ol>
<li>实际工作中，算法的先进性对真正业务结果的影响，大概不到30%。当然算法必须要足够快，离线算法最好能在4小时内完成，实时算法我没搞过，要求大概更高。机器学习大多数场景是搜索、广告、垃圾过滤、安全、推荐系统等等。对业务有深刻的理解对你做出来的系统的结果影响超过70%。这里你没做过实际的项目，是完全不可能有任何体会的，我做过一个推荐系统，没有什么算法上的高大上的改进，主要是业务逻辑的创新，直接就提高了很明显的一个CTR（具体数目不太方便透露，总之很明显就是了）。如果你做过实际的项目，一定要主动说出来，主动让面试官知道，这才是最大最大的加分项目。</li>
<li>这些问题的特点是很基础很简单，因为实际中很少用复杂的算法，复杂的算法不好控制，而且理论要求高。另一个特点是注重考查实际工程能力，我经常被问到自己实现了哪些算法。还有的问题很契合实际。</li>
</ol>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2017/12/12/RLAI-Monte-Carlo-Methods-学习笔记/">
                RLAI Monte Carlo Methods 学习笔记
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-12-12</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="Chapter-5"><a href="#Chapter-5" class="headerlink" title="Chapter 5"></a>Chapter 5</h2><h2 id="Monte-Carlo-Methods-一种估计值函数和发现最优策略的方法"><a href="#Monte-Carlo-Methods-一种估计值函数和发现最优策略的方法" class="headerlink" title="Monte Carlo Methods 一种估计值函数和发现最优策略的方法"></a>Monte Carlo Methods 一种估计值函数和发现最优策略的方法</h2><p>不需知道环境的完整信息，MC方法只需要 experience，也就是来自真实或者仿真环境下的状态、动作、奖励的序列。尽管需要环境模型，但是仅仅需要这个模型产生样本，而不是像动态规划那样需要完整的转移概率分布。在很多情况下，获得样本是容易的，而给出具体形式的分布确实困难的，这就使得MC方法十分的有用。</p>
<p>MC 方法基于采样与平均。experience 分为不同的 episode，只有在一个 episode 完成之后才会进行值估计和策略提升。MC 方法是 episode-by-episode （offline）的形式，而不是 step-by-step （online）的方式。</p>
<h3 id="Monte-Carlo-Prediction"><a href="#Monte-Carlo-Prediction" class="headerlink" title="Monte Carlo Prediction"></a>Monte Carlo Prediction</h3><p>一个状态的 value 是一个期望回报，即从该状态出发遵循一定的策略可以期望获得的累积未来折扣奖励。</p>
<p>MC 方法内在的想法就是，从 experience 中估计状态值函数，对访问一个状态之后获得的回报进行平均，随着 episode 次数的增多，这个平均值会收敛到期望值。\(v_{\pi}(s)\) 是在策略 \(\pi\) 下，状态 \(s\) 的 value，我们要做的就是在给定一些遵循策略 \(\pi\) 经历了状态 \(s\) 的 episode 时，对 \(v_{\pi}(s)\) 进行估计。在 episode 中的 \(s\) 每一次出现就称之为对状态 \(s\) 的一次访问。根据进行估计时使用 \(s\) 的第一访问还是每一次访问，MC 方法可以分为 First-visit MC 和 Every-visit MC。<br><img src="http://oytnj8g2y.bkt.clouddn.com/image/png/2017/12/first-visit-mc-prediction.png" alt="first-visit-mc-prediction"></p>
<h3 id="Monte-Carlo-Estimation-of-Action-Values"><a href="#Monte-Carlo-Estimation-of-Action-Values" class="headerlink" title="Monte Carlo Estimation of Action Values"></a>Monte Carlo Estimation of Action Values</h3><p>上面讲了在给定策略的条件下使用 MC 对状态值函数进行估计。</p>
<p>当环境模型未知时，对状态-动作值函数进行估计就比对状态值函数进行估计要有用了，这是因为在环境模型已知时，状态值函数对于确定（给出）一个策略就足够了，即在根据当前状态选择动作时，仅仅需要选择立即奖励和下一状态的 value 之和最大的那个动作。这样可行是因为，当环境模型已知时，一个动作带来的奖励是已知的，状态转移概率是已知的，即在当前状态下采取一个动作转移到下一状态及由下一状态带来的期望回报都是已知的。但是在没有环境模型时，状态值函数不足以给出一个策略，为了可以得到一个策略，就需要更加显式直接的状态-动作对值函数。</p>
<p>\(q_{\pi}(s,a)\) the expected return when starting in state \(s\), taking action \(a\), and thereafter following policy \(\pi\)（从状态 \(s\) 出发，采取动作 \(a\) 并在后续遵循策略 \(\pi\) 可以得到的期望回报）。在使用 MC 进行估计时，和状态值函数的估计很像，不做在这里我们考虑的不再是对状态 \(s\) 的访问而是对状态-动作对 \(s\)-\(a\) 的访问。</p>
<p>这里唯一的问题在于，很多的状态-动作对可能永远不会被访问到。如果策略是确定性的，那么在一个状态下做出的动作就是确定性的，有的状态-动作对就不会被访问到，就无法更新状态-动作对的 value, 这是一个严重的问题，因为学习状态-动作对的 value 的目的就是用来在一个状态下可用的动作中做出选择，这就需要我们能够对一个状态的所有可能动作的 value 做出估计，而不是仅仅估计我们目前策略所指定的状态-动作对的 value。这就是一个保持探索（maintaining exploration）的问题，一个解决方法就是 exploring starts 假设，即每一个状态-动作对都有不为零的概率被选择成为一个 episode 的开始。但是在“实际”环境中这通常是不可行的。另外一个确保所有的状态-动作对都被访问到的方法是使用在每一个状态下以非零概率选择各个动作的随机策略。</p>
<h3 id="Monte-Carlo-Control"><a href="#Monte-Carlo-Control" class="headerlink" title="Monte Carlo Control"></a>Monte Carlo Control</h3><p>遵循 GPI（generalized policy iteration 泛化策略迭代）的指导，即策略的评估（利用上面讲到的状态-动作对值函数对一个策略的好坏进行评估）和策略的提高（对得到的状态-动作对值函数进行利用从而提高策略）。<br><img src="http://oytnj8g2y.bkt.clouddn.com/image/png/2017/12/GPI.png" alt="GPI"><br>policy evaluation and policy improvement, beginning with an arbitrary policy \(\pi_{0}\) and ending with the optimal policy and optimal action-value function:<br><img src="http://oytnj8g2y.bkt.clouddn.com/image/png/2017/12/evaluation-improvement.png" alt="evaluation-improvement"><br>策略评估是通过多个 episode，用状态-动作对值函数的估计渐进地逼近真实的函数。<br>策略提升是通过对状态-动作对值函数进行利用得到的贪婪策略，即$$\pi(s)=argmax_{a}q(s,a)$$<br>策略提高之所以有效是因为：<br>$$q_{\pi_{k} }(s, \pi_{k+1}(s))=q_{\pi_{k} }(s, argmax_{a}q_{\pi_{k} }(s,a))$$<br>$$=max_{a}q_{\pi_{k} }(s,a)$$<br>$$\ge q_{\pi_{k} }(s, \pi_{k}(s))$$<br>上面的公式可以做如下解释：<br>\(q_{\pi_{k} }(s,a)\) 是在策略 \(\pi_{k}\) 指导下进行多次 episode 而得到的对状态-动作对值函数的估计，使用贪心的方式得到的新策略 \(\pi_{k+1}(s)\)，\(q_{\pi_{k} }(s, \pi_{k+1}(s))\) 是在新的策略 \(\pi_{k+1}(s)\)指导下可以得到的状态-动作对值函数的预期，实际上尚未在其指导下进行过一次 episode，可以看到这个预期是大于等于已经得到的状态-动作对值函数的估计的，因此新的策略 \(\pi_{k+1}(s)\) 相较于 \(\pi_{k}(s)\) 是提升了的。可以看到状态-动作对值函数的提高提升了策略，而策略的提高提升了状态-动作对值函数，两者交替上升。由此可见，MC 方法可以在对环境模型未知的情况下仅仅通过 episode 找到最优的策略。</p>
<p>We made two unlikely assumptions above in order to easily obtain this guarantee of convergence for the Monte Carlo method. One was that the episodes have exploring starts, and the other was that policy evaluation could be done with an infinite number of episodes.第二个假设相对而言比较容易移除，一种有效的避免策略评估需要无限次数的 episode 的途径是，我们放弃完整地完成策略评估，而是中途进入策略提升阶段，我们并不需要直达或者逼近真实的\(q_{\pi_{k} }\)，而只需要 move toward \(q_{\pi_{k} }\) step-by-step。</p>
<p>一个极端的例子就是值迭代，在两次策略提升之间是只有迭代策略评估的一次迭代；in-place 版本的值迭代更加极端，在提升和评估之间只有一个状态。</p>
<p>For Monte Carlo policy evaluation it is natural to alternate between evaluation and improvement on<br>an episode-by-episode basis. 在每次 episode 之后，观测到的回报被用于策略评估，然后策略会在此次 episode 中被访问的所有状态上进行提升。<br><img src="http://oytnj8g2y.bkt.clouddn.com/image/png/2017/12/MC-ES.png" alt="MC-ES"></p>
<h3 id="Monte-Carlo-Control-without-Exploring-Starts"><a href="#Monte-Carlo-Control-without-Exploring-Starts" class="headerlink" title="Monte Carlo Control without Exploring Starts"></a>Monte Carlo Control without Exploring Starts</h3><p>如何去掉 exploring starts 假设呢？有两种方式：</p>
<ul>
<li>on-policy：evaluate or improve the policy that is used to make decisions</li>
<li>off-policy：evaluate or improve a policy different from that used to generate the data<br>MC ES 是一种 on-policy 的例子。<br>在 on-policy 方法中的策略通常是软的，也就是$$\pi(a|s)&gt;0\quad for\quad all\quad s\quad \in\quad S\quad and\quad a\quad \in\quad A(s)$$<br>但是向确定性的最优策略偏移地越来越近。<br>\(\varepsilon-soft\) 中的一个例子就是 \(\varepsilon-greedy\)，在 \(\varepsilon-greedy\) 中所有的非贪婪动作被选择的概率为 \(\frac{\varepsilon}{|A(s)|}\)，贪婪动作被选择的概率为 \(1-\varepsilon+\frac{\varepsilon}{|A(s)|}\)，它是对于所有的状态和动作都有 \(\pi(a|s)\ge\frac{\varepsilon}{|A(s)|}\) 的 \(\varepsilon-soft\)。<br>在去掉 exploring starts 假设之后，不能简单地使用贪婪地方式进行策略提升，因为这会阻碍非贪婪动作的探索，相应的使用 \(\varepsilon-greedy\) 策略。<br><img src="/2017/12/12/RLAI-Monte-Carlo-Methods-学习笔记/.." alt="epsilon-soft"><br>关于算法有效性的证明请参考 Reinforcement Learning: An Introduction 5.4。</li>
</ul>
<h3 id="Off-policy-Prediction-via-Importance-Sampling"><a href="#Off-policy-Prediction-via-Importance-Sampling" class="headerlink" title="Off-policy Prediction via Importance Sampling"></a>Off-policy Prediction via Importance Sampling</h3><p>所有的 learning control 方式都有一个困境，那就是假设在后续最优动作的条件下得到状态-动作对的 value，但是又需要表现的非最优来探索所有的动作，即最优动作是确定的，但是又需要执行非最优动作来探索动作空间进行最优动作的寻找，使得最优策略的状态-动作对 value 的求解变得不可得。<br>How to learn about the optimal policy while behaving according to<br>an exploratory policy?<br>上面讲到的得 on-policy 是一种折中的方式，即学习到的并不是最优策略的状态-动作对的值，而是接近最优的仍在探索的策略的状态-动作对的值，即最优策略是固定的，但此处得到的策略是随机的非最优的。更直接的方式是使用两个策略，一个进行学习从而成为最优策略（target policy），另一个更具有探索性用来产出动作（behaviour policy），也就是 off-policy learning，这种方式方差较大，收敛地更慢。<br>下面首先进行策略的评估，也就是 prediction，从策略 \(b(b\ne\pi)\) 指导下的一些 episode 出发估计 \(v_{\pi}\) 或者 \(q_{\pi}\)。<br>收敛假设：$$\pi(a|s)&gt;0 implies b(a|s)&gt;0$$<br>另外，\(b\) 必须是随机的，而 \(\pi\) 可以是确定性的，在控制学里，典型的情形是 \(\pi\) 是在当前状态-动作值函数估计下的确定性策略，behaviour policy 保持随机，而 target policy 逐渐成为一个确定性的最优策略。<br>几乎所有的 off-policy 方法使用了重要性采样，a general technique for estimating expected<br>values under one distribution given samples from another。<br>在这里我们通过根据目标策略下的轨迹和行为策略下的轨迹之间的相对概率关系对回报进行加权的方式来将重要性采样应用到 off-policy 的学习中。<br>给定一个初始状态 \(S_{t}\)，\([A_{t}, S_{t+1}, A_{t+1},…,S_{T}]\)这样的一条轨迹出现的概率<br><img src="/2017/12/12/RLAI-Monte-Carlo-Methods-学习笔记/.." alt="trajectory_probability"><br>这样的一条轨迹在 target policy 和 behaviour policy 之间的相对概率也就是 importance-sampling ratio：<br><img src="/2017/12/12/RLAI-Monte-Carlo-Methods-学习笔记/.." alt="trajectory_importance_ratio"><br>Although the trajectory probabilities depend on the MDP’s transition probabilities, which are generally<br>unknown, they appear identically in both the numerator and denominator, and thus cancel. The<br>importance sampling ratio ends up depending only on the two policies and the sequence, not on the<br>MDP.<br>下面给出一个 MC 算法，该算法使用观察到的遵循策略 \(b\) 的一批次 episode 来估计 \(v_{\pi}(s)\).<br>给所有的 episode 中的时间步打破 episode 边界赋予一个唯一的递增的时间步序号，在所有的 episode 中，对于 every-visit 方式，定义对状态 \(s\) 进行了访问的时间步集合是 \(J(s)\)；对于 first-visit 方式，定义第一次对状态 \(s\)进行了访问的时间步集合是 \(J(s)\)。<br>let \(T(t)\) denote the first time<br>of termination following time \(t\), and \(G_{t}\) denote the return after \(t\) up through \(T(t)\)。<br>\(\lbrace G_{t}\rbrace_{t \in J(s)}\) 就是状态 \(s\) 的回报，\(\lbrace \rho_{t:T(t)-1} \rbrace_{t \in J(s)}\) 就是状态 \(s\) 的重要性采样比率。<br>To estimate \(v_{\pi}(s)\), we simply scale the returns by the ratios and average the results:<br><img src="/2017/12/12/RLAI-Monte-Carlo-Methods-学习笔记/.." alt="ordinary_scale_return_and_average"><br>通过简单平均完成的重要性采样叫做 ordinary importance sampling。<br><img src="/2017/12/12/RLAI-Monte-Carlo-Methods-学习笔记/.." alt="weighted_scale_return_and_average"><br>通过加权平均完成的重要性采样叫做 weighted importance sampling。<br>关于这两者的不同，请参考 Reinforcement Learning: An Introduction 5.5。</p>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2017/12/09/强化学习-3-估值网络及其-TensorFlow-实现/">
                强化学习 3 估值网络及其 TensorFlow 实现
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-12-09</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="强化学习-3-估值网络及其-TensorFlow-实现"><a href="#强化学习-3-估值网络及其-TensorFlow-实现" class="headerlink" title="强化学习 3 估值网络及其 TensorFlow 实现"></a>强化学习 3 估值网络及其 TensorFlow 实现</h1><h2 id="估值网络"><a href="#估值网络" class="headerlink" title="估值网络"></a>估值网络</h2><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><ol>
<li>Q-learning 中的期望价值指从当前的这一步到后续的所有步骤，总共可以期望获得的最大价值。也就说是对未来进行了断言，这一步采取这样的动作，不管未来采取什么样的动作，可以期望获得的价值不会超过这个Q值。Q值的意义就是最大价值，当前最大 = 当前 + gamma * 以后续一步为当前的最大。</li>
<li>Q-learning 的目的就是求解 \(Q(s_t, a_t)\)，可以将其看作一个表格，每一行是不同的状态，每一列是不同的动作，学习的过程就是把这个表用合适的值填充起来。</li>
<li>Q-learning 的训练思路也很简单，以（状态，动作，奖励，下一状态）四元组（\((s_t, a_t, r_{t+1}, s_{t+1})\)）作为样本进行训练。</li>
<li>学习目标 \(r_{t+1} + \gamma \cdot \max\limits_{a} Q(s_{t+1}, a)\)，即相当于 label。</li>
<li>学习过程 \(Q_{new}(s_t, a_t) \gets (1-\alpha) \cdot Q_{old}(s_t, a_t) + \alpha \cdot (r_{t+1} + \gamma \cdot \max\limits_{a} Q_{old}(s_{t+1}, a))\)</li>
<li>Q-learning 的模型是神经网络时，即将\(Q(s_t, a_t)\)表达为神经网络，就是估值网络。</li>
<li>DQN 是 DeepMind 在 Human-level control through deep reinforcement learning 中提出的。</li>
</ol>
<h4 id="Tricks："><a href="#Tricks：" class="headerlink" title="Tricks："></a>Tricks：</h4><ol>
<li>Experience Replay，因为深度学习需要大量的样本，所以传统的Q-learning 的 online update 的方法不太适合于 DQN，可以像训练CNN 那样进行多个 epoch 的训练，主要思想就是存储 Agent 的 Experience，并且每次训练时随机抽取一部分样本训练网络。这样就能比较稳定的完成学习任务，避免只短视地学习新接触地样本，而是综合地反复利用过往的大量样本进行学习。可以创建一个用来存储Experience的缓存buffer，缓存满了之后就使用新的样本进行替换，如此就可以保证样本都有相近的概率被抽到，如果不替换，那么一开始就有的老样本在整个训练过程中被抽中的概率就会比新样本大得多。</li>
<li>使用 target DQN 进行辅助训练，它的意义是用来计算目标 Q 值（label），即提供\(\max\limits_{a} Q(s_{t+1}, a)\)。之所以拆分为两个网络，一个用来制造学习目标，一个用来进行实际训练，是为了让 Q-learning 训练的目标平稳。强化学习的学习目标每次更新后都在变化，即相同的输入，目标Q值（label）并不相同，如果模型参数更新地很频繁，幅度很大，训练过程就会因为目标剧烈变化而非常不稳定，容易失控。为了降低这个影响，需要让目标Q值（label）尽量平稳，因此需要一个比较稳定的 target DQN 辅助计算目标Q值，让target DQN 进行低频率的学习，让它输出的目标Q值波动也小，可以减少对训练过程的影响。</li>
<li>Double DQN 是在拆分出target DQN 的基础上更近一步，DeepMind 的研究者在 Deep Reinforcement Learning with Double Q-learning 中指出，传统的DQN通常会高估 Action 的Q值，如果这中高估是不均匀的，可能会导致本来次优的 Action 总是被高估而超过最后的 Action，这样就可能永远发现不了最优的 Action。之前，target DQN 完全负责生成目标Q值，先产生\(Q(s_{t+1}, a)\),再通过\(\max\limits_{a}\)选择那个最大的Q值。Double DQN 改变了第二步，不是直接选择 target DQN 输出中的最大Q值，而是在主DQN的输出中找到最大Q值对应的 Action，再找到 target DQN 的输出中这个 Action 对应的Q值，这个Q值作为目标Q值（即label）。使用的目标Q值不一定总是 target DQN 输出中的最大Q值，这样就避免了总是从 target DQN 的输出中选择被高估的同一个 Action 对应的Q值作为 label。此时学习目标就可以写成 $$Target=r_{t+1} + \gamma \cdot Q_{target}(s_{t+1}, argmax_{a}(Q_{main}(s_{t+1}, a)))$$</li>
<li>Dueling DQN 是 DQN 一大改进，在 Dueling Network Architectures for Deep Reinforcement Learning 中提出，将Q值函数\(Q(s_{t}, a)\)拆分成两部分，一部分是静态的环境本身具有的价值\(V(s_{t})\)，称为 Value；另外一部分是通过执行 Action 额外带来的价值\(A(a_{t})\)，称为 Advantage，即 \(Q(s_{t}, a_{t})=V(s_{t})+A(a_{t})\)。Dueling 的目的就是让网络分别计算环境本身的 Value 和 Action 带来的 Advantage，Advantage 或好或坏，设计成零均值。<br><img src="http://oytnj8g2y.bkt.clouddn.com/image/png/2017/12/dueling.png" alt="传统DQN和Dueling DQN 的对比"><br>Dueling DQN 的输出是一个标量和向量，分别代表 Value 和每个 Action 的 Advantage。</li>
</ol>
<h4 id="仿真环境-GridWorld"><a href="#仿真环境-GridWorld" class="headerlink" title="仿真环境 GridWorld"></a>仿真环境 GridWorld</h4><p>grid_world.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> scipy.misc</div><div class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, coordinates, size, intensity, channel, reward, name)</span>:</span></div><div class="line">        self.x, self.y = coordinates[<span class="number">0</span>], coordinates[<span class="number">1</span>]</div><div class="line">        self.size = size</div><div class="line">        self.intensity = intensity</div><div class="line">        self.channel = channel</div><div class="line">        self.reward = reward</div><div class="line">        self.name = name</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">GridWorld</span><span class="params">()</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size)</span>:</span></div><div class="line">        self.x_size = size</div><div class="line">        self.y_size = size</div><div class="line">        self.action_num = <span class="number">4</span></div><div class="line">        self.block_num = <span class="number">7</span></div><div class="line">        self.blocks = <span class="keyword">None</span></div><div class="line">        self.available_grids = <span class="keyword">None</span></div><div class="line">        self.state = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_positions</span><span class="params">(self, num)</span>:</span></div><div class="line">        indices = np.random.choice(np.arange(len(self.available_grids)), size=num, replace=<span class="keyword">False</span>)</div><div class="line">        grids = [self.available_grids[index] <span class="keyword">for</span> index <span class="keyword">in</span> indices]</div><div class="line">        <span class="keyword">for</span> grid <span class="keyword">in</span> grids:</div><div class="line">            self.available_grids.remove(grid)</div><div class="line">        <span class="keyword">return</span> grids</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset</span><span class="params">(self)</span>:</span></div><div class="line">        self.available_grids = [(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> range(self.x_size) <span class="keyword">for</span> y <span class="keyword">in</span> range(self.y_size)]</div><div class="line">        postions = self.get_positions(self.block_num)</div><div class="line">        size = [<span class="number">1</span>] * self.block_num</div><div class="line">        intensity = [<span class="number">1</span>] * self.block_num</div><div class="line">        channel = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]</div><div class="line">        reward = [<span class="keyword">None</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>]</div><div class="line">        name = [<span class="string">"hero"</span>, <span class="string">"goal"</span>, <span class="string">"fire"</span>, <span class="string">"goal"</span>, <span class="string">"fire"</span>, <span class="string">"goal"</span>, <span class="string">"goal"</span>]</div><div class="line">        self.blocks = [Block(*args) <span class="keyword">for</span> args <span class="keyword">in</span> zip(postions, size, intensity, channel, reward, name)]</div><div class="line">        self.state = self.render()</div><div class="line">        <span class="keyword">return</span> self.state</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self, direction)</span>:</span></div><div class="line">        hero = self.blocks[<span class="number">0</span>]</div><div class="line">        <span class="keyword">if</span> direction == <span class="number">0</span> <span class="keyword">and</span> hero.y &gt;=<span class="number">1</span>:</div><div class="line">            hero.y -= <span class="number">1</span></div><div class="line">        <span class="keyword">elif</span> direction == <span class="number">1</span> <span class="keyword">and</span> hero.y &lt;= self.y_size - <span class="number">2</span>:</div><div class="line">            hero.y += <span class="number">1</span></div><div class="line">        <span class="keyword">elif</span> direction == <span class="number">2</span> <span class="keyword">and</span> hero.x &gt;= <span class="number">1</span>:</div><div class="line">            hero.x -= <span class="number">1</span></div><div class="line">        <span class="keyword">elif</span> direction == <span class="number">3</span> <span class="keyword">and</span> hero.x &lt;= self.x_size - <span class="number">2</span>:</div><div class="line">            hero.x += <span class="number">1</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">pass</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_hit</span><span class="params">(self)</span>:</span></div><div class="line">        hero = self.blocks.pop(<span class="number">0</span>)</div><div class="line">        <span class="keyword">for</span> block <span class="keyword">in</span> self.blocks:</div><div class="line">            <span class="keyword">if</span> (hero.x == block.x) <span class="keyword">and</span> (hero.y == block.y):</div><div class="line">                self.available_grids.append([block.x, block.y])</div><div class="line">                self.blocks.remove(block)</div><div class="line">                <span class="keyword">if</span> block.name == <span class="string">"goal"</span>:</div><div class="line">                    self.blocks.append(Block(*self.get_positions(<span class="number">1</span>), <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">"goal"</span>))</div><div class="line">                <span class="keyword">elif</span> block.name == <span class="string">"fire"</span>:</div><div class="line">                    self.blocks.append(Block(*self.get_positions(<span class="number">1</span>), <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="string">"fire"</span>))</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">raise</span></div><div class="line">                self.blocks.insert(<span class="number">0</span>, hero)</div><div class="line">                <span class="keyword">return</span> block.reward, <span class="keyword">False</span></div><div class="line">        </div><div class="line">        self.blocks.insert(<span class="number">0</span>, hero)</div><div class="line">        <span class="keyword">return</span> <span class="number">0.0</span>, <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">render</span><span class="params">(self)</span>:</span></div><div class="line">        canvas = np.ones([self.y_size+<span class="number">2</span>, self.x_size+<span class="number">2</span>, <span class="number">3</span>])</div><div class="line">        canvas[<span class="number">1</span>:<span class="number">-1</span>,<span class="number">1</span>:<span class="number">-1</span>,:] = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> block <span class="keyword">in</span> self.blocks:</div><div class="line">            canvas[block.y+<span class="number">1</span>:block.y+block.size+<span class="number">1</span>,block.x+<span class="number">1</span>:block.x+block.size+<span class="number">1</span>,block.channel] = block.intensity</div><div class="line">        r = scipy.misc.imresize(canvas[:,:,<span class="number">0</span>], [<span class="number">84</span>,<span class="number">84</span>,<span class="number">1</span>], interp=<span class="string">'nearest'</span>)</div><div class="line">        g = scipy.misc.imresize(canvas[:,:,<span class="number">1</span>], [<span class="number">84</span>,<span class="number">84</span>,<span class="number">1</span>], interp=<span class="string">'nearest'</span>)</div><div class="line">        b = scipy.misc.imresize(canvas[:,:,<span class="number">2</span>], [<span class="number">84</span>,<span class="number">84</span>,<span class="number">1</span>], interp=<span class="string">'nearest'</span>)</div><div class="line">        <span class="keyword">return</span> np.stack([r, g, b],axis=<span class="number">2</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">step</span><span class="params">(self, action)</span>:</span></div><div class="line">        self.move(action)</div><div class="line">        reward, done = self.check_hit()</div><div class="line">        self.state = self.render()</div><div class="line">        <span class="keyword">return</span> self.state, reward, done</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plot</span><span class="params">(self)</span>:</span></div><div class="line">        plt.imshow(self.state, interpolation=<span class="string">"nearest"</span>)</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    env = GridWorld(size=<span class="number">5</span>)</div><div class="line">    _ = env.reset()</div><div class="line">    env.plot()</div></pre></td></tr></table></figure></p>
<p>上面的模块定义了 GridWorld，效果图如下：<br><img src="http://oytnj8g2y.bkt.clouddn.com/gw.png" alt="gw"><br>其中蓝色是英雄，绿色是目标（奖励为1），红色是火焰（惩罚为1），英雄在这个 GridWorld 中游走获得尽可能多分数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding: utf-8</span></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf </div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">from</span> grid_world <span class="keyword">import</span> GridWorld</div><div class="line">os.environ[<span class="string">'CUDA_VISIBLE_DEVICES'</span>] = <span class="string">"1"</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DQN</span><span class="params">()</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, env, name)</span>:</span></div><div class="line">        self.name = name</div><div class="line">        self.env = env</div><div class="line">        <span class="comment">################## 网络结构 ##############</span></div><div class="line">        self.scalar_input =  tf.placeholder(shape=[<span class="keyword">None</span>,<span class="number">21168</span>],dtype=tf.float32)</div><div class="line">        self.image = tf.reshape(self.scalar_input,shape=[<span class="number">-1</span>,<span class="number">84</span>,<span class="number">84</span>,<span class="number">3</span>])</div><div class="line">        self.conv1 = tf.contrib.layers.convolution2d(inputs=self.image, num_outputs=<span class="number">32</span>, </div><div class="line">            kernel_size=[<span class="number">8</span>,<span class="number">8</span>], stride=[<span class="number">4</span>,<span class="number">4</span>], padding=<span class="string">'VALID'</span>, biases_initializer=<span class="keyword">None</span>)</div><div class="line">        self.conv2 = tf.contrib.layers.convolution2d(inputs=self.conv1, num_outputs=<span class="number">64</span>, </div><div class="line">            kernel_size=[<span class="number">4</span>,<span class="number">4</span>], stride=[<span class="number">2</span>,<span class="number">2</span>],padding=<span class="string">'VALID'</span>, biases_initializer=<span class="keyword">None</span>)</div><div class="line">        self.conv3 = tf.contrib.layers.convolution2d(inputs=self.conv2, num_outputs=<span class="number">64</span>, </div><div class="line">            kernel_size=[<span class="number">3</span>,<span class="number">3</span>], stride=[<span class="number">1</span>,<span class="number">1</span>], padding=<span class="string">'VALID'</span>, biases_initializer=<span class="keyword">None</span>)</div><div class="line">        self.conv4 = tf.contrib.layers.convolution2d(inputs=self.conv3, num_outputs=<span class="number">512</span>, </div><div class="line">            kernel_size=[<span class="number">7</span>,<span class="number">7</span>], stride=[<span class="number">1</span>,<span class="number">1</span>], padding=<span class="string">'VALID'</span>, biases_initializer=<span class="keyword">None</span>)</div><div class="line"></div><div class="line">        self.conv4_1, self.conv4_2 = tf.split(self.conv4, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">        self.flat_1 = tf.contrib.layers.flatten(self.conv4_1)</div><div class="line">        self.flat_2 = tf.contrib.layers.flatten(self.conv4_2)</div><div class="line">        self.advantage_weight = tf.Variable(tf.random_normal([<span class="number">256</span>, self.env.action_num]), </div><div class="line">            name=<span class="string">"advantage_weight"</span>)</div><div class="line">        self.value_weight = tf.Variable(tf.random_normal([<span class="number">256</span>, <span class="number">1</span>]), name=<span class="string">"value_weight"</span>)</div><div class="line">        self.advantage = tf.matmul(self.flat_1, self.advantage_weight)</div><div class="line">        self.value = tf.matmul(self.flat_2, self.value_weight)</div><div class="line">        </div><div class="line">        self.q_value = self.value + tf.subtract(self.advantage, </div><div class="line">            tf.reduce_mean(self.advantage, reduction_indices=<span class="number">1</span>, keep_dims=<span class="keyword">True</span>))</div><div class="line">        self.action = tf.argmax(self.q_value, <span class="number">1</span>)</div><div class="line"></div><div class="line">        <span class="comment"># self.actions 是一维的，类似于[1,1,2,3,1,0.....]</span></div><div class="line">        self.actions = tf.placeholder(shape=[<span class="keyword">None</span>], dtype=tf.int32)</div><div class="line">        <span class="comment"># self.target_q 是一维的，是self.actions 中每个动作对应的q值</span></div><div class="line">        self.target_q = tf.placeholder(shape=[<span class="keyword">None</span>], dtype=tf.float32)</div><div class="line">        <span class="comment"># self.q_value_of_action 是一维的，是self.actions 中每个动作对应的预测q值</span></div><div class="line">        self.actions_onehot = tf.one_hot(self.actions, self.env.action_num, dtype=tf.float32)</div><div class="line">        self.q_value_on_action = tf.reduce_sum(tf.multiply(self.q_value, self.actions_onehot), </div><div class="line">            reduction_indices=<span class="number">1</span>)</div><div class="line">        </div><div class="line">        self.loss = tf.reduce_mean(tf.square(self.target_q - self.q_value_on_action))</div><div class="line">        self.trainer = tf.train.AdamOptimizer(learning_rate=<span class="number">0.00001</span>)</div><div class="line">        self.update_model = self.trainer.minimize(self.loss)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExperienceBuffer</span><span class="params">()</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, buffer_size=<span class="number">50000</span>)</span>:</span></div><div class="line">        self.buffer = []</div><div class="line">        self.buffer_size = buffer_size</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, experience)</span>:</span></div><div class="line">        num_to_remove = len(self.buffer) + len(experience) - self.buffer_size</div><div class="line">        <span class="keyword">if</span> num_to_remove &gt; <span class="number">0</span>:</div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(num_to_remove):</div><div class="line">                self.buffer.pop(<span class="number">0</span>)</div><div class="line">        self.buffer.extend(experience)</div><div class="line">            </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sample</span><span class="params">(self, size)</span>:</span></div><div class="line">        indices = np.random.choice(np.arange(len(self.buffer)), size=size)</div><div class="line">        <span class="keyword">return</span> [self.buffer[index] <span class="keyword">for</span> index <span class="keyword">in</span> indices]</div><div class="line"></div><div class="line">     </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_update_target_ops</span><span class="params">(variables, tau)</span>:</span></div><div class="line">    main_DQN_vars = variables[<span class="number">0</span>:len(variables)//<span class="number">2</span>]</div><div class="line">    target_DQN_vars = variables[len(variables)//<span class="number">2</span>:]</div><div class="line">    ops = []</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(target_DQN_vars)):</div><div class="line">        ops.append(target_DQN_vars[i].assign(</div><div class="line">            main_DQN_vars[i].value() * tau + (<span class="number">1</span> - tau) * target_DQN_vars[i].value()</div><div class="line">            ))</div><div class="line">    <span class="keyword">return</span> ops</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_target</span><span class="params">(ops, sess)</span>:</span></div><div class="line">    <span class="keyword">for</span> op <span class="keyword">in</span> ops:</div><div class="line">        sess.run(op)</div><div class="line"></div><div class="line"><span class="comment">########################## 超参数 #####################</span></div><div class="line">batch_size = <span class="number">32</span></div><div class="line"></div><div class="line"><span class="comment">#How often to perform a training step.</span></div><div class="line">update_freq = <span class="number">4</span></div><div class="line">gamma = <span class="number">.99</span></div><div class="line">random_upper_bound = <span class="number">1</span></div><div class="line">random_lower_bound = <span class="number">0.1</span></div><div class="line">annealing_steps = <span class="number">10000</span></div><div class="line">random_threshold = random_upper_bound</div><div class="line">drop_step = (random_upper_bound - random_lower_bound) / annealing_steps</div><div class="line"></div><div class="line"><span class="comment">#How many episodes of game environment to train network with.</span></div><div class="line">num_episodes = <span class="number">10000</span></div><div class="line"><span class="comment">#How many steps of random actions before training begins.</span></div><div class="line">pre_train_steps = <span class="number">10000</span></div><div class="line"><span class="comment">#The max allowed length for one episode.</span></div><div class="line">max_episode_length = <span class="number">50</span></div><div class="line">load_model = <span class="keyword">False</span> </div><div class="line">path = <span class="string">"./dqn"</span></div><div class="line"><span class="comment">#Rate to update target network toward primary network</span></div><div class="line">tau = <span class="number">0.001</span></div><div class="line"></div><div class="line"><span class="comment">########################## 训练 #####################</span></div><div class="line">env = GridWorld(size=<span class="number">5</span>)</div><div class="line">tf.reset_default_graph()</div><div class="line">main_DQN = DQN(env, <span class="string">"main"</span>)</div><div class="line">target_DQN = DQN(env, <span class="string">"target"</span>)</div><div class="line"></div><div class="line">init_op = tf.global_variables_initializer()</div><div class="line">update_target_ops_1 = get_update_target_ops(tf.trainable_variables(), <span class="number">1</span>)</div><div class="line">update_target_ops_2 = get_update_target_ops(tf.trainable_variables(), tau)</div><div class="line"></div><div class="line">saver = tf.train.Saver()</div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</div><div class="line">    os.makedirs(path)</div><div class="line"></div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    <span class="keyword">if</span> load_model == <span class="keyword">True</span>:</div><div class="line">        print(<span class="string">'Loading Model...'</span>)</div><div class="line">        ckpt = tf.train.get_checkpoint_state(path)</div><div class="line">        saver.restore(sess,ckpt.model_checkpoint_path)</div><div class="line">    sess.run(init_op)</div><div class="line">    </div><div class="line">    <span class="comment">#Set the target network to be equal to the main network.</span></div><div class="line">    update_target(update_target_ops_2, sess)</div><div class="line">    global_experience_buffer = ExperienceBuffer()</div><div class="line">    </div><div class="line">    <span class="comment">#create list to contain total rewards per episode</span></div><div class="line">    total_reward_list = []</div><div class="line">    steps = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_episodes + <span class="number">1</span>):</div><div class="line">        episode_buffer = ExperienceBuffer()</div><div class="line">        observation = env.reset()</div><div class="line">        observation = np.reshape(observation, [<span class="number">21168</span>])</div><div class="line">        done = <span class="keyword">False</span></div><div class="line">        total_reward_in_episode = <span class="number">0</span></div><div class="line">        steps_in_episode = <span class="number">0</span></div><div class="line">        <span class="keyword">while</span> steps_in_episode &lt; max_episode_length:</div><div class="line">            <span class="comment"># 积累样本</span></div><div class="line">            steps_in_episode += <span class="number">1</span></div><div class="line">            steps += <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> np.random.rand(<span class="number">1</span>) &lt; random_threshold <span class="keyword">or</span> steps &lt; pre_train_steps:</div><div class="line">                action = np.random.randint(<span class="number">0</span>, <span class="number">4</span>)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                action = sess.run(main_DQN.action, feed_dict=&#123;main_DQN.scalar_input: [observation]&#125;)[<span class="number">0</span>]</div><div class="line">            new_observation, reward, done = env.step(action)</div><div class="line">            new_observation = np.reshape(new_observation, [<span class="number">21168</span>])</div><div class="line">            <span class="comment">#Save the experience to episode buffer</span></div><div class="line">            episode_buffer.add([[observation, action, reward, new_observation, done]])</div><div class="line">            </div><div class="line">            total_reward_in_episode += reward</div><div class="line">            observation = new_observation</div><div class="line">            <span class="comment"># 积累了 pre_train_steps/max_episode_length 次经历的pre_train_steps个样本之后，</span></div><div class="line">            <span class="comment"># 才会第一次开始衰减随机门限，进行第一次训练。</span></div><div class="line">            <span class="keyword">if</span> steps &gt;= pre_train_steps:</div><div class="line">                <span class="keyword">if</span> random_threshold &gt; random_lower_bound:</div><div class="line">                    random_threshold -= drop_step</div><div class="line">                <span class="keyword">if</span> steps % (update_freq) == <span class="number">0</span>:</div><div class="line">                    train_batch = global_experience_buffer.sample(batch_size)</div><div class="line">                    <span class="comment">#Below we perform the Double-DQN update to the target Q-values</span></div><div class="line">                    observations = np.vstack([record[<span class="number">0</span>] <span class="keyword">for</span> record <span class="keyword">in</span> train_batch])</div><div class="line">                    actions = np.array([record[<span class="number">1</span>] <span class="keyword">for</span> record <span class="keyword">in</span> train_batch])</div><div class="line">                    instant_rewards = np.array([record[<span class="number">2</span>] <span class="keyword">for</span> record <span class="keyword">in</span> train_batch])</div><div class="line">                    new_observations = np.vstack([record[<span class="number">3</span>] <span class="keyword">for</span> record <span class="keyword">in</span> train_batch])</div><div class="line">                    </div><div class="line">                    action = sess.run(main_DQN.action, feed_dict=&#123;main_DQN.scalar_input: new_observations&#125;)</div><div class="line">                    q_value, value, advantage = sess.run([target_DQN.q_value, target_DQN.value, target_DQN.advantage], </div><div class="line">                        feed_dict=&#123;target_DQN.scalar_input: new_observations&#125;)</div><div class="line">                    labels = instant_rewards + gamma * q_value[range(batch_size) ,action]</div><div class="line"></div><div class="line">                    <span class="comment"># Update the network with our target values.</span></div><div class="line">                    _ = sess.run(main_DQN.update_model, feed_dict=&#123;</div><div class="line">                        main_DQN.scalar_input: observations,</div><div class="line">                        main_DQN.target_q: labels,</div><div class="line">                        main_DQN.actions: actions&#125;)</div><div class="line"></div><div class="line">                    <span class="comment">#update the target network towards the main network.</span></div><div class="line">                    update_target(update_target_ops_2, sess)</div><div class="line">        </div><div class="line">        <span class="comment">#Get all experiences from this episode</span></div><div class="line">        global_experience_buffer.add(episode_buffer.buffer)</div><div class="line">        total_reward_list.append(total_reward_in_episode)</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> i % <span class="number">25</span> == <span class="number">0</span>:</div><div class="line">            print(<span class="string">'episode'</span>,i,<span class="string">', average reward of last 25 episode'</span>, np.mean(total_reward_list[<span class="number">-25</span>:]))</div><div class="line">        <span class="comment">#Periodically save the model.</span></div><div class="line">        <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> i % <span class="number">1000</span> == <span class="number">0</span>:</div><div class="line">            saver.save(sess,path+<span class="string">'/model-'</span>+str(i)+<span class="string">'.cptk'</span>)</div><div class="line">            print(<span class="string">"Saved Model"</span>)</div><div class="line">    saver.save(sess,path+<span class="string">'/model-'</span>+str(i)+<span class="string">'.cptk'</span>)</div></pre></td></tr></table></figure></p>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2017/12/09/强化学习-2-策略网络及其-TensorFlow-实现/">
                强化学习 2 策略网络及其 TensorFlow 实现
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-12-09</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h1 id="强化学习-2-策略网络及其-TensorFlow-实现"><a href="#强化学习-2-策略网络及其-TensorFlow-实现" class="headerlink" title="强化学习 2 策略网络及其 TensorFlow 实现"></a>强化学习 2 策略网络及其 TensorFlow 实现</h1><h2 id="策略网络"><a href="#策略网络" class="headerlink" title="策略网络"></a>策略网络</h2><p>在强化学习中，我们并不知道标签，对于某一个特定的环境状态，我们并不知道它对应的最好的动作是什么，只知道当前动作获得的奖励和试验后获得的未来奖励。我们需要让模型通过试验自己学习什么动作才是某一个特定环境状态下的较优动作，而不是告诉模型较优动作是什么，因为我们也不知道正确的答案。<br>为了让策略网络更好的理解未来，不仅仅要考虑动作的当前奖励，还要动作的考虑未来的、潜在的奖励，即奖励为 Discounted Reward。在训练过程中，模型会接触到好的动作以及它们带来的高奖励，差的动作以及它们带来的低奖励，通过学习，模型会逐渐增加选择好的动作的概率，降低选择差动作的概率，这样就逐渐完成了策略的学习。策略网络是一个End-to-End（端到端）的方法，直接产生动作。</p>
<h2 id="Gym"><a href="#Gym" class="headerlink" title="Gym"></a>Gym</h2><p>核心概念</p>
<ol>
<li>Environment，</li>
<li>Agent（编写的算法/模型）<br>Agent 观察环境状态（Observation），执行动作（Action）改变环境（Environment），得到奖励（Reward），再观察环境状态执行动作得到奖励，周而复始。即 Observation-Action-Reward 循环。<h2 id="策略网络解决-CartPole-任务"><a href="#策略网络解决-CartPole-任务" class="headerlink" title="策略网络解决 CartPole 任务"></a>策略网络解决 CartPole 任务</h2></li>
<li>Observation 四元组（车的位置，车的速度，杆的角度，杆的速度）</li>
<li>Action Space 给小车施加正向或者反向的力（0， 1）</li>
<li>任务目标时尽可能保持杆竖直不倒，当小车偏离中心超过2.4个单位或者杆的倾角大于15度时，任务失败。</li>
<li>在每坚持一步就会获得+1的奖励，模型要坚持尽可能长的时间而不导致任务失败。</li>
<li>模型为了获得尽可能多的奖励就要有远见，不能仅考虑当前的奖励，也要考虑未来长远的奖励<br>采取随机动作的 Agent：<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> gym</div><div class="line">env = gym.make(<span class="string">"CartPole-v0"</span>)</div><div class="line"></div><div class="line">env.reset()</div><div class="line">random_episodes = <span class="number">0</span></div><div class="line">reward_sum = <span class="number">0</span></div><div class="line"><span class="keyword">while</span> random_episodes &lt; <span class="number">10</span>:</div><div class="line">    observation, reward, done, _ = env.step(np.random.choice([<span class="number">0</span>, <span class="number">1</span>]))</div><div class="line">    reward_sum += reward</div><div class="line">    <span class="keyword">if</span> done:</div><div class="line">        random_episodes += <span class="number">1</span></div><div class="line">        print(<span class="string">"Reward for this episode was: "</span>, reward_sum)</div><div class="line">        reward_sum = <span class="number">0</span></div><div class="line">        env.reset()</div></pre></td></tr></table></figure>
</li>
</ol>
<p>MLP Policy Network：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!coding: utf-8</span></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </div><div class="line"><span class="keyword">import</span> gym </div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf </div><div class="line">env = gym.make(<span class="string">"CartPole-v0"</span>)</div><div class="line"></div><div class="line"><span class="comment">################################# 网络结构 #####################</span></div><div class="line">hidden_n = <span class="number">50</span></div><div class="line">batch_size = <span class="number">25</span></div><div class="line">learning_rate = <span class="number">1e-1</span></div><div class="line">input_dim = <span class="number">4</span></div><div class="line">output_dim = <span class="number">1</span></div><div class="line">gamma = <span class="number">0.99</span></div><div class="line"></div><div class="line">observation_placeholder = tf.placeholder(tf.float32, [<span class="keyword">None</span>, input_dim], name=<span class="string">"observation_placeholder"</span>)</div><div class="line">w_1 = tf.get_variable(<span class="string">"w_1"</span>, shape=[input_dim, hidden_n], initializer=tf.contrib.layers.xavier_initializer())</div><div class="line">layer_1 = tf.nn.relu(tf.matmul(observation_placeholder, w_1))</div><div class="line">w_2 = tf.get_variable(<span class="string">"w_2"</span>, shape=[hidden_n, output_dim], initializer=tf.contrib.layers.xavier_initializer())</div><div class="line">probability = tf.nn.sigmoid(tf.matmul(layer_1, w_2))</div><div class="line"></div><div class="line"><span class="comment">################################# 批优化 #####################</span></div><div class="line"><span class="string">'''</span></div><div class="line"><span class="string">深度强化学习的训练也是采用 batch training，不逐个“样本”的更新参数，而累计 batch_size 个经历（episode）再更新参数，防止</span></div><div class="line"><span class="string">单一经历（episode）随机扰动噪声对模型训练带来的不利影响。</span></div><div class="line"><span class="string">不像 CNN 那样一个 batch 样本 feed 进模型，直接产生一个梯度平均值就可以进行一次参数的更新，</span></div><div class="line"><span class="string">这里需要进行 batch_size 次play从而得到 batch_size 个经历（episode），需要存储每经历（episode）中的平均梯度，并进行平均，最终更新一次参数。</span></div><div class="line"><span class="string">'''</span></div><div class="line">adam = tf.train.AdamOptimizer(learning_rate=learning_rate)</div><div class="line">w_1_grad = tf.placeholder(tf.float32, name=<span class="string">"batch_grad_1"</span>)</div><div class="line">w_2_grad = tf.placeholder(tf.float32, name=<span class="string">"batch_grad_2"</span>)</div><div class="line">batch_grad = [w_1_grad, w_2_grad]</div><div class="line">update = adam.apply_gradients(zip(batch_grad, tf.trainable_variables()))</div><div class="line"></div><div class="line"><span class="comment">################################# 损失 #####################</span></div><div class="line"><span class="string">'''</span></div><div class="line"><span class="string">在 CartPole 问题中，每一次得到的奖励和这次奖励之前的所有动作都有关，也就说之前的所有动作导致了这次奖励的得到，</span></div><div class="line"><span class="string">为了计算一个动作带来的奖励我们要计算这个动作之后全部奖励的折扣和。</span></div><div class="line"><span class="string">我们倒推求解每一个动作带来的奖励。在 CartPole 任务中除了导致任务失败的那次动作之外，所有动作的即时奖励都是 1。</span></div><div class="line"><span class="string">一个动作带来的奖励是后一时间步动作带来的奖励的折扣加上这个动作的即时奖励。</span></div><div class="line"><span class="string">'''</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">discount_reward</span><span class="params">(r)</span>:</span></div><div class="line">    d_r = np.zeros_like(r)</div><div class="line">    d_r[<span class="number">-1</span>] = r[<span class="number">-1</span>]</div><div class="line">    <span class="keyword">for</span> time <span class="keyword">in</span> range(len(r)<span class="number">-1</span>)[::<span class="number">-1</span>]:</div><div class="line">        d_r[time] =  d_r[time+<span class="number">1</span>] * gamma + r[time]</div><div class="line">    <span class="keyword">return</span> d_r</div><div class="line"></div><div class="line"><span class="comment"># 模型做出的动作的反动作，学习目标，相当于 label，是来自于模型的概率输出与一个来自均匀分布的随机数的比较</span></div><div class="line">opposite_action = tf.placeholder(tf.float32, [<span class="keyword">None</span>, <span class="number">1</span>], name=<span class="string">"opposite_action"</span>)</div><div class="line"><span class="comment"># 动作带来的奖励</span></div><div class="line">advantage = tf.placeholder(tf.float32, name=<span class="string">"reward_signal"</span>)</div><div class="line"><span class="string">'''</span></div><div class="line"><span class="string">模型得到这份奖励的概率：</span></div><div class="line"><span class="string">opposite_action=1 时，即 action=0，1- probability</span></div><div class="line"><span class="string">opposite_action=0 时，即 action=1，probability</span></div><div class="line"><span class="string">综合上面两个式子，模型得到这份奖励的概率：</span></div><div class="line"><span class="string">opposite_action * (opposite_action - probability) + (1 - opposite_action) * (opposite_action + probability)</span></div><div class="line"><span class="string">'''</span></div><div class="line"><span class="comment"># 模型得到这份奖励的概率的对数：</span></div><div class="line">log_prob = tf.log(opposite_action * (opposite_action - probability) </div><div class="line">    + (<span class="number">1</span> - opposite_action) * (opposite_action + probability))</div><div class="line">loss = -tf.reduce_mean(log_prob * advantage)</div><div class="line">gradients = tf.gradients(loss, tf.trainable_variables())</div><div class="line"></div><div class="line"><span class="comment">################################# 训练 #####################</span></div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    init = tf.global_variables_initializer()</div><div class="line">    sess.run(init)</div><div class="line"></div><div class="line">    observation = env.reset()</div><div class="line">    xs, ys, rewards = [], [], []</div><div class="line">    reward_sum = <span class="number">0</span></div><div class="line">    episode = <span class="number">1</span></div><div class="line">    total_episodes = <span class="number">10000</span></div><div class="line"></div><div class="line">    grad_buffer = sess.run(tf.trainable_variables())</div><div class="line">    <span class="keyword">for</span> i, grad <span class="keyword">in</span> enumerate(grad_buffer):</div><div class="line">        grad_buffer[i] = grad * <span class="number">0</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> episode &lt;= total_episodes:</div><div class="line">        x = np.reshape(observation, [<span class="number">1</span>, input_dim])</div><div class="line">        prob = sess.run(probability, feed_dict=&#123;observation_placeholder: x&#125;)</div><div class="line">        action = <span class="number">1</span> <span class="keyword">if</span> np.random.uniform() &lt; prob <span class="keyword">else</span> <span class="number">0</span></div><div class="line">        xs.append(x)</div><div class="line">        ys.append(<span class="number">1</span> - action)</div><div class="line">        observation, reward, done, info = env.step(action)</div><div class="line">        reward_sum += reward</div><div class="line">        rewards.append(reward)</div><div class="line">        <span class="keyword">if</span> done:</div><div class="line">            <span class="comment">### 构建一个经历（episode）的样本，计算该经历（episode）中所有样本上的梯度和，并加入到此批次的梯度buffer中 #####</span></div><div class="line">            episode += <span class="number">1</span></div><div class="line">            xs_per_episode = np.vstack(xs)</div><div class="line">            ys_per_episode = np.vstack(ys)</div><div class="line">            rewards_per_episode = np.vstack(rewards)</div><div class="line">            xs, ys, rewards = [], [], []</div><div class="line">            d_r = discount_reward(rewards_per_episode)</div><div class="line">            d_r -= np.mean(d_r)</div><div class="line">            d_r /= np.std(d_r)</div><div class="line">            grad_per_episode = sess.run(gradients, feed_dict=&#123;observation_placeholder: xs_per_episode,</div><div class="line">                opposite_action: ys_per_episode,</div><div class="line">                advantage: d_r&#125;)</div><div class="line">            <span class="keyword">for</span> i, grad <span class="keyword">in</span> enumerate(grad_per_episode):</div><div class="line">                grad_buffer[i] += grad</div><div class="line"></div><div class="line">            <span class="keyword">if</span> episode % batch_size == <span class="number">0</span>:</div><div class="line">                sess.run(update, feed_dict=&#123;w_1_grad: grad_buffer[<span class="number">0</span>], w_2_grad: grad_buffer[<span class="number">1</span>]&#125;)</div><div class="line"></div><div class="line">                <span class="keyword">for</span> i, grad <span class="keyword">in</span> enumerate(grad_buffer):</div><div class="line">                    grad_buffer[i] = grad * <span class="number">0</span></div><div class="line"></div><div class="line">                print(<span class="string">"Average reward for episode %d : %.2f"</span> %(episode, reward_sum/batch_size))</div><div class="line"></div><div class="line">                <span class="keyword">if</span> reward_sum/batch_size &gt;= <span class="number">200</span>:</div><div class="line">                    print(<span class="string">"Task solved in %d episodes"</span> % episode)</div><div class="line">                    <span class="keyword">break</span></div><div class="line">                reward_sum =<span class="number">0</span></div><div class="line">            observation = env.reset()</div></pre></td></tr></table></figure></p>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="" href="/page/3/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/5/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This is Robert Lexis (FengCun Li). To see the world, things dangerous to come to, to see behind walls, to draw closer, to find each other and to feel. That is the purpose of LIFE.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2018/08/26/YOLO/">YOLO</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/26/非最大值抑制/">非最大值抑制</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/26/目标定位-vs-目标检测/">目标定位 vs 目标检测</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/13/消失的梯度/">消失的梯度</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/RobertLexis">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:robert_lexis@163.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Robert Lexis Loves Wenny
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>