<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    

    <!--Author-->
    
        <meta name="author" content="Robert Lexis">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="This is WHY."/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="This is WHY."/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>page - This is WHY.</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">This is WHY.</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/05/17/C-Miscellaneous/">
                C++ Miscellaneous
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-05-17</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="子类父类的同名函数"><a href="#子类父类的同名函数" class="headerlink" title="子类父类的同名函数"></a>子类父类的同名函数</h3><p>子类和父类的方法之间就只能是重写，不允许重载，如果你试图重载发生的就只能是隐藏，子类的方法会完全隐藏父类所有的同名函数，即<strong>你在子类中定义了一个父类中函数的同名函数，则父类中所有的同名函数对于子类来说均不可用了</strong>，一是因为发生重写，二是因为不允许子类和父类的方法之间发生重载，子类中的这个函数会完全隐藏父类所有的同名函数。</p>
<h3 id="为什么对于存在虚函数的类中析构函数要定义成虚函数"><a href="#为什么对于存在虚函数的类中析构函数要定义成虚函数" class="headerlink" title="为什么对于存在虚函数的类中析构函数要定义成虚函数"></a>为什么对于存在虚函数的类中析构函数要定义成虚函数</h3><p>存在虚函数的类，也就是多态，<strong>经常会（如果不是总会的话）</strong>用一个基类指针去指向一个派生类对象，如果析构函数是 non-virtual 的，当 delete 基类指针时，其结果是未定义的，实际执行时通常发生的是对象的 derived 成分未被销毁。 即调用的是基类的析构函数，而派生类的析构函数未能执行，会造成一个诡异的“局部销毁”对象，这会导致资源泄露，数据结构败坏，在调试器上浪费很多的时间。<br>用一个基类指针指向派生类的对象时，不管存不存在虚函数，delete 基类指针都会陷入局部销毁的陷阱。如果你企图继承一个标准容器或者任何其他的“带有non-virtual析构函数”的 class，拒绝诱惑吧。<strong>基类应该有个虚析构函数。</strong>这一句话说的是带有多态性质的基类，即“通过基类的接口处理派生类对象”。有的类不是意图当作基类的，有的基类并不用于多态性质，即并非被设计用来“通过基类的接口处理派生类对象”，这样的类是不需为其提供虚析构函数的，因为它们就不可能陷入“局部销毁”陷阱。如果一个类你是企图设计它作为基类，那么它就应该拥有一个虚析构函数，这样的话，就当 delete 一个指向派生类对象的基类指针时就绝不会陷入“局部销毁”的陷阱了。由于像 string 这些标准库中的类就不是设计用来当作基类的，所有没有虚析构函数，不该尝试对其进行继承操作。<br>不是企图当作基类的类，不该为其定义虚函数，这是出于空间和移植性的考虑；虚函数的语义就是强制派生类对其进行重写，也就是这个类是意图当作基类的语义。所以在一个侧面，虚函数和基类是挂钩的。<br>当将一个类的析构函数申明为纯虚函数，这个类变成了一个抽象类，与普通的纯虚函数不一样的是，你必须要为这个纯虚析构函数提供一份定义，不然的话就会导致链接错误，这和析构函数的运作方式有关。析构函数的运作方式是：最深层派生的那个class其析构函数最先被调用，然后是其每一个基类的析构函数被调用，编译器会在类A的派生类的析构函数中创建一个对 ~A 的调用动作， 所以必须要为这个函数提供一份定义，否则链接器就会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class A</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    virtual ~A()=0;    </div><div class="line">&#125;;</div><div class="line">A::~A() &#123;&#125;</div></pre></td></tr></table></figure></p>
<h3 id="析构函数能抛出异常吗"><a href="#析构函数能抛出异常吗" class="headerlink" title="析构函数能抛出异常吗"></a>析构函数能抛出异常吗</h3><p>C++ 并不禁止析构函数抛出异常，当它并不鼓励你这样做。只要析构函数抛出异常，即使并非使用容器或者array，程序也可能过早结束或者出现不明确的行为。请记住：</p>
<ol>
<li>析构函数绝对不要抛出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吐下它们（不传播）或者结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通函数（而非在析构函数）中执行该操作。</li>
</ol>
<h3 id="构造函数和析构函数中能调用虚函数吗？"><a href="#构造函数和析构函数中能调用虚函数吗？" class="headerlink" title="构造函数和析构函数中能调用虚函数吗？"></a>构造函数和析构函数中能调用虚函数吗？</h3><p>绝对不要在构造函数和析构函数中调用虚函数，而且确保它们调用的所有函数也都服从这一约束。是因为如此并不能做到多态，这与构造函数和析构函数的运作方式有关，当在继承链中执行构造或者析构时，派生类的对象尚未存在或者已经不复存在，不能做到多态，这与你的设计初衷不符会使得程序的执行结果不符预期，所以就不要这样做。在构造和析构期间不要调用虚函数，因为这类调用从不能下降至派生类，这是合理的，是因为此时派生类的特有成员变量会呈现未定义状态，不管是因为尚未定义或是已经销毁，一旦下降至派生类并调用函数可能会触发对这些未定义变量的访问。</p>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><ol>
<li>什么时候改变引用计数？<br>构造函数中计数初始化为1；拷贝构造函数中计数值加1；赋值运算符中，左边的对象引用计数减一，右边的对象引用计数加一；析构函数中引用计数减一；在赋值运算符和析构函数中，如果减一后为0，则调用delete释放对象。</li>
</ol>
<ul>
<li>当用一个 shared_ptr 初始化另一个 shared_ptr</li>
<li>作为函数参数传递给一个函数</li>
<li>作为函数的返回值</li>
<li>给 shared_ptr 赋予一个新值</li>
<li>shared_ptr 被销毁，例如一个局部的 shared_ptr 离开其作用域</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;memory&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    shared_ptr&lt;string&gt; p1(new string(&quot;Jasmine&quot;));</div><div class="line">    shared_ptr&lt;string&gt; p2(new string(&quot;Robert&quot;), [] (string* p) &#123;</div><div class="line">        cout &lt;&lt; &quot;But maybe there is hope.&quot; &lt;&lt; endl;</div><div class="line">        delete p;</div><div class="line">    &#125;);</div><div class="line">    vector&lt;shared_ptr&lt;string&gt;&gt; v;</div><div class="line">    v.push_back(p1);</div><div class="line">    v.push_back(p1);</div><div class="line">    v.push_back(p2);</div><div class="line">    cout &lt;&lt; *p1 &lt;&lt; &quot; Love &quot; &lt;&lt; *p2 &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; p1.use_count() &lt;&lt; &quot;;&quot; &lt;&lt; p2.use_count() &lt;&lt; endl;</div><div class="line">    p1 = p2;</div><div class="line">    // 这时候 p1 和 p2 是 “同一个” shared_ptr。</div><div class="line">    cout &lt;&lt; p1.use_count() &lt;&lt; &quot;;&quot; &lt;&lt; p2.use_count() &lt;&lt; endl;</div><div class="line">    // 这样查看才是正确的。</div><div class="line">    cout &lt;&lt; v[0].use_count() &lt;&lt; &quot;;&quot; &lt;&lt; p2.use_count() &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; &quot;This is a sad story~&quot; &lt;&lt; endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Jasmine Love Robert</div><div class="line">3;2</div><div class="line">3;3</div><div class="line">2;3</div><div class="line">This is a sad story~</div><div class="line">But maybe there is hope.</div></pre></td></tr></table></figure></p>
<ol>
<li><p>智能指针是怎么实现的？<br>基于引用计数的智能指针实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">// 基于引用计数的智能指针简单实现</div><div class="line">template&lt;class T&gt;</div><div class="line">class SmartPtr</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    SmartPtr(T *p);</div><div class="line">    ~SmartPtr();</div><div class="line">    SmartPtr(const SmartPtr &amp; orig);            // 浅拷贝</div><div class="line">    SmartPtr&amp; operator=(const SmartPtr &amp; rhs);    // 浅拷贝</div><div class="line">private:</div><div class="line">    T *ptr;</div><div class="line">    // 将 use_count 声明成指针是为了方便对其的递增或递减操作</div><div class="line">    int *use_count;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">template&lt;class T&gt;</div><div class="line">SmartPtr&lt;T&gt;::SmartPtr(T *p) : ptr(p)</div><div class="line">&#123;</div><div class="line">    try</div><div class="line">    &#123;   // 动态分配一个整型对象，并用 1 进行初始化</div><div class="line">        use_count = new int(1);</div><div class="line">    &#125;</div><div class="line">    catch (...)</div><div class="line">    &#123;</div><div class="line">        delete ptr;</div><div class="line">        ptr = nullptr;</div><div class="line">        use_count = nullptr;</div><div class="line">        cout &lt;&lt; &quot;Allocate memory for use_count fails.&quot; &lt;&lt; endl;</div><div class="line">        exit(1);</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; &quot;Constructor is called!&quot; &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">template&lt;class T&gt;</div><div class="line">SmartPtr&lt;T&gt;::~SmartPtr()</div><div class="line">&#123;</div><div class="line">    // 只在最后一个对象引用ptr时才释放内存</div><div class="line">    if (--(*use_count) == 0)</div><div class="line">    &#123;</div><div class="line">        delete ptr;</div><div class="line">        delete use_count;</div><div class="line">        ptr = nullptr;</div><div class="line">        use_count = nullptr;</div><div class="line">        cout &lt;&lt; &quot;Destructor is called!&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">template&lt;class T&gt;</div><div class="line">SmartPtr&lt;T&gt;::SmartPtr(const SmartPtr&lt;T&gt; &amp;orig)</div><div class="line">&#123;</div><div class="line">    ptr = orig.ptr;</div><div class="line">    use_count = orig.use_count;</div><div class="line">    ++(*use_count);</div><div class="line">    cout &lt;&lt; &quot;Copy constructor is called!&quot; &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 拷贝赋值运算符不同于拷贝构造函数，即等号左边的对象可能已经指向某块内存。</div><div class="line">// 这样，我们就需要判断左边对象指向的内存已经被引用的次数。如果次数为1，</div><div class="line">// 表明我们可以释放这块内存；反之则不释放，由其他对象来释放。</div><div class="line">template&lt;class T&gt;</div><div class="line">SmartPtr&lt;T&gt;&amp; SmartPtr&lt;T&gt;::operator=(const SmartPtr&lt;T&gt; &amp;rhs)</div><div class="line">&#123;</div><div class="line">    // 《C++ primer》：“这个赋值操作符在减少左操作数的使用计数之前使 rhs 的使用计数加1，</div><div class="line">    // 从而防止自身赋值”而导致的提早释放内存</div><div class="line">    ++(*rhs.use_count);</div><div class="line"></div><div class="line">    // 将左操作数对象的使用计数减1，若该对象的使用计数减至0，则删除该对象</div><div class="line">    if (--(*use_count) == 0)</div><div class="line">    &#123;   </div><div class="line">        // 左操作数是最后一个指向管理对象的智能指针了，</div><div class="line">        // 虽然左侧操作数这个对象本身不至删除，但是左操作数所管理的对象及左操作数原来所分配的空间必须被销毁。</div><div class="line">        delete ptr;</div><div class="line">        delete use_count;</div><div class="line">        cout &lt;&lt; &quot;Left side object is deleted!&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ptr = rhs.ptr;</div><div class="line">    use_count = rhs.use_count;</div><div class="line">    </div><div class="line">    cout &lt;&lt; &quot;Assignment operator is called!&quot; &lt;&lt; endl;</div><div class="line">    return *this;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>share_prt与weak_ptr的区别？<br>只要有一个 shared_ptr 指向一个对象，这个对象就不会被销毁。<br>而一旦指向一个对象的最后一个 shared_ptr 被销毁，这个对象就会被销毁，即使有 weak_ptr 指向这个对象。<br>weak_ptr 不控制所指向对象的生存期，将一个 weak_ptr 绑定到一个 shared_ptr 上，并不增加 shared_ptr 所管理对象的引用计数，体现出了“弱”共享对象的特点。</p>
</li>
</ol>
<h3 id="内存对齐的原则"><a href="#内存对齐的原则" class="headerlink" title="内存对齐的原则"></a>内存对齐的原则</h3><p>CPU 的优化原则: 对于 n 个字节的元素(n=2, 4, 8,…) ,它的首地址能被 n 整除,才能获得最好的性能.设计编译器时可以这样做:对于每一个变量,从当前位置向后找到第一个满足这样条件的地址作为首地址.<br>结构体长度一定是最长元素的整数倍,这样当其放入数组的时候,才不会为遵守CPU 的优化原则而产生空隙.</p>
<h3 id="内联函数有什么优点？内联函数与宏定义的区别？"><a href="#内联函数有什么优点？内联函数与宏定义的区别？" class="headerlink" title="内联函数有什么优点？内联函数与宏定义的区别？"></a>内联函数有什么优点？内联函数与宏定义的区别？</h3><p>内联函数和普通函数相比可以加快程序运行的速度，因为不需要中断调用，在编译的时候内联函数可以直接被镶嵌到目标代码中。<br>用内联函数完全取代宏：</p>
<ol>
<li>内联函数可利用调试器进行调试，而宏定义不可以;</li>
<li>编译器会对内联函数的参数类型做安全检查或自动类型转换（同普通函数），而宏定<br>义则不会； </li>
<li>内联函数可以访问类的成员变量，宏定义则不能； </li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数。</li>
</ol>
<p>inline 是指嵌入代码，就是在调用函数的地方不是跳转，而是把代码直接写到那里去。对于短小的代码来说，inline可以带来一定的效率提升，而且和C时代的宏函数相比，inline 更安全可靠。可是这个是以增加空间消耗为代价的。至于是否需要inline函数就需要根据你的实际情况取舍了, 频繁的调用内联函数和宏定义容易造成代码膨胀，消耗更大的内存而<strong>造成过多的换页操作</strong>。</p>
<p>inline一般只用于如下情况：</p>
<ol>
<li>一个函数不断被重复调用。</li>
<li>函数只有简单的几行，且函数不包含for、while、switch语句等复杂结构, 否则编译器不会将其当作内联函数看待，而是把它决议成为一个静态函数.<br>宏不是函数，只是在编译预处理阶段将程序中有关字符串替换成宏体。<br>inline函数是函数，但在编译中不单独产生代码，而是将有关代码嵌入到调用处。<br>关于类的例子如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Class A</div><div class="line">&#123;</div><div class="line">public：</div><div class="line">    int readTest（）</div><div class="line">    &#123;</div><div class="line">        return nTest；</div><div class="line">    &#125;</div><div class="line">    void setTest（int i);</div><div class="line">&#125;;</div><div class="line">inline void A::setTest(int i)</div><div class="line">&#123;</div><div class="line">    nTest=i;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>类A的成员函数readTest（）和setTest（）都是内联函数，readTest（）函数的定义体被放在类声明之中，因而 readTest（）自动转换成inline函数，setTest函数的定义体在类声明之外，因此要加上inline关键字。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/05/05/喂饱GPU：多线程加载图像数据/">
                喂饱GPU：多线程加载图像数据
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-05-05</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>在训练卷积神经网络时，为了充分利用GPU的计算能力，让GPU充分运转，减少GPU等待批次（batch）数据的时间，需要进行图像数据加载的并行编程。可以进行多进程或者多线程编程，需要注意的是，由于 Python GIL 的存在，基于多线程的并行编程仅适用于 I/O 密集型的并发，并不适用于 CPU 计算密集型的并发。因此，如果图像数据加载（I/O密集型）后，需要进行图像数据的预处理（CPU 计算密集型），推荐使用多进程编程，关于多进程编程我后续会写一篇博客进行介绍，本文主要介绍我在使用使用多线程加载图像数据时遇到的一些知识点，主要包括：</p>
<ul>
<li>加锁：关键代码区访问控制</li>
<li>双重锁验证</li>
<li>长时代码移出关键代码区</li>
</ul>
<p>另外如果想了解关于线程之间通信的相关知识，可以查看我的另一篇博文<a href="https://robertlexis.github.io/2017/11/05/Python-threads-communication-and-stopping/" target="_blank" rel="external">Python threads: communication and stopping</a>。</p>
<h3 id="加锁，关键代码区访问控制"><a href="#加锁，关键代码区访问控制" class="headerlink" title="加锁，关键代码区访问控制"></a>加锁，关键代码区访问控制</h3><p>利用锁划定关键代码区，使得同一时刻只能有一个线程在执行该关键代码区的代码，之所以要进行如此的访问控制，是因为在多线程中，“全局”变量是由线程共享的，进行访问控制可以防止多个线程同时修改同一个“全局”变量造成变量的值的错乱。</p>
<p>在 Python 中利用锁划定关键代码区有两种方式，<strong>手动方式</strong>和<strong>上下文管理器方式</strong>，无论使用哪种方式，都要求即使在关键代码区的代码发生异常时，依然可以正常的释放锁，不然该异常线程一直持有锁会导致其他线程一直处于等待锁被释放的状态，不能正常的处理工作和退出。</p>
<p>手动方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">lock = threading.Lock()</div><div class="line">def thread_function():</div><div class="line">    ...</div><div class="line">    lock.acquire()</div><div class="line">    ~~~~~~~~~~~~~~~~~~~~~~ begin of critical code region</div><div class="line">    try:</div><div class="line">        ...</div><div class="line">    finally:</div><div class="line">    ~~~~~~~~~~~~~~~~~~~~~~ end of critical code region</div><div class="line">        lock.release()</div><div class="line">    ...</div></pre></td></tr></table></figure></p>
<p>上下文管理器方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">lock = threading.Lock()</div><div class="line">def thread_function():</div><div class="line">    ...</div><div class="line">    with lock：</div><div class="line">        ~~~~~~~~~~~~~~~~~~~~~~ begin of critical code region</div><div class="line">        ...</div><div class="line">        ~~~~~~~~~~~~~~~~~~~~~~ end of critical code region</div><div class="line">    ...</div></pre></td></tr></table></figure></p>
<p>上下文管理器方式的方式可以自动在异常时释放锁，并且代码结构上也更加简洁清晰，是推荐的划定关键代码区的方式。</p>
<h3 id="双重锁验证"><a href="#双重锁验证" class="headerlink" title="双重锁验证"></a>双重锁验证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">import numpy as np</div><div class="line">from skimage import io</div><div class="line">import os</div><div class="line"></div><div class="line">directory = &quot;images/&quot;</div><div class="line">filenames = [name for name in os.listdir(directory)]</div><div class="line">num_images = len(filenames)</div><div class="line"></div><div class="line">images = np.empty((num_images, 256, 256, 3))</div><div class="line">current_image_index = 0</div><div class="line">lock = threading.Lock()</div><div class="line"></div><div class="line">def load_images(directory):</div><div class="line">    global current_image_index</div><div class="line">    global images</div><div class="line">    while current_image_index &lt; num_images: # 第一次验证</div><div class="line">        with lock:</div><div class="line">            if current_image_index &lt; num_images: # 第二次验证</div><div class="line">                image = io.imread(os.path.join(directory, filenames[current_image_index]))</div><div class="line">                images[current_image_index] = image</div><div class="line">                current_image_index += 1</div><div class="line">num_threads = 4</div><div class="line">threads = []</div><div class="line">for i in range(num_threads):</div><div class="line">    t = threading.Thread(target=load_images, args=(directory, ))</div><div class="line">    threads.append(t)</div><div class="line"></div><div class="line"># Fire all threads up</div><div class="line">for t in threads:</div><div class="line">    t.start()</div><div class="line"></div><div class="line"># wait for all threads</div><div class="line">for t in threads:</div><div class="line">    t.join()</div></pre></td></tr></table></figure>
<p>上面的代码起了4个线程，它们分别根据全局变量 <code>current_image_index</code> 的指示加载图像并将图像数据赋给全局变量 <code>images</code>。<br>第一次验证控制循环的退出和线程的退出，只要 <code>current_image_index</code> 小于 <code>num_images</code>，说明目录中尚有图像未被加载，需要进入循环继续加载。进入循环之后首先请求锁构建关键代码区，因为我们要对共享全局变量进行修改了，而这必须发生在关键代码区。如果线程获得锁，就进入关键代码区执行；如果当前有其他线程持有锁，该线程就“堵塞”在此处直到其他线程释放锁并且该线程获得锁，才进入关键代码区。</p>
<p>进入关键代码区之后，我们进行了第二次验证，这是因为线程在等待获得锁的过程中流逝了一段时间，可能有其他线程加载了一些图像并修改了 <code>current_image_index</code> 的值，导致目录中的图像文件被加载完并设置 <code>current_image_index</code> 等于了 <code>num_images</code>，因此在进行加载之前需要再次进行验证，仅在 <code>current_image_index</code> 小于 <code>num_images</code> 时才进行加载，否则就会发生filenames 列表的访问越界错误。</p>
<h3 id="长时代码移出关键代码区"><a href="#长时代码移出关键代码区" class="headerlink" title="长时代码移出关键代码区"></a>长时代码移出关键代码区</h3><p>上一部分中的代码实际上是“伪”多线程，我们是起了 4 个线程，但是难道这 4 个线程真的是在并行地处理各自的工作吗？<br><code>image = io.imread(os.path.join(directory, filenames[current_image_index]))</code> 这一行是每一个线程的主要功能代码，也是耗时较长的部分（涉及到 I/O 操作，虽然没有太多的指令，即不是 CPU 密集型，但是却是耗时较长的部分），它被放到了关键代码区！！这意味着这实际上是在“单线程”执行着的，因为在关键代码区实际上由于锁的控制使得同一时刻只能有一个线程进入关键代码区。</p>
<p>我们要做就是要把长时代码移出关键代码区，从而实现“真”多线程。</p>
<p>这里需要记住的一点就是：关键代码区的代码运行时间要短，这是因为在关键代码区实际上由于锁的控制使得同一时刻只能有一个线程进入关键代码区，即“单线程模式”，为了减少其他线程的等待时间，提高“并行模式”运行时间 vs “单线程模式”运行时间的比例。做到这一点，就要求在关键代码区中仅进行全局共享变量的修改，而将长时代码移出关键代码区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">import numpy as np</div><div class="line">from skimage import io</div><div class="line">import os</div><div class="line"></div><div class="line">directory = &quot;images/&quot;</div><div class="line">filenames = [name for name in os.listdir(directory)]</div><div class="line">num_images = len(filenames)</div><div class="line"></div><div class="line">images = np.empty((num_images, 256, 256, 3))</div><div class="line">current_image_index = 0</div><div class="line">lock = threading.Lock()</div><div class="line"></div><div class="line">def load_images(directory):</div><div class="line">    global current_image_index</div><div class="line">    global images</div><div class="line">    while current_image_index &lt; num_images: # 第一次验证</div><div class="line">        with lock:</div><div class="line">            if current_image_index &lt; num_images: # 第二次验证</div><div class="line">                index = current_image_index</div><div class="line">                current_image_index += 1</div><div class="line">            else:</div><div class="line">                break</div><div class="line"></div><div class="line">        image = io.imread(os.path.join(directory, filenames[index]))</div><div class="line"></div><div class="line">        with lock:</div><div class="line">            images[index] = image</div><div class="line"></div><div class="line">num_threads = 4</div><div class="line">threads = []</div><div class="line">for i in range(num_threads):</div><div class="line">    t = threading.Thread(target=load_images, args=(directory, ))</div><div class="line">    threads.append(t)</div><div class="line"></div><div class="line"># Fire all threads up</div><div class="line">for t in threads:</div><div class="line">    t.start()</div><div class="line"></div><div class="line"># wait for all threads</div><div class="line">for t in threads:</div><div class="line">    t.join()</div></pre></td></tr></table></figure></p>
<p>上面的代码通过将一个关键代码区分成两个关键代码区，将图像文件打开代码移出了关键代码区，并使用线程局部变量 <code>index</code> 来标识该线程当前要加载的图像。通过实验可以发现，整个程序的运行时间减少了。</p>
<h3 id="实验对比"><a href="#实验对比" class="headerlink" title="实验对比"></a>实验对比</h3><p><img src="http://oytnj8g2y.bkt.clouddn.com/python/concurrency/compare.png" alt="compare"><br>“真”多线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">import time</div><div class="line"></div><div class="line"></div><div class="line">num_iterations = 100</div><div class="line"></div><div class="line">current_iteration = 0</div><div class="line"></div><div class="line">lock = threading.Lock()</div><div class="line"></div><div class="line">def thread_function():</div><div class="line">    global current_iteration</div><div class="line">    while current_iteration &lt; num_iterations: # 第一次验证</div><div class="line">        with lock:</div><div class="line">            if current_iteration &lt; num_iterations: # 第二次验证</div><div class="line">                iteration = current_iteration</div><div class="line">                current_iteration += 1</div><div class="line">            else:</div><div class="line">                break</div><div class="line"></div><div class="line">        # using iteration</div><div class="line">        # Long running time code </div><div class="line">        time.sleep(0.1)</div><div class="line"></div><div class="line">        with lock:</div><div class="line">            pass</div><div class="line"></div><div class="line">num_threads = 4</div><div class="line">threads = []</div><div class="line">for i in range(num_threads):</div><div class="line">    t = threading.Thread(target=thread_function)</div><div class="line">    threads.append(t)</div><div class="line"></div><div class="line">tic = time.time()</div><div class="line"># Fire all threads up</div><div class="line">for t in threads:</div><div class="line">    t.start()</div><div class="line"></div><div class="line"># wait for all threads</div><div class="line">for t in threads:</div><div class="line">    t.join()</div><div class="line">toc = time.time()</div><div class="line">print(&quot;Time elapsed %.2f&quot; % (toc - tic))</div></pre></td></tr></table></figure></p>
<p>“伪”多线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">import time</div><div class="line"></div><div class="line"></div><div class="line">num_iterations = 100</div><div class="line"></div><div class="line">current_iteration = 0</div><div class="line"></div><div class="line">lock = threading.Lock()</div><div class="line"></div><div class="line">def thread_function():</div><div class="line">    global current_iteration</div><div class="line">    while current_iteration &lt; num_iterations: # 第一次验证</div><div class="line">        with lock:</div><div class="line">            if current_iteration &lt; num_iterations: # 第二次验证</div><div class="line">                iteration = current_iteration</div><div class="line">                current_iteration += 1</div><div class="line">                # using iteration</div><div class="line">                # Long running time code </div><div class="line">                time.sleep(0.1)</div><div class="line"></div><div class="line">num_threads = 4</div><div class="line">threads = []</div><div class="line">for i in range(num_threads):</div><div class="line">    t = threading.Thread(target=thread_function)</div><div class="line">    threads.append(t)</div><div class="line"></div><div class="line">tic = time.time()</div><div class="line"># Fire all threads up</div><div class="line">for t in threads:</div><div class="line">    t.start()</div><div class="line"></div><div class="line"># wait for all threads</div><div class="line">for t in threads:</div><div class="line">    t.join()</div><div class="line">toc = time.time()</div><div class="line">print(&quot;Time elapsed %.2f&quot; % (toc - tic))</div></pre></td></tr></table></figure></p>
<p>单线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import time</div><div class="line"></div><div class="line"></div><div class="line">num_iterations = 100</div><div class="line"></div><div class="line">tic = time.time()</div><div class="line"></div><div class="line">for iteration in range(num_iterations):</div><div class="line">    # using iteration</div><div class="line">    # Long running time code </div><div class="line">    time.sleep(0.1)</div><div class="line"></div><div class="line">toc = time.time()</div><div class="line">print(&quot;Time elapsed %.2f&quot; % (toc - tic))</div></pre></td></tr></table></figure></p>
<p>相关的代码放置在我的 GitHub <a href="https://github.com/RobertLexis/python_concurrency" target="_blank" rel="external">仓库</a>中。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/04/12/Loss-functions-推导及理解/">
                Loss functions 推导及理解
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-04-12</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>本博文主要是在学习 <a href="http://cs231n.stanford.edu/2017/" target="_blank" rel="external">CS231n: Convolutional Neural Networks for Visual Recognition Spring 2017</a> Lecture 3: Loss Functions and Optimization 之后的总结。</p>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><img src="" alt="problem"><br>Suppose: 3 training examples, 3 classes. With some \(W\) the scores \( f(x, W) = Wx\) are:<br>损失函数告诉我们目前模型性能的好坏（A loss function tells how<br>good our current classifier is）。<br>Loss function takes in the \(W\), looks at the scores, then tell us how bad quantitatively the \(W\) is.<br>Optimizer comes up a procedure for searching through the space of all possible \(Ws\) to get the least bad W.<br>给定数据集 \(\lbrace (x_i, y_i) \rbrace_{i=1}^N\)，其中 \(x_i\) 是图片，\(y_i\) 是一个整数标签，在整个数据集上损失是：<br>$$<br>L = \frac{1}{N} \sum_i L_i(f(x_i, W), y_i)<br>$$</p>
<h3 id="Multiclass-SVM-loss"><a href="#Multiclass-SVM-loss" class="headerlink" title="Multiclass SVM loss"></a>Multiclass SVM loss</h3><p>$$<br>\begin{split}<br>L_i &amp; = \sum_{j \not= y_i} \begin{cases}<br>    0 &amp; s_{y_i} &gt; s_j + 1 \\\<br>    s_j - s_{y_i} + 1 &amp; otherwise<br>    \end{cases} \\\<br>    &amp; = \sum_{j \not= y_i} max(0, s_j - s_{y_i} + 1)<br>\end{split}<br>$$</p>
<p>对一个样本\(i\)而言，我们可以得到其在各个类别上的 score，如上图所示，<br>仅在不是真实标签类别\(y_i\)的其他类别上\(j\)上计算损失，仅当其他类别上的 score \(s_j\) 加上一个 safety margin值之后还小于真实类别上的 score \(s_{y_i}\)时，损失才为0。即不仅仅要求真实类别score \(s_{y_i}\) 大于其他类别score \(s_j}\)，而且更进一步要求优化器使得前者大于后者加上一个safety margin。<br>在 otherwise 分支，\(s_j\) 比 \(s_{y_i}\) 大的值再加上safety margin就是损失值。<br>$$<br>HingeLoss_{i, j} = max(0, s_j - s_{y_i} + 1)<br>$$<br>作为 \(s_{y_i}\) 的函数斜率为 -1，必过点 \((s_j + 1, 0)\)。<br><img src="" alt="hinge_loss"></p>
<p><img src="" alt="losses"><br>$$<br>L = (2.9 + 0 + 12.9) / 3 = 5.27<br>$$</p>
<h5 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h5><ul>
<li>What happens to loss if car scores change a bit ?<br>  The loss will not change.<br>  这说明 SVM loss 关心的仅仅是让真实标签类别的 score 比其他类别的 score 大 1。</li>
<li>what is the min/max possible loss?<br>  0/infinity</li>
<li>At initialization W is small so all s ≈ 0. What is the loss?<br>  number of classes minus one<br>  这一点在 debug 时是很有用的。在我们尚未进行训练之前，我们可以思考一下此时的预期损失。</li>
<li>What if the sum was over all classes (including \(j = y_i\))?<br>  The loss will increase exactly by one.训练结果不会变，会获得同一个的分类器。但是损失的最小值不再是 0，而是1。</li>
<li>What if we used mean instead of sum?<br>  Just rescale the whole loss function by a constant (number of classes minus one). 训练结果不会变，会获得同一个的分类器。</li>
<li>What if we used \( L_i = \sum_{j \not= y_i} max(0, s_j - s_{y_i} + 1)^2 \) ?<br>  现在我们有了一个完全不同的 loss function，squared hinge loss，<strong>不同损失函数对分类器犯下的不同错误的关注点不一样，也就是说，分类器会犯下不同错误，不同的损失函数对这些不同错误的关注程度不一致。</strong> hinge loss 不在乎 score 的错误程度是很错误还是一般错误，而 squared hinge loss 会着重关注那些偏得离谱的错误，因为他们的 wrong 会变成 squared wrong。对于 hinge loss 来说，同等看待，让一个很错误的样本预测结果变得不太错误了，和让一个不太错误的样本预测结果变得更加不太错误，比如，\(4-&gt;3\) 与 \(3-&gt;2\)，而对于 squared hinge loss 来说，<br>  (16-&gt;9) 要比 \(9-&gt;4\) loss 降低幅度要大，但是分类的 accuracy 并没有变化。</li>
</ul>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/04/01/C-多态/">
                C++多态
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-04-01</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="C-多态的实现？"><a href="#C-多态的实现？" class="headerlink" title="C++多态的实现？"></a>C++多态的实现？</h3><p>多态性可以简单地概括为“一个接口，多种实现”，程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。<br>C++多态性是通过虚函数来实现的，重写虚函数。<br>多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译时就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。<br>封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。<br>最常见的用法就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同类型而调用不同的方法。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是一定的，而固定的地址将始终调用到同一个函数，这就无法实现一个接口，多种实现的目的了。</p>
<h3 id="虚函数的作用？"><a href="#虚函数的作用？" class="headerlink" title="虚函数的作用？"></a>虚函数的作用？</h3><p>虚函数用于实现多态，这点大家都能答上来但是虚函数在设计上还具有封装和抽象的作用。比如抽象工厂模式。<br>每个虚函数都有一个虚函数列表，根据指向对象的类型不同，函数地址也将不同。</p>
<h3 id="virtual-的语义就是强制派生类重写该函数。"><a href="#virtual-的语义就是强制派生类重写该函数。" class="headerlink" title="virtual 的语义就是强制派生类重写该函数。"></a>virtual 的语义就是强制派生类重写该函数。</h3><h3 id="C-纯虚函数"><a href="#C-纯虚函数" class="headerlink" title="C++纯虚函数"></a>C++纯虚函数</h3><p>引入原因：在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。含有纯虚拟函数的类称为抽象类，它不能生成对象。<br>多态性：指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。 </p>
<ul>
<li>编译时多态性：通过重载函数实现</li>
<li>运行时多态性：通过虚函数实现<br>静态多态和动态多态。静态多态是指通过模板技术或者函数重载技术实现的多态，其在编译期确定行为。动态多态是指通过虚函数技术实现在运行期动态绑定的技术。</li>
</ul>
<h3 id="动态绑定的实现"><a href="#动态绑定的实现" class="headerlink" title="动态绑定的实现"></a>动态绑定的实现</h3><ol>
<li>为每一个包含虚函数的类设置一个虚表（VTABLE）<br>每当创建一个包含有虚函数的类或从包含虚函数的类派生一个类时，编译器就会为这个类创建一个 VTABLE。在 VTABLE 中，编译器放置了这个类中，或者它的基类中所有已经声明为 virtual 的函数的地址。如果在这个派生类中没有对基类中声明为 virtual 的函数进行重新定义，编译器就使用基类的这个虚函数的地址。<strong>而且所有 VTABLE 中虚函数地址的顺序是完全相同的。</strong></li>
<li>初始化虚指针（VPTR）<br>编译器在这个类的<strong>每个对象</strong>中放置 VPTR。VPTR 在对象的相同的位置（通常都在对象的开头）。VPTR 必须被初始化为指向相应的 VTABLE。</li>
<li>为虚函数调用插入代码<br>当通过基类的指针调用派生类的虚函数时，编译器将在调用处插入相应的代码，以实现通过 VPTR 找到 VTABLE，并根据 VTABLE 中存储的正确的虚函数地址，访问到正确的函数。</li>
</ol>
<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p>C++ 中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。<br>C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。这意味着我们可以通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。<br>假设我们有这样的一个类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">class Base</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Base()&#123;&#125;;</div><div class="line">    ~Base()&#123;&#125;;</div><div class="line">    virtual void f() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    virtual void g() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    virtual void h() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl;</div><div class="line">    &#125;      </div><div class="line">&#125;;</div><div class="line">typedef void(*Func)(void);</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;   </div><div class="line">    Base b;</div><div class="line">    Func fp = nullptr, gp = nullptr, hp = nullptr;</div><div class="line">    // 打印值一样，值是一样的，但是这个值的意义是不一样的，分别指向32bit空间，整个对象空间，64bit空间，</div><div class="line">    // 这在解引用时就会出现本质的差异。</div><div class="line">    cout &lt;&lt; &quot;虚函数表地址：&quot; &lt;&lt; (int*)(&amp;b) &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; &quot;虚函数表地址：&quot; &lt;&lt; &amp;b &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; &quot;虚函数表地址：&quot; &lt;&lt; (long long*)(&amp;b) &lt;&lt; endl;</div><div class="line">    // 下面这一行会报错，是因为这台机器是64位的，*(int*)(&amp;b) 是一个整型，空间只有32位，</div><div class="line">    // 在强制将其cast成64位地址时，就会报出 cast to pointer from integer of different size [-Wint-to-pointer-cast]</div><div class="line">    // cout &lt;&lt; &quot;虚函数表 — 第一个函数地址：&quot; &lt;&lt; (int*)*(int*)(&amp;b) &lt;&lt; endl;</div><div class="line">    // 当将 int 改成 long long 时就好了，如此将一个 long long 转换成指针（无论是何种类型的指针，此处是整型指针）。</div><div class="line">    // 在64位机器上用 long long*  cast 指针是安全的，而用 int* 则是不安全的。</div><div class="line">    cout &lt;&lt; &quot;虚函数表 — 第一个函数地址：&quot; &lt;&lt; (int*)*(long long*)(&amp;b) &lt;&lt; endl;</div><div class="line">    // Invoke the first virtual function </div><div class="line">    fp = (Func)*((long long*)*(long long*)(&amp;b));</div><div class="line">    fp();</div><div class="line">    gp = (Func)*((long long*)*(long long*)(&amp;b) + 1);</div><div class="line">    gp();</div><div class="line">    hp = (Func)*((long long*)*(long long*)(&amp;b) + 2);</div><div class="line">    hp();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“/0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。</p>
<p>下面将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。</p>
<h4 id="一般继承（无虚函数覆盖）"><a href="#一般继承（无虚函数覆盖）" class="headerlink" title="一般继承（无虚函数覆盖）"></a>一般继承（无虚函数覆盖）</h4><p><img src="http://oytnj8g2y.bkt.clouddn.com/vtable0.JPG" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">class Base</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Base()&#123;&#125;;</div><div class="line">    ~Base()&#123;&#125;;</div><div class="line">    virtual void f() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    virtual void g() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    virtual void h() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl;</div><div class="line">    &#125;      </div><div class="line">&#125;;</div><div class="line">class Derive : public Base</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Derive()&#123;&#125;;</div><div class="line">    ~Derive()&#123;&#125;;</div><div class="line">    virtual void f1() &#123;</div><div class="line">        cout &lt;&lt; &quot;Derive::f1&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    virtual void g1() &#123;</div><div class="line">        cout &lt;&lt; &quot;Derive::g1&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    virtual void h1() &#123;</div><div class="line">        cout &lt;&lt; &quot;Derive::h1&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;;</div><div class="line">typedef void(*Func)(void);</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;   </div><div class="line"></div><div class="line">    Derive d;</div><div class="line">    Func fp = nullptr, gp = nullptr, hp = nullptr;</div><div class="line">    fp = (Func)*((long long*)*(long long*)(&amp;d));</div><div class="line">    fp();</div><div class="line">    gp = (Func)*((long long*)*(long long*)(&amp;d) + 1);</div><div class="line">    gp();</div><div class="line">    hp = (Func)*((long long*)*(long long*)(&amp;d) + 2);</div><div class="line">    hp();</div><div class="line"></div><div class="line">    Func f1p = nullptr, g1p = nullptr, h1p = nullptr;</div><div class="line">    f1p = (Func)*((long long*)*(long long*)(&amp;d) + 3);</div><div class="line">    f1p();</div><div class="line">    g1p = (Func)*((long long*)*(long long*)(&amp;d) + 4);</div><div class="line">    g1p();</div><div class="line">    h1p = (Func)*((long long*)*(long long*)(&amp;d) + 5);</div><div class="line">    h1p();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Base::f</div><div class="line">Base::g</div><div class="line">Base::h</div><div class="line">Derive::f1</div><div class="line">Derive::g1</div><div class="line">Derive::h1</div></pre></td></tr></table></figure>
<p><img src="http://oytnj8g2y.bkt.clouddn.com/vtable1.JPG" alt=""><br>我们可以看到下面几点：</p>
<ol>
<li>虚函数按照其声明顺序放于表中。</li>
<li>父类的虚函数在子类的虚函数前面。<h4 id="一般继承（有虚函数覆盖）"><a href="#一般继承（有虚函数覆盖）" class="headerlink" title="一般继承（有虚函数覆盖）"></a>一般继承（有虚函数覆盖）</h4>覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。<br><img src="http://oytnj8g2y.bkt.clouddn.com/vtable2.JPG" alt=""><br>为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子：<br><img src="http://oytnj8g2y.bkt.clouddn.com/vtable3.JPG" alt=""><br>我们从表中可以看到下面几点，</li>
<li>覆盖的f()函数被放到了虚表中原来父类虚函数的位置。</li>
<li>没有被覆盖的函数依旧。<br>这样，我们就可以看到对于下面这样的程序，<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Base *b = new Derive();</div><div class="line">b-&gt;f();</div></pre></td></tr></table></figure>
</li>
</ol>
<p>由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。</p>
<h4 id="多重继承（无虚函数覆盖）"><a href="#多重继承（无虚函数覆盖）" class="headerlink" title="多重继承（无虚函数覆盖）"></a>多重继承（无虚函数覆盖）</h4><p>下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。<br><img src="http://oytnj8g2y.bkt.clouddn.com/vtable4.JPG" alt=""><br>对于子类实例中的虚函数表，是下面这个样子：<br><img src="http://oytnj8g2y.bkt.clouddn.com/vtable5.JPG" alt=""><br>我们可以看到：</p>
<ol>
<li>每个父类都有自己的虚表。</li>
<li>子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）</li>
</ol>
<p>这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。</p>
<h4 id="多重继承（有虚函数覆盖）"><a href="#多重继承（有虚函数覆盖）" class="headerlink" title="多重继承（有虚函数覆盖）"></a>多重继承（有虚函数覆盖）</h4><p>下面我们再来看看，如果发生虚函数覆盖的情况。<br>下图中，我们在子类中覆盖了父类的f()函数。<br><img src="http://oytnj8g2y.bkt.clouddn.com/vtable6.JPG" alt=""><br>下面是对于子类实例中的虚函数表的图：<br><img src="http://oytnj8g2y.bkt.clouddn.com/vtable7.JPG" alt=""><br>我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Derive d;</div><div class="line">Base1 *b1 = &amp;d;</div><div class="line">Base2 *b2 = &amp;d;</div><div class="line">Base3 *b3 = &amp;d;</div><div class="line">b1-&gt;f(); //Derive::f()</div><div class="line">b2-&gt;f(); //Derive::f()</div><div class="line">b3-&gt;f(); //Derive::f()</div><div class="line">b1-&gt;g(); //Base1::g()</div><div class="line">b2-&gt;g(); //Base2::g()</div><div class="line">b3-&gt;g(); //Base3::g()</div></pre></td></tr></table></figure></p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>每次写C++的文章，总免不了要批判一下C++。这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。</p>
<ol>
<li>通过父类型的指针访问子类自己的虚函数</li>
</ol>
<p>我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的<strong>自有虚函数</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Base1 *b1 = new Derive();</div><div class="line">b1-&gt;f1();  //编译出错</div></pre></td></tr></table></figure></p>
<p>任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。</p>
<ol>
<li>访问 non-public 的虚函数<br>另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">class Base</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Base()&#123;&#125;;</div><div class="line">    ~Base()&#123;&#125;;</div><div class="line">    virtual void f() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl;</div><div class="line">    &#125;;</div><div class="line">private:</div><div class="line">    virtual void h() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line">class Derive: public Base</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Derive()&#123;&#125;;</div><div class="line">    ~Derive()&#123;&#125;;</div><div class="line">    virtual void f() &#123;</div><div class="line">        cout &lt;&lt; &quot;Derive::f&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    virtual void g() &#123;</div><div class="line">        cout &lt;&lt; &quot;Derive::g&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">typedef void(*Func)(void);</div><div class="line"></div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    Base* ptr = new Derive;</div><div class="line">    ptr-&gt;f();</div><div class="line">    // ptr-&gt;g();</div><div class="line">    Func func_ptr = nullptr;</div><div class="line">    func_ptr = (Func)*((long long*)*(long long*)ptr + 1); </div><div class="line">    func_ptr();</div><div class="line">    func_ptr = (Func)*((long long*)*(long long*)ptr + 2); </div><div class="line">    func_ptr();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Derive::f</div><div class="line">Base::h</div><div class="line">Derive::g</div></pre></td></tr></table></figure>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/03/25/STL-内存池实现/">
                STL 内存池实现
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-03-25</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="STL-里的内存池实现"><a href="#STL-里的内存池实现" class="headerlink" title="STL 里的内存池实现"></a>STL 里的内存池实现</h3><h4 id="内存池的目的是什么？"><a href="#内存池的目的是什么？" class="headerlink" title="内存池的目的是什么？"></a>内存池的目的是什么？</h4><ol>
<li>通过 new 表达式动态分配一个对象时，会调用 operator new 进行内存分配，这一步是直接和操作系统打交道的, 操作系统可能需要经过相对繁琐的过程才能将一块指向空闲内存的指针返回给用户, 所以这也是 new 比较耗时的一部分, 而第二步就是使用构造函数进行初始化。既然内存分配耗时, 那我们很容易想到的就是一次性分配一大块内存, 然后在用户需要的时候再划分其中一部分给用户, 这样的话, 一次分配, 多次使用, 自然而然提高了效率, 而用来管理这所谓的一大块内存的内存结构, 也就是今天我们要说的内存池。</li>
<li>内存池带来的另外一个好处在于，频繁地使用new将导致系统内存空间碎片化严重， 容易导致的后果就是很难找到一块连续的大块内存, 空间利用率低，而内存池是一次性分配一大块内存空间，就缓解了内存碎片的问题。</li>
</ol>
<h4 id="一、STL中的内存管理"><a href="#一、STL中的内存管理" class="headerlink" title="一、STL中的内存管理"></a>一、STL中的内存管理</h4><p>当我们 new 一个对象时：</p>
<ol>
<li>使用 operator new 申请了一块内存。</li>
<li>执行构造函数。<br>在SGI中，这两步独立出了两个函数：allocate申请内存，construct调用构造函数。这两个函数分别在<code>&lt;stl_alloc.h&gt;</code>和<code>&lt;stl_construct.h&gt;</code>中。<br><img src="http://oytnj8g2y.bkt.clouddn.com/1.jfif" alt=""></li>
</ol>
<h4 id="二、第一级配置器"><a href="#二、第一级配置器" class="headerlink" title="二、第一级配置器"></a>二、第一级配置器</h4><p>第一级配置器以 malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。</p>
<h4 id="三、第二级配置器"><a href="#三、第二级配置器" class="headerlink" title="三、第二级配置器"></a>三、第二级配置器</h4><p>第二级配置器维护着16个空闲链表（free list），各自管理大小分别为8、16、24、32、40、48、56、64、72、80、88、96、104、112、120、128 bytes的小内存块。<br>如果要分配的内存大于 128bytes，则移交给第一级配置器处理，直接用malloc。<br>如果要分配的内存小于 128bytes，则以内存池管理（memory pool），使用第二级配置器，找出适合的空闲链表, 从其上摘下一个节点将其头指针返回给用户，这就完成了对用户的内存分配。<br>释放过程则正好与分配相对应，如果用户分配的内存大于128bytes，直接用free，否则找出适当的空闲链表， 将指针所指的该段内存重新连接到空闲链表中(注意此时并不把内存返回给操作系统, 如此可以重复利用)。 </p>
<h5 id="1-空闲链表（free-list）的设计"><a href="#1-空闲链表（free-list）的设计" class="headerlink" title="1. 空闲链表（free list）的设计"></a>1. 空闲链表（free list）的设计</h5><p>空闲链表节点的设计十分巧妙，用了一个联合体既可以记录下一个空闲内存块（存在于空闲链表中）的地址，也可以给出分配给用户使用内存块的地址。<br><img src="http://oytnj8g2y.bkt.clouddn.com/2.jfif" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">template &lt;bool threads, int inst&gt;  </div><div class="line">class __default_alloc_template  </div><div class="line">&#123;  </div><div class="line">private:  </div><div class="line">    //将bytes上调至8的倍数  </div><div class="line">    static size_t ROUND_UP(size_t bytes)  </div><div class="line">    &#123;  </div><div class="line">        return (((bytes) + __ALIGN - 1) &amp; ~(__ALIGN - 1));//等价于(bytes + 7) / 8  </div><div class="line">    &#125;  </div><div class="line">    //空闲链表的节点构造 </div><div class="line">    union obj  </div><div class="line">    &#123;  </div><div class="line">        union obj * free_list_link;  </div><div class="line">        char client_data[1];  </div><div class="line">    &#125;;  </div><div class="line">private:  </div><div class="line">    //16个空闲链表，初始化为0，即每个链表中都没有空闲内存块  </div><div class="line">    static obj * volatile free_list[__NFREELISTS];  </div><div class="line">    //根据申请内存块的大小找到相应空闲链表的下标  </div><div class="line">    static  size_t FREELIST_INDEX(size_t bytes)  </div><div class="line">    &#123;  </div><div class="line">        return (((bytes) + __ALIGN - 1)/__ALIGN - 1);  </div><div class="line">    &#125;  </div><div class="line">    ......  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="2-从空闲列表中取内存块"><a href="#2-从空闲列表中取内存块" class="headerlink" title="2. 从空闲列表中取内存块"></a>2. 从空闲列表中取内存块</h5><p>首先先要检查申请空间的大小，如果大于128字节就调用第一级配置器，小于128字节就检查对应的空闲链表，如果该空闲链表中有可用内存块，则直接拿来用（拿取空闲链表中的第一个可用内存块，然后把该空闲链表的地址设置为该内存块指向的下一个地址），如果没有可用内存块，则调用 refill 为该空闲链表填充新的空间。<br><img src="http://oytnj8g2y.bkt.clouddn.com/3.jfif" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//申请大小为 n 的内存块，返回该内存块的起始地址</div><div class="line">static void * allocate(size_t n)  </div><div class="line">&#123;  </div><div class="line">    obj * __VOLATILE * my_free_list;  </div><div class="line">    obj * __RESTRICT result;  </div><div class="line">  </div><div class="line">    if (n &gt; (size_t) __MAX_BYTES)//大于128字节调用第一级配置器  </div><div class="line">    &#123;  </div><div class="line">        return(malloc_alloc::allocate(n));  </div><div class="line">    &#125;  </div><div class="line">    my_free_list = free_list + FREELIST_INDEX(n);//根据申请空间的大小寻找相应的空闲链表（16个空闲链表中的一个）  </div><div class="line">  </div><div class="line">    result = *my_free_list;  </div><div class="line">    if (result == 0)//如果该空闲链表没有空闲的内存块</div><div class="line">    &#123;  </div><div class="line">        void *r = refill(ROUND_UP(n));//为该空闲链表填充新的空间  </div><div class="line">        return r;  </div><div class="line">    &#125;  </div><div class="line">    *my_free_list = result -&gt; free_list_link;//如果空闲链表中有空闲内存块，则取出一个，并把空闲链表的指针指向下一个内存块</div><div class="line">    return (result);  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h5 id="3-从内存池取空间，重新填充空闲链表"><a href="#3-从内存池取空间，重新填充空闲链表" class="headerlink" title="3. 从内存池取空间，重新填充空闲链表"></a>3. 从内存池取空间，重新填充空闲链表</h5><p>在用 allocate 配置空间时，如果空闲链表中没有可用内存块，就会调用refill来为该空闲链表填充新的空间，新的空间取自内存池。缺省取20个内存块，如果内存池空间不足，那么能取多少个节点就取多少个。<br>这里有两种情况会导致没有可用的内存块, 第一种是用光了, 第二种是这是该内存池初始化以来第一次使用这个大小的空闲链表, 所以还未为空闲链表分配过空间。<br><img src="http://oytnj8g2y.bkt.clouddn.com/5.jfif" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">template &lt;bool threads, int inst&gt;  </div><div class="line">void* refill(size_t n)  </div><div class="line">&#123;  </div><div class="line">    int nobjs = 20;  </div><div class="line">    //从内存池里取出nobjs个大小为n的内存块,返回值nobjs为真实申请到的内存块个数，注意这里nobjs个大小为n的内存块所在的空间是连续的</div><div class="line">    char * chunk = chunk_alloc(n, nobjs);</div><div class="line">    obj * __VOLATILE * my_free_list;  </div><div class="line">    obj * result;  </div><div class="line">    obj * current_obj, * next_obj;  </div><div class="line">    int i;  </div><div class="line">  </div><div class="line">    if (1 == nobjs) return(chunk);//如果只获得一个内存块，那么这个内存块就直接分给调用者，空闲链表中不会增加新节点  </div><div class="line">    my_free_list = free_list + FREELIST_INDEX(n);//否则根据申请内存块的大小找到相应空闲链表  </div><div class="line">  </div><div class="line">    result = (obj *)chunk;  </div><div class="line">    *my_free_list = next_obj = (obj *)(chunk + n);//第0个内存块给调用者，地址访问即chunk~chunk + n - 1  </div><div class="line">    for (i = 1; ; i++)//1~nobjs-1的内存块插入到空闲链表  </div><div class="line">    &#123;  </div><div class="line">        current_obj = next_obj;  </div><div class="line">        next_obj = (obj *)((char *)next_obj + n);//由于之前内存池里申请到的空间连续，所以这里需要人工划分成小块一次插入到空闲链表  </div><div class="line">  </div><div class="line">        if (nobjs - 1 == i)  </div><div class="line">        &#123;  </div><div class="line">            current_obj -&gt; free_list_link = 0;  </div><div class="line">            break;  </div><div class="line">        &#125;  </div><div class="line">        else  </div><div class="line">        &#123;  </div><div class="line">            current_obj -&gt; free_list_link = next_obj;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    return(result);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="4-从系统内存取空间给内存池"><a href="#4-从系统内存取空间给内存池" class="headerlink" title="4. 从系统内存取空间给内存池"></a>4. 从系统内存取空间给内存池</h5><p>首先根据end_free-start_free来判断内存池中的剩余空间是否足以调出nobjs个大小为size的内存块出去，如果内存连一个内存块的空间都无法供应，需要用malloc取堆中申请内存。<br><img src="http://oytnj8g2y.bkt.clouddn.com/6.jfif" alt=""><br>申请内存后，如果要拨出去20个大小为8字节的内存块。<br><img src="http://oytnj8g2y.bkt.clouddn.com/7.jfif" alt=""><br>假如山穷水尽，整个系统的堆空间都不够用了，malloc失败，那么chunk_alloc会从空闲链表中找是否有大的内存块，然后将该内存块的空间分给内存池（这个内存块会从链表中去除）。即内存池强制回收空闲链表的内存空间。<br><img src="http://oytnj8g2y.bkt.clouddn.com/8.jfif" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">template &lt;bool threads, int inst&gt;  </div><div class="line">class __default_alloc_template  </div><div class="line">&#123;  </div><div class="line">private:  </div><div class="line">    ......  </div><div class="line">    static char *start_free;//内存池可用空间的起始位置，初始化为0  </div><div class="line">    static char *end_free;//内存池可用空间的结束位置,初始化为0  </div><div class="line">    static size_t heap_size;//内存池的总大小  </div><div class="line">  </div><div class="line">public:  </div><div class="line">    // 申请 nobjs 个大小为size的内存块， </div><div class="line">    // nobjs传进去的是引用，因为可能会出现内存池空间不够的情况，nobjs最终为最后真实申请到的内存块个数</div><div class="line">    static char *chunk_alloc(size_t size, int &amp;nobjs)  </div><div class="line">    &#123;  </div><div class="line">        char * result;  </div><div class="line">        size_t total_bytes = size * nobjs;//需要申请空间的大小  </div><div class="line">        size_t bytes_left = end_free - start_free;//计算内存池剩余空间  </div><div class="line">  </div><div class="line">        //如果内存池剩余空间完全满足需求量  </div><div class="line">        if (bytes_left &gt;= total_bytes)  </div><div class="line">        &#123;  </div><div class="line">            result = start_free;  </div><div class="line">            start_free += total_bytes;  </div><div class="line">            return(result);  </div><div class="line">        &#125;  </div><div class="line">        //内存池剩余空间不满足需求量，但是至少能够提供一个以上内存块  </div><div class="line">        else if (bytes_left &gt;= size)  </div><div class="line">        &#123;  </div><div class="line">            nobjs = bytes_left / size;  </div><div class="line">            total_bytes = size * nobjs;  </div><div class="line">            result = start_free;  </div><div class="line">            start_free += total_bytes;  </div><div class="line">            return(result);  </div><div class="line">        &#125;  </div><div class="line">        //剩余空间连一个内存块（大小为size）也无法提供  </div><div class="line">        else  </div><div class="line">        &#123;  </div><div class="line">            size_t bytes_to_get = 2 * total_bytes + ROUND_UP(heap_size &gt;&gt; 4);  </div><div class="line">  </div><div class="line">            //内存池的剩余空间分给合适的空闲链表  </div><div class="line">            if (bytes_left &gt; 0)  </div><div class="line">            &#123;  </div><div class="line">                obj * __VOLATILE * my_free_list = free_list + FREELIST_INDEX(bytes_left);  </div><div class="line">  </div><div class="line">                ((obj *)start_free) -&gt; free_list_link = *my_free_list;  </div><div class="line">                *my_free_list = (obj *)start_free;  </div><div class="line">            &#125;  </div><div class="line">            start_free = (char *)malloc(bytes_to_get);//配置heap空间，用来补充内存池  </div><div class="line">            if (0 == start_free)  </div><div class="line">            &#123;  </div><div class="line">                int i;  </div><div class="line">                obj * __VOLATILE * my_free_list, *p;  </div><div class="line">  </div><div class="line">                //从空闲链表中找出一个比较大的空闲内存块还给内存池（之后会将这个大的空闲内存块切成多个小的空闲内存块再次加入到空闲链表）  </div><div class="line">                for (i = size; i &lt;= __MAX_BYTES; i += __ALIGN)  </div><div class="line">                &#123;  </div><div class="line">                    my_free_list = free_list + FREELIST_INDEX(i);  </div><div class="line">                    p = *my_free_list;  </div><div class="line">                    if (0 != p)  </div><div class="line">                    &#123;  </div><div class="line">                        *my_free_list = p -&gt; free_list_link;  </div><div class="line">                        start_free = (char *)p;  </div><div class="line">                        end_free = start_free + i;  </div><div class="line">                        return(chunk_alloc(size, nobjs));//递归调用自己，为了修正nobjs  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">                end_free = 0;  </div><div class="line">                start_free = (char *)malloc_alloc::allocate(bytes_to_get);//如果连这个大的内存块都找不出来则调用第一级配置器  </div><div class="line">            &#125;  </div><div class="line">            //如果分配成功  </div><div class="line">            heap_size += bytes_to_get;//内存池大小增加  </div><div class="line">            end_free = start_free + bytes_to_get;//修改内存池可用空间的结束位置  </div><div class="line">            return(chunk_alloc(size, nobjs));//递归调用自己，为了修正nobjs  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h5 id="5-空间释放函数deallocate"><a href="#5-空间释放函数deallocate" class="headerlink" title="5. 空间释放函数deallocate"></a>5. 空间释放函数deallocate</h5><p>首先先要检查释放内存块的大小，如果大于128字节就调用第一级配置器，小于128字节则根据内存块的大小来判断回收后的空间会被插入到哪个空闲链表。<br>例如回收下面指定位置大小为16字节的内存块，首先内存块的大小判断回收后的内存块应该插入到第二个空闲链表，把该节点指向的下一个地址修改为原链表指向的地址（这里是NULL）,然后将原链表指向该节点。<br><img src="http://oytnj8g2y.bkt.clouddn.com/4.jfif" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//释放地址为p，释放大小为n  </div><div class="line">static void deallocate(void *p, size_t n)  </div><div class="line">&#123;  </div><div class="line">    obj *q = (obj *)p;  </div><div class="line">    obj * __VOLATILE * my_free_list;  </div><div class="line">  </div><div class="line">    if (n &gt; (size_t) __MAX_BYTES)//如果空间大于128字节，采用普通的方法析构  </div><div class="line">    &#123;  </div><div class="line">        malloc_alloc::deallocate(p, n);  </div><div class="line">        return;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    my_free_list = free_list + FREELIST_INDEX(n);//否则将空间回收到相应空闲链表（由释放块的大小决定）中  </div><div class="line">    q -&gt; free_list_link = *my_free_list;  </div><div class="line">    *my_free_list = q;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h4><ol>
<li>使用 allocate 请求size大小的内存空间, 如果需要请求的内存大小大于128bytes, 直接使用malloc.</li>
<li>如果需要的内存大小小于128bytes, allocate根据size找到最适合的空闲链表.<br>&nbsp;a. 如果链表不为空, 返回第一个内存块, 链表头改为第二个内存块。<br>&nbsp;b. 如果链表为空, 使用refill为该空闲链表填充新的空间。<br>&nbsp;&nbsp;x. 如果内存池中有大于一个内存块的空间, 分配尽可能多的内存块(但是最多20个), 将一个内存块返回, 其他的内存块添加到链表中。<br>&nbsp;&nbsp;y. 如果内存池只有一个内存块的空间, 直接返回给用户.<br>&nbsp;&nbsp;z. 如果内存池连一个内存块的空间都没有, 再次向操作系统请求分配内存.<br>&nbsp;&nbsp;&nbsp;I 系统内存足够，分配成功，再次进行b过程<br>&nbsp;&nbsp;&nbsp;II 分配失败, 循环各个空闲链表, 寻找空间<br>&nbsp;&nbsp;&nbsp;&nbsp;A. 找到空间, 再次进行过程b<br>&nbsp;&nbsp;&nbsp;&nbsp;B. 找不到空间, 抛出异常</li>
<li>用户调用deallocate释放内存空间, 如果要求释放的内存空间大于128bytes, 直接调用free。</li>
<li>否则按照其大小找到合适的空闲链表, 并将其插入。</li>
</ol>
<p>特点其实是这样的:</p>
<ol>
<li>刚开始初始化内存池的时候, 其实内存池中并没有内存, 同时所有的空闲链表都为空链表.</li>
<li>只有用户第一次向内存池请求内存时, 内存池会依次执行上述过程的 1-&gt;2-&gt;b-&gt;z来完成内存池以及链表的首次填充, 而此时, 其他未使用链表仍然是空的.<br><img src="http://oytnj8g2y.bkt.clouddn.com/10.png" alt=""><br><img src="http://oytnj8g2y.bkt.clouddn.com/11.png" alt=""><br><img src="http://oytnj8g2y.bkt.clouddn.com/12.png" alt=""></li>
</ol>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/03/16/计算机概念的英文表述/">
                计算机概念的英文表述
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-03-16</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="map-vs-set"><a href="#map-vs-set" class="headerlink" title="map vs set"></a>map vs set</h3><p>In C++ STL, a map sometimes is referred to as a dictionary, consists of key/value pairs. The key is used to order the sequence, and the value is somehow associated with that key. For example, a map might contain keys representing every unique word in a text and values representing the number of times that word appears in that text.<br>a set is simply an ascending container of unique elements.<br>STL’s map and set are implemented with RB-Tree.<br>Both set and map support bidirectional iterators.<br>While not officially part of the STL standard, hash_map and hash_set are commonly used to improve searching time. These containers store elements as a hash table, with each table entry (bucket) containing a bidirectional linked list of elements.<br>Additionally, python’s dict and set is implemented with hash table. This is different from C++.</p>
<h3 id="stack-vs-heap"><a href="#stack-vs-heap" class="headerlink" title="stack vs heap"></a>stack vs heap</h3><p>stack:</p>
<ol>
<li>abstract data type, concept, LIFO</li>
<li>call stack<br>heap:</li>
<li>data structure, commonly used to implement a priority queue. A Specialized tree-based data structure that satisfies heap property: if P is parent node of C, then the key of P is either greater than or equal to the key of C. And it is a complete binary tree.</li>
<li>free store, an area of memory used for dynamic memory allocation</li>
</ol>
<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>is compact, allow random access.</p>
<h3 id="linked-list"><a href="#linked-list" class="headerlink" title="linked list"></a>linked list</h3><p>elements can be inserted or removed without a lot of movement operations because the data items need not to be stored<br>continuously in memory.</p>
<h3 id="singly-linked-list"><a href="#singly-linked-list" class="headerlink" title="singly linked list"></a>singly linked list</h3><p>A singly linked list node have a data field, a next field.</p>
<h3 id="Doubly-linked-list"><a href="#Doubly-linked-list" class="headerlink" title="Doubly linked list"></a>Doubly linked list</h3><p>A doubly linked list node has a data field, a next field and a previous field.</p>
<h3 id="Circular-linked-list"><a href="#Circular-linked-list" class="headerlink" title="Circular linked list"></a>Circular linked list</h3><p>the next field of the last node points to the first node</p>
<h3 id="Multithreading’s-drawback"><a href="#Multithreading’s-drawback" class="headerlink" title="Multithreading’s drawback"></a>Multithreading’s drawback</h3><ol>
<li>Synchronization: deadlock, race over resource.</li>
<li>an illegal operation performed by a thread crashes the entire process.</li>
</ol>
<h3 id="Dining-philosophers-problem"><a href="#Dining-philosophers-problem" class="headerlink" title="Dining philosophers problem"></a>Dining philosophers problem</h3><p>is an example problem used in concurrent algorithm design to illustrate synchronization issues.<br>Fiving slient philosophers sit at a round table. Forks are placed between each pair of adjacent philosophers.<br>Each philosopher must alternately think and eat.<br>A philosopher can eat only when he have both left and ritht forks. No philosopher knows when others may want to eat or think.<br>The challenge is to avoid deadlock, a system state in which no progress is possible.<br>In this problem, the deadlock happens when each philosopher pick up the left fork, and is waiting for the right fork to be available. Then the philosophers will wait for each other to release a fork.<br>timing and retry. There may be a rule that the philosopher put down a fork after waiting 10 minutes for another fork and wait a 5 minutes before making a next attempt. This scheme eliminates the possibility of deadlock but still suffers from livelock when five philosophers pick up the left fork at the same time.</p>
<h5 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h5><ol>
<li>Resource hierarchy solution<br>Here, the resources (forks) will be numbered 1 through 5 and each unit of work (philosopher) will always pick up the lower-numbered fork first, and then the higher-numbered fork, from among the two forks they plan to use. The order in which each philosopher puts down the forks does not matter. In this case, if four of the five philosophers simultaneously pick up their lower-numbered fork, only the highest-numbered fork will remain on the table, so the fifth philosopher will not be able to pick up any fork. Moreover, only one philosopher will have access to that highest-numbered fork, so they will be able to eat using two forks.</li>
<li>Arbitrator solution<br>Another approach is to guarantee that a philosopher can only pick up both forks or none by introducing an arbitrator, e.g., a waiter. In order to pick up the forks, a philosopher must ask permission of the waiter. The waiter gives permission to only one philosopher at a time until the philosopher has picked up both of their forks. Putting down a fork is always allowed. The waiter can be implemented as a mutex. In addition to introducing a new central entity (the waiter), this approach can result in reduced parallelism: if a philosopher is eating and one of their neighbors is requesting the forks, all other philosophers must wait until this request has been fulfilled even if forks for them are still available.</li>
</ol>
<h3 id="priority-queue-vs-heap"><a href="#priority-queue-vs-heap" class="headerlink" title="priority queue vs heap"></a>priority queue vs heap</h3><p>A priority queue is an abstract data type where each element has a “priority” associated with it.<br>In priority queue, an element with high priority dequeue before the element with low priority.<br>While priority queue is often implemented with heap, they are conceptually different from heap.<br>A priority queue is abstract concept like “a map”, a map can be implemented with RB-Tree or hash table, a priority can be implemented with a heap or something else.</p>
<h3 id="heap-sort"><a href="#heap-sort" class="headerlink" title="heap sort"></a>heap sort</h3><p>is an improved selection sort: like that algorithm, it divides its input into a sorted region and an unsorted region. It iteratively shrinks the unsorted region by extracting the largest element and moving that into the sorted region.<br>Although somewhat slower than a well-implemented quick sort, it has the advantage of a more favourable worst-case O<br>(nlogn) runtime. And it is an inplace but not a stable algorithm.<br>steps:</p>
<ol>
<li>call heapify(), build a heap in O(n) operations. Floyd down to top siftdown.</li>
<li>swap the first element of the input vector with the final element. Now the final element is in its correct position. Decrease the considered range of the vector by one.</li>
<li>call siftdown() to restore the unsorted region into a heap.</li>
<li>Go to step 2, unless the considered range of the vector has only one element.</li>
</ol>
<h3 id="SQL-injection"><a href="#SQL-injection" class="headerlink" title="SQL injection"></a>SQL injection</h3><p>nefarious SQL statements are inserted into an entry field.<br>May dump the database contents to attackers.</p>
<ol>
<li>incorrectly filtered escape characters<br>This form of SQL injection occurs when user input is not filterd for escape characters and then is passed into an SQL statement.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;select * from users where name = &apos;&quot; + username +&quot;&apos;;&quot;</div><div class="line">username = &apos; OR &apos;1&apos; = &apos;1</div></pre></td></tr></table></figure>
</li>
</ol>
<p>now attackers will get all data in users table.</p>
<ol>
<li>incorrect type handling<br>occurs when a user-supplied field is not strongly typed or is not checked for type constraints.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;select * from userinfo where id=&quot; + a_variable +&quot;;&quot;</div><div class="line">a_variable is intended to be a number </div><div class="line">but if it is a string such as &quot;1; drop table users&quot;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>solution:<br>escaping and type checking</p>
<h3 id="Cross-site-Scripting-XSS"><a href="#Cross-site-Scripting-XSS" class="headerlink" title="Cross-site Scripting (XSS)"></a>Cross-site Scripting (XSS)</h3><p>typically found in web applications<br>XSS enables attackers to inject client-side scripts into the web pages which are viewed by other users.<br>A XSS vulnerability may be used by attackers to bypass access controls such as the same-origin policy.<br>same-origin policy:<br>A web browser permits scripts contained in the first web page to access data in the second web page, only if both web pages have the same origin.<br>same-origin: same protocol, same host and same port.</p>
<h3 id="Singleton-pattern"><a href="#Singleton-pattern" class="headerlink" title="Singleton pattern"></a>Singleton pattern</h3><p>is a software design pattern that restricts the instantiation of a class to only one object.<br>It’s useful when exactly one object is needed to coordinate actions across the whole system.<br>How to implement a singleton class</p>
<ol>
<li>protected or private constructor</li>
<li>private static pointer to the only instance</li>
<li>public static member function that returns the pointer<br>A singleton implementation may use lazy initialization, where the instance is created when the static method is first invoked. If the static method might be called from multiple threads simultaneously, we should pay attention to race condition that could result in the creation of multiple instances of the class.<br>Solution:<br>lazy initialization + double check :check + acquire the mutex + check</li>
</ol>
<h3 id="stack-overflow"><a href="#stack-overflow" class="headerlink" title="stack overflow"></a>stack overflow</h3><p>the website? a question and answer website on the topic of programming.<br>occurs [əˈkɜ:(r)] when the call stack pointer exceeds the stack bound.<br><em>The call stack may consist of a limited amount of address space, often determined at the start of the program. The size depends on many factors including programming language, machine architecture, multithreading, and amount of available memory.</em><br>stack overflow typically results in program crash.</p>
<ol>
<li>Infinite / very deep recursion<br>a function calls itself so many times that the space needed to store the variables and information associated with each call is more than can fit on the stack.</li>
<li>very large stack variables<br>an attempt to allocate more memory than can fit on the stack.<br>For example, create local array varibles that are too large. For this reason, it is recommended that arrays larger than a few kilobytes should be allocated dynamically instead of as stack variables.</li>
</ol>
<h3 id="binary-tree"><a href="#binary-tree" class="headerlink" title="binary tree"></a>binary tree</h3><p>is tree data structure in which each node has at most two child nodes, which refered to as left child and right child.<br>A binary tree node typically has a data field, left field and right field.<br>tree: In graph theory, a tree is a connected acyclic[ˌeɪˈsaɪklɪk] graph.</p>
<h3 id="binary-sorted-tree-binary-search-tree"><a href="#binary-sorted-tree-binary-search-tree" class="headerlink" title="binary sorted tree/ binary search tree"></a>binary sorted tree/ binary search tree</h3><p>keeps their keys in sorted order, so that lookup and other operations can use the principle of binary search.<br>search/ insertion/ deletion logn<br>That’s much better than the linear time required to find items by key in an unsorted array, but slower than the corresponding operations on hash table.<br>BST satisfies the binary search property, which states that the key in each node must be greater than or equal to any keys stored in the left sub-tree, and less than or equal to any keys stored in the right sub-tree.<br>BST can be used to implement either dynamic set of items or look up table that allow finding items by key.</p>
<h3 id="Database-index"><a href="#Database-index" class="headerlink" title="Database index"></a>Database index</h3><p>is a data structure that improves the speed of data retrieval[rɪˈtri:vl]<br> operations at the cost of additional space and effort to maintain the structure.</p>
<p>indexes are used to quickly locate data without having to search every row in a database table. Indexes can be created using one or more columns.<br>An index is a copy of data from the selected columns and include a low-level disk block address or direct link to a complete row.<br>Tree Node key: index column value<br>Tree Node value: address or link</p>
<ul>
<li>Dense Index: pairs of key and pointer for every record in data file.</li>
<li>Spare Index: pairs of key and pointer for every block in data file.</li>
</ul>
<h3 id="memory-leak"><a href="#memory-leak" class="headerlink" title="memory leak"></a>memory leak</h3><p>memory which is no longer needed is not released.<br>In oop, a memory leak may happen when an object is stored in memory but can be accessed by running code.<br>Because memory leak can exhaust available system memory as application runs, memory leak is often a cause of or a contributing factor for software aging. </p>
<h5 id="solutions"><a href="#solutions" class="headerlink" title="solutions"></a>solutions</h5><ol>
<li>RAII resource acqusition is initialization<br>is an approch to this problem commonly taken in C++.<br>It associates scoped objects with required resources, and automatically release resources once the objects go out of scope. Unlike garbage collection, RAII has the advantage of knowing when objects exist and when they don’t.</li>
<li>reference counting, smart pointer<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/*C version */</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">void f(int n) &#123;</div><div class="line">    int* array = calloc(n, sizeof(int));</div><div class="line">    do_somework(array);</div><div class="line">    free(array);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/* C++ version */</div><div class="line">#include &lt;vector&gt;</div><div class="line">void f(int n) &#123;</div><div class="line">    std::vector&lt;int&gt; array(n);</div><div class="line">    do_somework(array);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The C++ version requires no explicit deallocation.<br>It will always occur automatically once the object goes out of scope, including if a exception is thrown.<br>RAII also works with open files, open windows, objects in a graphics drawing library, thread synchronization primitives, network connections and connections to database.</p>
<h3 id="multiple-inheritance"><a href="#multiple-inheritance" class="headerlink" title="multiple inheritance"></a>multiple inheritance</h3><p>is a feature of oop in which a class can inherit from more than one parent class.<br>It has been a sensitive issue for many years and it may result in “Diamond Problem”.</p>
<h3 id="pass-by-value"><a href="#pass-by-value" class="headerlink" title="pass-by-value"></a>pass-by-value</h3><p>means that the value of function parameter is copied into another location of you memory.<br>When accessing and modifying the variable within the function, only the copy is accessed and modified, the original is left untouched. In other word, the inner variable and the outer variable are not the same one.</p>
<h3 id="pass-by-reference"><a href="#pass-by-reference" class="headerlink" title="pass-by-reference"></a>pass-by-reference</h3><p>means that the address of the variable is passed into the function.<br>it can avoid unnecessary copy construction of object and improve the speed.</p>
<h3 id="overloading-vs-overriding"><a href="#overloading-vs-overriding" class="headerlink" title="overloading vs overriding"></a>overloading vs overriding</h3><p>overloading occurs when two or more functions in same scope have same name but different parameters list or constantness.<br>overriding occurs when a method in derived class and a method in base class have the same name and same parameters list. (different from re-definition)</p>
<h3 id="virtual-function"><a href="#virtual-function" class="headerlink" title="virtual function"></a>virtual function</h3><p>is an important part of runtime polymorphism. A vitual function gives a target function to be executed but the target function might not be known at compile time.<br>Class containing pure virtual functions is termed “abstract” and they cann’t be instantiated directly.<br>A pure virtual function is required to be implemented by a derived class if the derived class is not abstract.</p>
<h3 id="virtual-destructor"><a href="#virtual-destructor" class="headerlink" title="virtual destructor"></a>virtual destructor</h3><p>a class intended to be base class should declare a virtual destructor<br>why?<br>If an object of type Wolf is created but pointed to by an Animal pointer, and it is this Animal pointer type that is deleted, the destructor called may actually be the one defined for Animal and not the one for Wolf, unless the destructor is virtual. This is particularly the case with C++, where the behaviour is a common source of programming errors.</p>
<h3 id="virtual-inheritance"><a href="#virtual-inheritance" class="headerlink" title="virtual inheritance"></a>virtual inheritance</h3><p>is a C++ technique that ensures only one copy of base class’s member variables are inherited by grandchild derived class.<br>without virtual inheritance, if class A and class B both inherite from class X, class C inherites from A and B, then class C will contain two copies of X’s member variables: one via A and one via B.These will be accessible independently using scope resolution.</p>
<h3 id="smart-pointer"><a href="#smart-pointer" class="headerlink" title="smart pointer"></a>smart pointer</h3><p>prevent memory leak by making the memory deallocation automatic.<br>works with reference counting.<br>smart pointer is a container for raw pointer.<br>smart pointer in C++ is a class template that mimics raw pointer by operator overloading while providing memory management features.</p>
<p><hr><br>shared_ptr: when reference counting is down to zero, the object is destoryed.<br>unique_ptr: explicitly prevents copying of its contained raw pointer, but the std::move function can be used to transfer the ownership of the contained raw pointer to another unique_ptr. A unique_ptr can’t be copied because its copy constructor and copy assignment operator are explicitly deleted.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">std::unique_ptr&lt;int&gt; p1(new int(5));</div><div class="line">std::unique_ptr&lt;int&gt; p2 = p1; // compile error</div><div class="line">std::unique_ptr&lt;int&gt; p3 = std::move(p1);  // ok</div><div class="line">// transfer the ownership of the contained raw pointer</div><div class="line">p3.reset(); // delete the memory</div><div class="line">p1.reset(); // does nothing</div></pre></td></tr></table></figure></p>
<p><strong>std::auto_ptr is deprecated under C++ 11 and will be removed completely from C++ 17.</strong><br>weak_ptr is created as a copy of shared_ptr, it doesn’t increase the reference counting of the object controlled by shared_ptr.</p>
<h3 id="database-transaction"><a href="#database-transaction" class="headerlink" title="database transaction"></a>database transaction</h3><p>a bunch of SQL statements<br>a unit of work performed by database management system against database<br>a database transaction, by definition, must be atomic, consistent, isolated, durable, ACID.<br>transaction provides an “all-or-nothing” proposition, stating that each unit of work must either complete entirely or have no effect whatsoever.</p>
<h3 id="primary-key"><a href="#primary-key" class="headerlink" title="primary key"></a>primary key</h3><p>a column or a set of columns that uniquely identify a row in a table.</p>
<h3 id="foreign-key"><a href="#foreign-key" class="headerlink" title="foreign key"></a>foreign key</h3><p>a field or a collection of fields in one table that uniquely identify a row in another table.</p>
<h3 id="inter-process-communication"><a href="#inter-process-communication" class="headerlink" title="inter-process communication"></a>inter-process communication</h3><p>refers to system-provided mechanisms that allow processes to communicate with each other.<br>Typically, applications use IPC, categoried as client and server, where the client requests data and server responds to client requests.<br>Method:</p>
<ul>
<li>file</li>
<li>socket</li>
<li>message queue</li>
<li>pipe </li>
<li>shared memory</li>
<li>memory-mapped file</li>
<li>signal (asynchronous system trap): a system message sent from one process to another not usually used to transfer data, but to remotely command the partnered process.</li>
</ul>
<h3 id="UDP-vs-TCP"><a href="#UDP-vs-TCP" class="headerlink" title="UDP vs TCP"></a>UDP vs TCP</h3><p><strong>TCP</strong> (transmission control protocol) is <strong>connection-oriented</strong> protocol, which means that it requires handshaking to set up end-to-end connection. Once the connection is set up, user data may be sent bi-directionally over the connection.</p>
<ul>
<li>Reliable - Strictly only at transport layer, TCP manages message <strong>acknowledgement, retransmission, timeout</strong>. This reliability does not cover application layer, at which a separate acknowledgement flow control is still necessary.</li>
<li>ordered - if two messages are sent over a connection in sequence, the first message will reach the receiving application first. When data segments arrive in wrong order, TCP buffers delay the out-of-order segments utill all data segments can be properly re-ordered and delivered to application.</li>
<li>heavyweight - TCP requires handshaking (3 packets) to set up connection, before data be sent. TCP handles reliability and <strong>congestion control</strong>.</li>
<li>streaming - data is read as a byte stream, no distinguishing indications are transmitted to signal message boundaries.</li>
</ul>
<p><strong>UDP</strong> (user datagram protocol) is a simpler message-based connectionless protocol. Communication is achieved by transmitting information in one direction from source to destination without verifying the readiness or the state of receiver.</p>
<ul>
<li>Unreliable - When a UDP message is sent, it can be not known if it will reach its destination; it could be lost along the way. there is no concept of acknowledgement, retransmission, timeout.</li>
<li>not ordered - if two messages are sent to same recipient, the order in which they arrive can’t be predicted.</li>
<li>ligthweight - it’s a small transport layer designed on top of IP.</li>
<li>datagrams - packets have definite boundaries, which means that a read recipient at the receiver socket will yield an entire message as it was sent originally.</li>
<li>no congestion control</li>
<li>broadcast - being connectionless, UDP can broadcast. Sent packets are accessible by all devices on the subnet.</li>
</ul>
<h3 id="Connection-establishment-of-TCP"><a href="#Connection-establishment-of-TCP" class="headerlink" title="Connection establishment of TCP"></a>Connection establishment of TCP</h3><p>three-way handshake<br>Before a client attempts to connect with a server, the server must first bind to and listen to a port to open it up for connections: this is called ‘passive open’. Once the passive open is established, a client may initiate an ‘active open’.<br>To establish a connection, the three-way shake occurs:</p>
<ol>
<li>SYN: The client sends a SYN to server. The sequence number is set to a random value A;</li>
<li>SYN-ACK: In response, the server replies with a SYN-ACK. The acknowledgement number is set to A+1; The sequence number is set to another random value B.</li>
<li>ACK: Finally, the client sends a ACK to server. The acknowledgement number is set to B+1; the sequence number is set to A+1.</li>
</ol>
<h4 id="Connection-termination-of-TCP"><a href="#Connection-termination-of-TCP" class="headerlink" title="Connection termination of TCP"></a>Connection termination of TCP</h4><p>four-way handshake<br>when an end-point wishes to stop its half of the connection, it transmits a FIN packet, which the other will acknowledge with an ACK.</p>
<h3 id="thread-vs-process"><a href="#thread-vs-process" class="headerlink" title="thread vs process"></a>thread vs process</h3><ul>
<li>processes have independent/separate address space, while threads in a process share their address space.</li>
<li>context switching between threads is much faster than context switching between processes.</li>
<li>processes interact only throuth system-provided inter-process communication mechanisms.</li>
<li>multiple threads within a process share process state as well as memory and other resources</li>
</ul>
<h3 id="stack-vs-heap-1"><a href="#stack-vs-heap-1" class="headerlink" title="stack vs heap"></a>stack vs heap</h3><ul>
<li>the stack is memory set aside as scratch space for a thread execution.</li>
<li>the heap is memory set aside for dynamic allocation.</li>
<li>variables created on stack will be deallocated automatically when they go out of scope </li>
<li>variables created on heap must be destroyed manually.</li>
<li>allocation on stack is faster than heap</li>
<li>stack stores local variables, return addresses, and is used for parameters passing.</li>
<li>heap can have fragmentations when there are a lot of allocations and deallocations.</li>
</ul>
<h3 id="polymorphism"><a href="#polymorphism" class="headerlink" title="polymorphism"></a>polymorphism</h3><p>a single interface to different entities.</p>
<ul>
<li>function overloading, compile polymorphism</li>
<li>template, generic programming</li>
<li>virtual function, runtime polymorphism, call a method by a base class pointer, the actual method been called depends on the pointer’s dynamic type instead of static type.</li>
</ul>
<h3 id="recursion"><a href="#recursion" class="headerlink" title="recursion"></a>recursion</h3><p>the solution to a problem depends on solutions to smaller instances of the same problem.<br>programming languages support recursion by allowing a function to call itself.</p>
<h3 id="quick-sort"><a href="#quick-sort" class="headerlink" title="quick sort"></a>quick sort</h3><ol>
<li>pick an element as pivot from the array</li>
<li>partitioning: reorder the array so that all elements smaller than the pivot come before the pivot, while all elements bigger than the pivot come after the pivot. After the partitioning, the pivot is in its final position.</li>
<li>recursively apply the above steps to the sub-arrays.</li>
</ol>
<h3 id="public-private-protected"><a href="#public-private-protected" class="headerlink" title="public, private, protected"></a>public, private, protected</h3><ol>
<li>public: members are accessible outside the class</li>
<li>protected: members are only available to derived class</li>
<li>private: members are only accessible inside the class</li>
</ol>
<h3 id="copy-constructor"><a href="#copy-constructor" class="headerlink" title="copy constructor"></a>copy constructor</h3><p>initialize its object member variables with another object of the same class</p>
<h3 id="inline-function"><a href="#inline-function" class="headerlink" title="inline function"></a>inline function</h3><p>should be put into header file, and the header file is included as required.</p>
<h3 id="default-constructor"><a href="#default-constructor" class="headerlink" title="default constructor"></a>default constructor</h3><p>is declared by compiler.<br>it is an inline public member function, have no constructor initializer and have a null body.</p>
<h3 id="default"><a href="#default" class="headerlink" title="default"></a>default</h3><p>the members of class are private by default</p>
<h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>used to group entities like class, objects, functions under a name.</p>
<h3 id="late-binding-vs-early-binding"><a href="#late-binding-vs-early-binding" class="headerlink" title="late binding vs early binding"></a>late binding vs early binding</h3><p><strong>late binding</strong> refers to function calls that are resolved at runtime (occurs through virtual function)<br><strong>early binding</strong> refers to function calls that are resolved at compile time. (increase efficiency)</p>
<h3 id="hash-collision"><a href="#hash-collision" class="headerlink" title="hash collision"></a>hash collision</h3><ul>
<li>linear probing</li>
<li>quadratic probing</li>
<li>separate chaining<hr></li>
<li>lazy deletion</li>
<li>rehashing</li>
</ul>
<h3 id="inline-vs-macro"><a href="#inline-vs-macro" class="headerlink" title="inline vs macro"></a>inline vs macro</h3><ul>
<li>type check</li>
<li>debug </li>
<li>a function vs just text </li>
</ul>
<p>the code is inserted into the position where the function is called.</p>
<p>speed up execution vs code bloat</p>
<h3 id="when-a-smart-pointer-1"><a href="#when-a-smart-pointer-1" class="headerlink" title="when a smart pointer + 1"></a>when a smart pointer + 1</h3><ol>
<li>use the shared_ptr to initialize another shared_ptr</li>
<li>as parameter been passed into a funciton</li>
<li>returned by a function</li>
</ol>
<h3 id="when-a-smart-pointer-1-1"><a href="#when-a-smart-pointer-1-1" class="headerlink" title="when a smart pointer - 1"></a>when a smart pointer - 1</h3><ol>
<li>shared_ptr been assigned a new value</li>
<li>shared_ptr been destroyed</li>
</ol>
<h3 id="why-MS"><a href="#why-MS" class="headerlink" title="why MS?"></a>why MS?</h3><p>when answering the question of what motivated you to join morgan stanley, Bjarne Stroustrup said “I find myself motivated by the technical challenges and by working with a technical community that is among the best skilled in the world.” That’s also my motivation.</p>
<h3 id="have-you-ever-seen-the-designer-of-C"><a href="#have-you-ever-seen-the-designer-of-C" class="headerlink" title="have you ever seen the designer of C++?"></a>have you ever seen the designer of C++?</h3><p>Do I have a chance to listen to his lecture in the future?</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/03/15/MySQL-Crash-Course-读书笔记/">
                MySQL Crash Course 读书笔记
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-03-15</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><p>数据库就是数据库管理系统创建和操纵的容器。<br>模式(schema) 可以用来描述数据库中特定的表以及整个数据库（和其中表的关系），即关于数据库和表的布局及特性信息。</p>
<p>数据类型限制可存储在列中的数据类型，帮助正确的排序数据，并在优化磁盘使用方面起重要的作用。<br>主键：一列或者一组列，其值可以唯一区分表中的每行。没有主键，更新后者删除表中特定行是困难的，因为没有安全的方式保证只涉及相关的行。虽然并不总是需要主键，但是大多数数据库设计人员应该保证他们创建额每个表具有一个主键，以便于以后的数据操纵和管理。<br>表中的任何列都可以作为主键，只要满足两个条件：</p>
<ol>
<li>任意两行不具有相同的主键</li>
<li>每个行都必须具有一个主键值，主键列不允许NULL值。<br>主键的最佳实践：</li>
<li>不更新主键列的值</li>
<li>不重用主键列的值</li>
<li>不在主键列中使用可能会更改的值。</li>
</ol>
<h2 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h2><p>DBMS 可以分为两类</p>
<ol>
<li>基于共享文件系统， Microsoft Access， FileMaker，桌面用途。</li>
<li>基于客户机-服务器， MySQL， Oracle，Microsoft SQL Server。<br>注意：</li>
<li>命令用;或者\g结束，换句话说，仅按Enter不执行命令。</li>
<li>help or \h</li>
<li>quit or exit</li>
</ol>
<h2 id="Chapter-3-使用-MySQL"><a href="#Chapter-3-使用-MySQL" class="headerlink" title="Chapter 3 使用 MySQL"></a>Chapter 3 使用 MySQL</h2><p>默认端口 3306<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use crashcourse;</div><div class="line">Database changed</div></pre></td></tr></table></figure></p>
<p>数据库、表、列、用户、权限等的信息被存储在数据库和表中，MySQL 使用 MySQL 来存储这些信息。不过，内部的表一般不直接访问，可使用 MySQL 的 show 命令来显示这些信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show databases;</div></pre></td></tr></table></figure></p>
<p>包含在结果列表中的可能是 MySQL 内部使用的数据库，如 mysql， information_schema。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show tables;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show columns from customers;</div></pre></td></tr></table></figure>
<p>什么是自动增量？<br>某些表列需要唯一值，例如订单编号，在每个行添加至表中时，MySQL 可以自动地为每个行分配下一个可用编号，不用在添加一行时手动分配唯一值（这样必须记住最后一次使用的值）。<br>describe 语句， MySQL 支持用 describe 作为 show columns from 的一种快捷方式。<br>所支持的其他show语句还有：</p>
<ul>
<li>show status, 用于显示广泛的服务器状态信息</li>
<li>show create database, show create table，用来显示创建特定数据库或表的MySQL语句。</li>
<li>show grants, 用来显示授予用户（所有用户或特定用户）的安全权限。</li>
<li>show errors, show warnings 用来显示服务器错误或者警告信息。</li>
</ul>
<h3 id="Chapter-4-检索数据"><a href="#Chapter-4-检索数据" class="headerlink" title="Chapter 4 检索数据"></a>Chapter 4 检索数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select prod_name from products;</div><div class="line">``` </div><div class="line">如果没有明确排序查询结果，则返回的数据的顺序并没有特殊意义，返回数据的顺序可能是数据被添加到表中的顺序，也可能不是。</div><div class="line">多条 SQL 语句必须以分号分隔，MySQL 如同多数DBMS一样，不需要在单条SQL语句后加分号，但是在mysql 命令行，必须加上分号来结束SQL语句。</div></pre></td></tr></table></figure>
<p>select * from products;<br>select distinct vend_id from products;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">不能部分使用distinct, distinct 关键字应用于所有列而不仅仅是前置它的列。</div></pre></td></tr></table></figure></p>
<p>select prod_name from products limit 5;<br>select prod_name from products limit 6, 5;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">limit 6, 5 返回从行6开始的5行。包前。</div><div class="line">如果没有足够的行，只返回它能返回的行数。</div><div class="line">由于这两位数字的混淆，MySQL 5 支持limit 的另一种替代语法，`limit 4 offset 3`。</div><div class="line">表名和列名可以是完全限定的，`select products.prod_name from crashcourse.products`，在一些情形下是需要完全限定名的。</div><div class="line"></div><div class="line">### Chapter 5 排序检索数据</div><div class="line">select 语句的 order by 子句。</div><div class="line">子句 clause，SQL 语句由子句构成，有些子句是必须的，有些子句是可选的。</div></pre></td></tr></table></figure></p>
<p>select prod_name from products order by prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">用非检索的列排序数据是完全合法的。</div></pre></td></tr></table></figure></p>
<p>select prod_id, prod_price, prod_name from products order by prod_price, prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">指定排序方向</div></pre></td></tr></table></figure></p>
<p>select prod_id, prod_price, prod_name from products order by prod_price desc, prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">desc 关键字只应用于直接位于其前面的列名。</div><div class="line">在给出 order by 子句时，应该保证它位于from子句之后，如果使用limit子句，它必须位于order by子句之后，使用的子句顺序不对将产生错误信息。</div><div class="line"></div><div class="line">### Chapter 6 过滤数据</div></pre></td></tr></table></figure></p>
<p>select prod_name, prod_price from products where prod_price = 2.50;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">SQL 过滤与应用过滤：SQL 过滤快速且节省带宽。</div><div class="line">在同时使用 order by 和 where时，应该让 order by 位于where之后。</div><div class="line">where 子句操作符：</div><div class="line"></div><div class="line">+ = 等于</div><div class="line">+ &lt;&gt; 不等于</div><div class="line">+ != 不等于</div><div class="line">+ &lt;, &lt;=, &gt;, &gt;=</div><div class="line">+ between</div></pre></td></tr></table></figure></p>
<p>select prod_name, prod_price from products where prod_name = ‘fuses’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">何时使用括号？</div><div class="line">单引号用来限定字符串，如果将值与串类型的列进行比较，则需要引号。</div></pre></td></tr></table></figure></p>
<p>select prod_name, prod_price from products where prod_price between 5 and 10;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">包前包后。</div><div class="line">NULL 与0，空字符串或者仅仅包含空格不同。</div></pre></td></tr></table></figure></p>
<p>select prod_name from products where prod_name is null;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### Chapter 7 数据过滤</div><div class="line">MySQL 允许给出多个where子句，并用and或者or进行连接。</div><div class="line">计算次序</div></pre></td></tr></table></figure></p>
<p>select prod_name, prod_price from products where vend_id = 1002 or vend_id = 1003 and prod_price &gt;= 10;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SQL 在处理or操作符之前，优先处理and操作符，当MySQL 看到上面的句子时，它理解为由供应商1003制造的价格10美元（含）以上的产品，或者由供应商1002 制造的任何产品，而不管其价格如何。</div><div class="line">换句话说，and 在计算次序中优先级更高。</div></pre></td></tr></table></figure></p>
<p>select prod_name, prod_price from products where (vend_id = 1003 or vend_id = 1002) and prod_price &gt;= 10;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">圆括号在where子句中除了用于明确计算顺序，还能用来指定 in 操作符的范围，合法值由逗号分隔，全部都在圆括号中。</div></pre></td></tr></table></figure></p>
<p>select prod_name, prod_price from products where vend_id in (1002, 1003, 1004) order by prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">in 操作符与 or 操作符完成相同的功能，那为什么使用 in 操作符呢？</div><div class="line">1. 直观</div><div class="line">2. 计算次序更加容易管理</div><div class="line">3. 比 or 更快</div><div class="line">4. in 的最大优点是可以包含其他的select 语句，使得能够动态地建立where子句。</div></pre></td></tr></table></figure></p>
<p>select prod_name, prod_price from products where vend_id not in (1002, 1003, 1004) order by prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">MySQL 支持使用 not 对 in，between，exists 子句取反。</div><div class="line"></div><div class="line">### Chapter 8 用通配符进行过滤</div><div class="line">like 操作符</div><div class="line">为在搜索子句中使用通配符，必须使用like操作符，like 指示 MySQL 后跟的搜索模式利用通配符匹配而不是直接相等比较。</div><div class="line">%表示任意字符出现任意次数。</div></pre></td></tr></table></figure></p>
<p>select prod_id, prod_name from products where prod_name like ‘jet%’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">**根据MySQL的配置方式，搜索可以是区分大小写的，如果区分大小写，&apos;jet%&apos;与JetPack 1000将不匹配。**</div><div class="line">注意尾空格，例如，在保存词anvil时，如果它后面有一个或者多个空格，则子句where prod_name like &apos;%anvil&apos;将不会匹配它们，解决这个问题的一个简单办法是在搜索模式（search pattern）的最后附加一个%，一个更好的方式是使用函数去掉尾空格。</div><div class="line">**%似乎可以匹配任何东西，但是NULL除外。**</div><div class="line">\_通配符，只匹配单个字符。</div><div class="line">通配符的使用技巧：</div><div class="line">1. 不要过度使用通配符。</div><div class="line">2. 在确实需要使用通配符时，除非有必要，否则不要将通配符放在搜索模式的开始处，放在开始处搜索起来是最慢的。</div><div class="line"></div><div class="line">### Chapter 9 使用正则表达式</div><div class="line">MySQL 仅支持正则表达式的一个很小的子集。</div><div class="line">基本字符匹配</div></pre></td></tr></table></figure></p>
<p>select prod_name from products where prod_name regexp ‘1000’ order by prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">返回列 prod_name 包含&apos;1000&apos;的所有行。</div></pre></td></tr></table></figure></p>
<p>select prod_name from products where prod_name regexp ‘.000’ order by prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MySQL 的正则表达式匹配不区分大小写，为了区分大小写可以用 binary 关键字，如 where prod_name regexp binary &apos;JetPack .000&apos;</div><div class="line">进行or匹配</div></pre></td></tr></table></figure></p>
<p>select prod_name from products where prod_name regexp ‘1000|2000|3000’ order by prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">输出</div></pre></td></tr></table></figure></p>
<p>prod_name<br>JetPack 1000<br>JetPack 2000<br>JetPack 3000<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">匹配几个字符之一</div></pre></td></tr></table></figure></p>
<p>select prod_name from products where prod_name regexp ‘[123] Ton’ order by prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">输出</div></pre></td></tr></table></figure></p>
<p>prod_name<br>1 ton anvil<br>2 ton anvil<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">select prod_name from products where prod_name regexp &apos;[^123] Ton&apos; order by prod_name;</div></pre></td></tr></table></figure></p>
<p>匹配除这些字符外的任何东西。<br>匹配范围[1-9]，[a-z]。<br>匹配特殊字符，必须以<code>\\</code>为前导。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select prod_name from products where </div><div class="line">prod_name regexp &apos;\\([0-9] sticks?\\)&apos;</div><div class="line">order by prod_name;</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">prod_name</div><div class="line">TNT (1 stick)</div><div class="line">TNT (7, sticks)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">select prod_name from products where </div><div class="line">prod_name regexp &apos;[[:digit:]]&#123;4&#125;&apos; order by prod_name;</div></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">prod_name</div><div class="line">JetPack 1000</div><div class="line">JetPack 2000</div></pre></td></tr></table></figure></p>
<p>定位符 <code>^, $, [[:&lt;:]], [[:&gt;:]]</code>。</p>
<h3 id="Chapter-10-创建计算字段"><a href="#Chapter-10-创建计算字段" class="headerlink" title="Chapter 10 创建计算字段"></a>Chapter 10 创建计算字段</h3><p>计算字段，比如城市、州、邮编的拼接，单价乘以数量，根据表数据进行总数、平均数或者其他的计算。计算字段也是一个字段，但是它并不存在于实际的数据库表中，计算字段是在运行时在select 语句内创建出来的。</p>
<h4 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h4><p>concatenate 将值连起来一起构成单个值。<br>MySQL 的不同之处，多数DBMS 使用+或||实现拼接，而MySQL则使用Concat()函数来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select concat(vend_name, &apos; (&apos;, vend_county, &apos;)&apos;) from vendors order by vend_name;</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">concat(vend_name, &apos; (&apos;, vend_county, &apos;)&apos;)</div><div class="line">ACME (USA)</div><div class="line">Anvil R us (USA)</div></pre></td></tr></table></figure></p>
<p>通过使用rtrim()函数来删除数据右侧多余的空格整理数据。<br>ltrim，trim。<br>使用别名，上面的语句工作得很好，但是在select语句内创建出来的计算字段并没有名称，不能被后续使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select concat(rtrim(vend_name), &apos; (&apos;, rtrim(vend_county), &apos;)&apos;) as vend_title from vendors order by vend_name;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vend_title</div><div class="line">ACME (USA)</div><div class="line">Anvil R us (USA)</div></pre></td></tr></table></figure>
<p>如今就像一个实际的表列一样。<br>别名还有其他的用处，包括在实际的表列名包含不符合规定的字符（如空格）时重新命名它，在原来的名字含混或者容易误解时扩充它。</p>
<h4 id="执行算术运算"><a href="#执行算术运算" class="headerlink" title="执行算术运算"></a>执行算术运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select prod_id, quantity, item_price from orderitems where order_num = 2005;</div></pre></td></tr></table></figure>
<p>检索出订单号为2005的订单包含的所有物品。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select prod_id, quantity, item_price, quantity * item_price as expanded_price </div><div class="line">from orderitems </div><div class="line">where order_num = 2005;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select 3*2; 6</div><div class="line">select trim(&apos; abc &apos;); abc</div><div class="line">select now(); 当前的日期与时间</div></pre></td></tr></table></figure>
<h3 id="Chapter-11-使用数据处理函数"><a href="#Chapter-11-使用数据处理函数" class="headerlink" title="Chapter 11 使用数据处理函数"></a>Chapter 11 使用数据处理函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">select vend_name, upper(vend_name) as vend_name_uppercase from vendors order by vend_name;</div><div class="line">``` </div><div class="line">#### 文本处理函数</div><div class="line">+ left</div><div class="line">+ right</div><div class="line">+ length</div><div class="line">+ locate</div><div class="line">+ lower</div><div class="line">+ upper</div><div class="line">+ ltrim</div><div class="line">+ rtrim</div><div class="line">+ trim</div><div class="line">+ substring</div><div class="line">+ soundex</div><div class="line"></div><div class="line">#### 日期和时间处理函数</div><div class="line">日期和时间采用相应的数据类型和特殊的格式存储，以便能够快速和有效地排序或过滤，并节省物理存储空间。</div><div class="line">一般地，应用程序并不直接处理、使用这样的格式，因此就需要日期和时间处理函数来读取、统计和处理这些值。由于这个原因，日期和时间处理函数在MySQL中具有重要的作用。</div><div class="line">常用的函数：</div><div class="line"></div><div class="line">+ adddate</div><div class="line">+ addtime</div><div class="line">+ curdate</div><div class="line">+ curtime</div><div class="line">+ date 返回日期时间的日期部分</div><div class="line">+ datediff 计算两个日期之差</div><div class="line">+ date_add</div><div class="line">+ date_format 返回一个格式化的日期或者时间字符串</div><div class="line">+ day</div><div class="line">+ dayofweek</div><div class="line">+ hour</div><div class="line">+ minute</div><div class="line">+ month</div><div class="line">+ now</div><div class="line">+ second</div><div class="line">+ time</div><div class="line">+ year</div><div class="line"></div><div class="line">首先需要注意的是MySQL使用的日期格式，无论你什么时候指定一个日期，不管是插入或者更新表值还是使用where子句进行过滤，日期都必须为 yyyy-mm-dd。</div></pre></td></tr></table></figure>
<p>select cust_id, order_num from orders where order_date = ‘2015-09-01’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">order_date 的数据类型是 datetime，这种类型存储日期及时间，因此&apos;2015-09-01&apos;匹配的是&apos;2015-09-01 00:00:00&apos;。</div><div class="line">如果是要日期请使用date()函数。</div></pre></td></tr></table></figure></p>
<p>select cust_id, order_num from orders where date(order_date) = ‘2015-09-01’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">使用 date 是一个良好的习惯，即使你知道相应的列只包含日期也是如此，这样由于某种原因表中以后有日期和时间值，你的SQL代码也不用修改。</div></pre></td></tr></table></figure></p>
<p>select cust_id, order_num from orders where date(order_date) between ‘2015-09-01’ and ‘2005-09-30’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 数值处理函数</div><div class="line">+ abs </div><div class="line">+ cos</div><div class="line">+ exp</div><div class="line">+ mod</div><div class="line">+ pi</div><div class="line">+ rand</div><div class="line">+ sin </div><div class="line">+ sqrt</div><div class="line">+ tan</div><div class="line"></div><div class="line">### Chapter 12 汇总数据</div><div class="line">聚集函数</div><div class="line">我们经常需要汇总数据而不用把它们实际检索出来，当需要的是对表中数据汇总而不是实际数据本身时，返回实际数据是对处理时间和处理资源的一种浪费，更不用说带宽了。</div><div class="line">MySQL 给出了5个聚集函数（aggregate function），聚集函数是运行在行组上，计算和返回单个值的函数。</div><div class="line"></div><div class="line">+ avg 返回某列的平均值</div><div class="line">+ count 返回某列的行数</div><div class="line">+ max 返回某列的最大值</div><div class="line">+ min 返回某列的最小值</div><div class="line">+ sum 返回某列值之和</div></pre></td></tr></table></figure></p>
<p>select avg(prod_price) as avg_price from products where vend_id = 1003;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">输出：</div></pre></td></tr></table></figure></p>
<p>avg_price<br>16.133571<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">avg 只能用于单个列，为了获得多个列的平均值，必须使用多个avg函数，avg 函数会自动忽略null的行。</div><div class="line">count 函数有两种使用方式：</div><div class="line">1. 使用 count(\*) 对表中行的数目进行计数，不管表列中包含的是空值还是非空值。</div><div class="line">2. 使用 count(column) 对特定列中具有值的行进行计数，忽略null值。</div></pre></td></tr></table></figure></p>
<p>select count(*) as num_cust from customers;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sum 函数</div></pre></td></tr></table></figure></p>
<p>select sum(item_price*quantity) as total_price from orderitems where order_num = 2005;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">聚集不同值</div></pre></td></tr></table></figure></p>
<p>select avg(distinct prod_price) as avg_price from products where vend_id = 1003;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">all 为默认值。</div><div class="line">聚集函数组合</div></pre></td></tr></table></figure></p>
<p>select count(*) as num_items,<br>    min(prod_price) as price_min,<br>    max(prod_price) as price_max,<br>    avg(prod_price) as price_avg<br>from products;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### Chapter 13 分组数据</div><div class="line">这涉及到两个 select 语句子句，分别是 group by 和 having。</div><div class="line">在上一章汇总数据时，是在表的所有数据或匹配特定的where子句的数据上进行的。</div></pre></td></tr></table></figure></p>
<p>select vend_id, count(*) as num_prods from products group by vend_id;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">输出</div></pre></td></tr></table></figure></p>
<p>vend_id num_prods<br>1001 3<br>1002 2<br>1003 7<br>1005 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">group by 的注意：</div><div class="line">1. 可以嵌套</div><div class="line">2. **除了聚集计算语句外，select语句中的每个列都必须在 group by 子句中给出**</div><div class="line">3. 如果分组列中有null值，则null将作为一个分组返回。</div><div class="line">4. group by 子句必须出现在where 子句之后，order by 子句之前。</div><div class="line"></div><div class="line">#### 过滤分组</div><div class="line">MySQL 允许过滤分组，规定包括哪些分组，排除哪些分组，例如，可能想要列出至少有两个订单的所有顾客，为了得到这个结果，必须基于用户分组进行计数并过滤而不是个别的行进行过滤。</div><div class="line">where 可以基于行而不是分组进行过滤，事实上，where 没有分组的概念。</div><div class="line">使用 having， having 非常类似where，事实上，目前为止所学的所有类型的where子句都用在having中来，唯一的差别是having 是过滤分组。</div><div class="line">having 支持所有where 操作符。</div></pre></td></tr></table></figure></p>
<p>select cust_id, count(<em>) as orders from orders group by cust_id having count(</em>) &gt;= 2;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">select vend_id, count(*) as num_prods from products where prod_price &gt;= 10</div><div class="line">group by vend_id having count(*) &gt;= 2;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">select order_num, sum(quantity*item_price) as ordertotal </div><div class="line">from orderitems</div><div class="line">group by order_num </div><div class="line">having sum(quantity*item_price) &gt;= 50</div><div class="line">order by ordertotal;</div></pre></td></tr></table></figure>
<p>having 子句中使用 <code>sum(quantity*item_price)</code>，而order by 子句中使用 ordertotal ，这是因为这两个子句分别运行于 as 子句之前和之后。</p>
<h3 id="Chapter-14-使用子查询"><a href="#Chapter-14-使用子查询" class="headerlink" title="Chapter 14 使用子查询"></a>Chapter 14 使用子查询</h3><p>子查询嵌套在其他查询中的查询。<br>orderitems&lt;-orders-&gt;customers<br>要求列出订购物品TNT2的所有客户：<br>需要三条查询语句</p>
<ol>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select order_num from orderitems where prod_id = &apos;TNT2&apos;;</div><div class="line">order_num</div><div class="line">20005</div><div class="line">20007</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select cust_id from orders where order_num in (20005, 20007);</div><div class="line">cust_id</div><div class="line">10001</div><div class="line">10004</div></pre></td></tr></table></figure>
</li>
</ol>
<p>3.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select cust_name, cust_contact from customers where cust_id in (10001, 10004);</div><div class="line">``` </div><div class="line">也可以使用一条语句</div></pre></td></tr></table></figure></p>
<p>select cust_name, cust_contact from customers where cust_id in (<br>    select cust_id from orders where order_num in (<br>        select order_num from orderitems where prod_id = ‘TNT2’<br>    )<br>);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">**列必须匹配： 在where子句中使用子查询， 应该保证select语句具有与where子句中相同数目的列，通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列。**</div><div class="line">子查询及其性能，这里给出的代码有效并获得了所需的结果，但是，使用子查询并不总是执行这种类型的数据检索的最有效的方法。</div><div class="line">#### 子查询结果作为计算字段使用</div></pre></td></tr></table></figure></p>
<p>select cust_name, cust_state,<br>    (select count(*) from orders where orders.cust_id = customers.cust_id) as orders<br>from customers order by cust_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">子查询及其性能，这里给出的代码有效并获得了所需的结果，但是，使用子查询并不总是执行这种类型的数据检索的最有效的方法。</div><div class="line">逐渐增加子查询来建立查询，首先，建立和测试最内层的查询，然后，用硬编码数据建立和测试外层查询，并且仅在确认它正常后才嵌入子查询，这时再次测试它。</div><div class="line"></div><div class="line">### Chapter 15 联结表</div><div class="line">SQL 最强大的功能之一就是能在数据检索查询的执行中联结 (join) 表。</div><div class="line">外键 (foreign key)，外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系：</div><div class="line">这样做的好处是：</div><div class="line">1. 数据不重复，节省空间。</div><div class="line">2. 信息变动时，可以只更新一个表中的单个记录，相关表中的数据不用改动。</div><div class="line">3. 数据的一致性好。</div></pre></td></tr></table></figure></p>
<p>select vend_name, prod_name, prod_price<br>from vendors, products<br>where vendors.vend_id = products.vend_id<br>order by vend_name, prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">笛卡儿积 由没有联结条件的表关系返回的结果为笛卡儿积，检索出的行的数目为第一个表中的行数乘以第二个表中的行数。</div></pre></td></tr></table></figure></p>
<p>select vend_name, prod_name, prod_price<br>from vendors, products<br>order by vend_name, prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">因此应该确保所有的联结都有where子句。</div><div class="line"></div><div class="line">#### 内部联结</div><div class="line">目前为止所用的联结称为等值联结，它基于两个表之间的相等测试，这种联结也成为内部联结，其实这种联结可以使用稍微不同的语法来明确指定联结的类型，下面的语句与前面的例子返回完全相同的数据</div></pre></td></tr></table></figure></p>
<p>select vend_name, prod_name, prod_price<br>from vendors inner join products<br>on vendors.vend_id = products.vend_id<br>order by vend_name, prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 联结多个表</div></pre></td></tr></table></figure></p>
<p>select prod_name, vend_name, prod_price, quantity<br>from orderitems, products, vendors<br>where products.vend_id = vendors.vend_id<br>and orderitems.prod_id = products.prod_id<br>and order_num = 2005;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">正如第14章所述，子查询并不总是执行复杂select操作的最有效的方法，下面是使用联结的相同查询：</div></pre></td></tr></table></figure></p>
<p>select cust_name, cust_contact<br>from customers, orders, orderitems<br>where customers.cust_id = order.cust_id<br>and order.order_num = orderitems.order_num<br>and prod_id = ‘TNT2’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### Chapter 16 创建高级联结</div><div class="line">#### 使用表别名</div><div class="line">SQL 的别名除了用于列名和计算字段外，SQL还允许给表名起别名，这样做主要有两个主要理由：</div><div class="line">1. 缩短SQL语句</div><div class="line">2. 允许在单条select语句中多次使用相同的表</div></pre></td></tr></table></figure></p>
<p>select cust_name, cust_contact<br>from customers as c, orders as o, orderitems as oi<br>where c.cust_id = o.cust_id<br>and o.order_num = oi.order_num<br>and prod_id = ‘TNT2’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 使用不同类型的联结</div><div class="line">迄今为止，使用的仅是称为内部联结或等值联结的简单联结。</div><div class="line">现在看其他三种联结，分别为自联结，自然联结，外部联结。</div><div class="line">自联结，如前所述，使用表别名的主要原因是能在单条select语句中不止一次引用相同的表。</div><div class="line">假设发现某物品id为DTNTR存在问题，想知道生产该物品的供应商的其他物品是否也存在这些问题。即在同一个表中。</div><div class="line">一种解决方式是使用子查询：</div></pre></td></tr></table></figure></p>
<p>select prod_id, prod_name<br>from products<br>where vend_id = (select vend_id from products where prod_id = ‘DTNTR’);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">现在看使用联结的相同查询：</div></pre></td></tr></table></figure></p>
<p>select p1.prod_id, p1.prod_name<br>from products as p1, products as p2<br>where p1.vend_id = p2.vend_id<br>and p2.prod_id = ‘DTNTR’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">p1.prod_id, p1.prod_name，如果不这样，MySQL将返回错误信息，因为分别存在两个名为 prod_id, prod_name 的列，MySQL 不知道想要的是哪一列，即使事实上它们是同一列。</div><div class="line">自联结通常用于替代在相同表中检索数据的子查询语句，虽然最终的结果是相同的，但有时候处理联结远比处理子查询要快得多。</div><div class="line">##### 自然联结</div><div class="line">无论何时对表进行联结，至少应该有一个列出现在不止一个表中，被联结的列，标准的联结，前一章中的内部联结，返回所有数据，甚至相同的列多次出现，自然联结则排除多次出现，使每个列只返回一次。</div></pre></td></tr></table></figure></p>
<p>select c.*, o.order_num, o.order_date, oi.prod_id, oi.quantity, oi.item_price<br>from customers as c, orders as o, orderitems as oi<br>where c.cust_id = o.cust_id<br>and o.order_num = oi.order_num<br>and prod_id = ‘FB’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">在这个例子中，通配符只对第一个表使用，所有其他列明确列出，所以没有重复的列被检索出来。</div><div class="line">事实上，迄今为止，我们建立的每个内部联结都是自然联结，很有可能我们永远都不会用到不是自然联结的内部联结。</div><div class="line">##### 外部联结</div><div class="line">检索所有客户及其订单：</div></pre></td></tr></table></figure></p>
<p>select customers.cust_name, orders.order_num<br>from customers inner join orders<br>on customers.cust_id = orders.cust_id;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">外部联结语法类似，检索所有的用户，包括那些没有订单的用户：</div></pre></td></tr></table></figure></p>
<p>select customers.cust_name, orders.order_num<br>from customers left outer join orders<br>on customers.cust_id = orders.cust_id;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">在使用 outer join 时，必须使用right或者left指定包括其所有行的表。外部联结的类型，存在两种形式的外部联结，它们之间唯一的差别在于所关联的表的顺序不同，换句话说，左外部联结可以通过颠倒from 或者 where子句中的表的顺序转换为右外部联结。</div><div class="line"></div><div class="line">##### 使用带聚集函数的联结</div><div class="line">检索所有客户及其订单数：</div></pre></td></tr></table></figure></p>
<p>select customers.cust_name, customers.cust_id,<br>count(orders.order_num) as num_ord<br>from customers inner join orders<br>on customers.cust_id = orders.cust_id<br>group by customers.cust_id;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">输出：</div></pre></td></tr></table></figure></p>
<p>cust_name cust_id num_ord<br>….        ….    2<br>….        ….    1<br>….        ….    1<br>….        ….    1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>select customers.cust_name, customers.cust_id,<br>count(orders.order_num) as num_ord<br>from customers left outer join orders<br>on customers.cust_id = orders.cust_id<br>group by customers.cust_id;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">输出：</div></pre></td></tr></table></figure></p>
<p>cust_name cust_id num_ord<br>….        ….    2<br>….        ….    1<br>….        ….    0<br>….        ….    1<br>….        ….    1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### Chapter 17 组合查询 compound query</div><div class="line">利用 union 操作符将多条select语句组合成一个结果集。</div><div class="line">组合查询和多个where条件：</div><div class="line">多数情况下，组合相同表的两个查询与具有多个where条件子句的单条查询完成的工作是相同的。</div></pre></td></tr></table></figure></p>
<p>select vend_id, prod_id, prod_price<br>from products<br>where prod_price &lt;= 5<br>union<br>select vend_id, prod_id, prod_price<br>from products<br>where vend_id in (1001, 1002);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">等于</div></pre></td></tr></table></figure></p>
<p>select vend_id, prod_id, prod_price<br>from products<br>where prod_price &lt;= 5<br>or<br>vend_id in (1001, 1002);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">union 规则：</div><div class="line">1. union 中的每个查询必须包含相同的列，表达式或者聚集函数（不过各个列不需要以相同的次序列出）。</div><div class="line">2. 列数据类型必须兼容，类型不必完全相同，但必须是 DBMS可以隐含地转换类型。</div><div class="line"></div><div class="line">##### 对组合查询结果进行排序</div><div class="line">在 union 组合查询时，只能使用一条order by 子句，它必须出现在最后一条select语句之后。</div><div class="line"></div><div class="line">### Chapter 18 全文本搜索</div><div class="line">并非所有引擎都支持全文本搜索</div><div class="line">MySQL 支持几种基本的数据库引擎，两个最常使用的引擎为MyISAM 和 InnoDB，前者支持全文本搜索，而后者不支持，这就是为什么这本书创建的多数样例表使用 InnoDB，而一个样例表（productnotes表）却使用MyISAM的原因。</div><div class="line">like关键字和正则表达式这两个搜索机制非常有用，但是却存在几个重要的限制：</div><div class="line">1. 性能，这两个搜索极少使用表索引，因此，随着被搜索行数不断增加，这些搜索可能会非常耗时。</div><div class="line">2. 控制不明确</div><div class="line">2. 不够智能</div><div class="line">使用全文本搜索时，MySQL不要分别查看每个行，不需要分别分析处理每个词，MySQL创建指定列中各词的一个索引，搜索可以针对这些词进行，这样，MySQL可以快速有效地决定哪些词匹配（哪些行包含它们），哪些词不匹配，以及它们的匹配频率。</div><div class="line">为了进行全文本搜索，必须索引被搜索的列，而且要随着数据的改动不断地重新索引，在对表列进行适当设计后，MySQL会自动进行所有索引和重新索引。</div><div class="line">在索引之后，select 可与match 和 against 一起使用以实际执行搜索。</div><div class="line">一般在创建表时启用全文本搜索，create table 语句接受 fulltext子句，它给出一个被索引列的一个逗号分隔的列表。</div></pre></td></tr></table></figure></p>
<p>create table productnotes (<br>    note_id     int        not null auto_increment,<br>    prod_id     char(10)   not null,<br>    note_date   datetime   not null,<br>    node_text   text       null,<br>    primary key(note_id),<br>    fulltext(node_text)<br>) engine=myisam;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">进行全文本搜索</div></pre></td></tr></table></figure></p>
<p>select node_text from productnotes where<br>match(node_text) against(‘rabbit’);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">有两行包含词 rabbit，这两行被返回。</div><div class="line">上述的搜索可以简单的使用like子句完成</div></pre></td></tr></table></figure></p>
<p>select node_text from productnotes where node_text like ‘%rabbit%’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">两行都包含词 rabbit，但包含词 rabbit 作为第三个词的等级比作为第二十个词的等级高，全文搜索的一个重要特点就是具有较高等级的行优先返回。</div><div class="line">**....to do**</div><div class="line"></div><div class="line">### Chapter 19 插入数据</div><div class="line">毫无疑问，select 是最常用的SQL语句了，但是还有其他3个经常使用的SQL语句。</div><div class="line">insert 可以以几种方式使用：</div><div class="line"></div><div class="line">+ 插入完整的行</div><div class="line">+ 插入行的一部分</div><div class="line">+ 插入多行</div><div class="line">+ 插入某些查询结果</div><div class="line"></div><div class="line">**插入及系统安全：可针对每个表或每个用户，利用MySQL的安全机制禁止使用insert语句**</div></pre></td></tr></table></figure></p>
<p>insert into customers<br>values (<br>    null,<br>    ‘Pep E. LaPaw’,<br>    ‘100 Main Street’,<br>    ‘Los Angeles’,<br>    ‘CA’,<br>    ‘90046’,<br>    ‘USA’,<br>    NULL,<br>    NULL<br>);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">依序，第一列 cust_id 为 null，是因为这列是由MySQL自动增量的。</div><div class="line">这种语法很简单，但并不安全，高度依赖于表中列的定义次序，不能保证表结构变动后各个列保持完全相同的次序。更加安全也更加繁琐的方式是：</div></pre></td></tr></table></figure></p>
<p>insert into customers (<br>    cust_name,<br>    cust_address,<br>    cust_city,<br>    cust_state,<br>    cust_zip,<br>    cust_county,<br>    cust_contact,<br>    cust_email<br>    )<br>    values (<br>    ‘Pep E. LaPaw’,<br>    ‘100 Main Street’,<br>    ‘Los Angeles’,<br>    ‘CA’,<br>    ‘90046’,<br>    ‘USA’,<br>    NULL,<br>    NULL<br>);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">省略的列：</div><div class="line">1. NULL</div><div class="line">2. default value</div><div class="line">否则就会产生一条错误信息，并相应的行插入不成功。</div><div class="line">提高整体性能：</div><div class="line">insert 操作可能很耗时，特别是有很多索引需要更新时，而它可能降低等待处理的select语句的性能。</div><div class="line">如果数据检索是重要的，通常如此，则你需要通过在insert 和into 之间添加关键字low_priority，指示MySQL降低insert语句的优先级。这也适用于 update 和 delete语句。</div></pre></td></tr></table></figure></p>
<p>insert into customers (…)<br>values (…), (…);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">此技术可以提高数据库处理的性能，因为MySQL用单条insert语句处理多个插入比使用多条insert语句要快。</div><div class="line"></div><div class="line">#### 插入检索出的数据</div><div class="line">将一条select语句的结果插入表中，这就是所谓的insert select。</div></pre></td></tr></table></figure></p>
<p>insert into customers (…)<br>select … from custnew;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Insert select 列名不一定匹配，MySQL使用的是其位置。</div><div class="line"></div><div class="line">### Chapter 20 更新和删除数据</div><div class="line">update 有两种使用方式：</div><div class="line">1. 更新表中特定行</div><div class="line">2. 更新表中所有行</div><div class="line">**一定要用where子句**</div></pre></td></tr></table></figure></p>
<p>update customers<br>set cust_email = ‘elmer@fudd.com’, cust_name = ‘The Fudds’<br>where cust_id = 10005;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">在update中可以使用子查询，使得能用select语句检索出的数据更新数据。</div><div class="line">ignore 关键字，在使用 update 更新多行时，如果其中的一行或者多行出现一个错误，则整个update操作被取消，错误发生前更新的所有行将恢复到其原有的值，为了即使发生错误，也能继续进行更新，可用ignore关键字。</div><div class="line">update ignore customers...</div><div class="line">delete 有两种使用方式：</div><div class="line">1. 删除表中特定行</div><div class="line">2. 删除表中所有行</div><div class="line">**一定要用where子句**</div></pre></td></tr></table></figure></p>
<p>delete from customers where cust_id = 10006;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">删除的是内容而不是表，即便是删除了表中所有的行。</div><div class="line">更快的删除</div><div class="line">如果想从表中删除所有行，不要使用delete，可以使用truncate table，它完成相同的工作，但是速度更快，它实际上是删除了原来的表并重新创建了一个表，而不是逐行删除表中的数据。</div><div class="line">更新和删除的指导原则</div><div class="line">1. 在对update 或delete语句使用where子句前，首先使用select进行测试，保证其过滤的是正确的记录，以免编写的where子句不正确。</div><div class="line">2. 使用强制实施引用完整性的数据库，这样MySQL不允许删除与其他表相关联的数据行。</div><div class="line"></div><div class="line">### Chapter 21 创建和操纵表</div><div class="line">迄今为止，我们看到的都是以单个列作为主键，为创建由多个列组成的主键，应该以逗号分隔的列表给出各列名，如下所示：</div></pre></td></tr></table></figure></p>
<p>create table orderitems (<br>    order_num    int           not null,<br>    order_item   int           not null,<br>    prod_id      char(10)      not null,<br>    quantity     int           not null,<br>    item_price   decimal(8, 2) not null,<br>    primary key (order_num, order_item)<br>) engine=innodb;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">+ 主键唯一标识表中的一行</div><div class="line">+ 外键是表中的一列，唯一标识另外一个表中的一行。</div><div class="line"></div><div class="line">每个表只允许一个 auto_increment 列，而且它必须被索引（如，通过使它成为主键）。</div><div class="line">覆盖 auto_increment，如果一个列被指定为 auto_increment，你可以简单地在insert语句中指定一个值，只要它是唯一的(至今尚未使用过)即可，该值将被用来代替自动生成的值，后续的增量将开始使用该手工插入的值。</div><div class="line">`select last_insert_id()` 返回最后一个 auto_increment 值。</div><div class="line">指定默认值 `quantity int not null default 1`，与大多数DBMS不一样，MySQL不允许使用函数作为默认值，它只支持常量。</div><div class="line"></div><div class="line">#### 引擎类型</div><div class="line">具体管理和处理数据的内部引擎。</div><div class="line"></div><div class="line">+ InnoDB 是一个可靠的事务处理引擎，但它不支持全文本搜索。</div><div class="line">+ Memory 功能等同于 MyISAM，但是数据存储在内存，而不是磁盘中，速度很快，特别适合于临时表。</div><div class="line">+ MyISAM 是一个性能极高的引擎，不支持事务处理，但是支持全文本搜索。</div><div class="line"></div><div class="line">在同一个数据库中引擎可以混用，一个表用 MyISAM，另一个表用 InnoDB。</div><div class="line">外键不能跨引擎。</div><div class="line"></div><div class="line">#### alter 表</div><div class="line">alter table，但是理想状态下，当表中存储数据后，该表就不应该被alter，在表的设计过程中需要花费大量的时间来考虑，以便后期不对该表进行大的变动。</div></pre></td></tr></table></figure></p>
<p>alter table vendors<br>add vend_phone char(20);</p>
<p>alter table vendors<br>drop column vend_phone;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alter table 的一个常见用途是定义外键：</div></pre></td></tr></table></figure></p>
<p>alter table orderitems<br>add constraint fk_orderitems_orders<br>foreign key (order_num) references orders (order_num);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">小心使用alter table，数据表的更改不能撤销，如果增加了不需要的列，可能不能删除它们，类似地，如果删除了不应该删除的列，可能会丢失该列中的所有数据。</div><div class="line">删除表 `drop table customers2;`</div><div class="line">重命名表 `rename table customers2 to customers;`</div><div class="line"></div><div class="line">### Chapter 22 使用视图</div><div class="line">视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</div></pre></td></tr></table></figure></p>
<p>select cust_name, cust_contact<br>from customers, orders, orderitems<br>where customers.cust_id = order.cust_id<br>and order.order_num = orderitems.order_num<br>and prod_id = ‘TNT2’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">此查询用来检索订购了某个特定产品的客户，任何需要这个数据的人都必须理解相关表的结构，并知道如何创建查询和对表进行联结，为了检索其他的产品或者多个产品的相同数据，必须修改最后的where子句。</div><div class="line">现在，假如可以把整个查询包装成为一个 productcustomers 的虚拟表，则可以轻松地检索出相同的数据：</div></pre></td></tr></table></figure></p>
<p>select cust_name, cust_contact from<br>productcustomers<br>where prod_id = ‘TNT2’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">productcustomers 是一个视图，作为视图，它不包含表中应该有的任何列或者数据，它包含的是一个SQL 查询。</div><div class="line">#### 视图用处</div><div class="line">+ 重用 SQL 语句</div><div class="line">+ 简化复杂的 SQL 操作</div><div class="line">+ 使用表的组成部分而不是整个表</div><div class="line">+ 保护数据，可以给用户授予表的特定部分的访问权限而不是整个表的访问权限</div><div class="line">+ 更改数据格式和表示，视图可返回与底层表的数据格式和表示不同的数据</div><div class="line"></div><div class="line">在视图创建之后，可以用与表基本相同的方式利用它们，可以对视图执行select操作，过滤和排序数据，将视图联结到其他视图或者表，甚至能添加和更新数据（添加和更新数据存在某些限制），重要的是，在添加或者更改表中的数据时，视图将立即进行反映。</div><div class="line">视图的规则和限制：</div><div class="line">1. 视图可以嵌套</div><div class="line">2. order by 可以用在视图中，但如果从该视图检索数据的select 中也包含order by，那么该视图的order by 将被覆盖。</div><div class="line">3. 视图不能索引，也不能有关联的触发器或者默认值</div><div class="line">4. 为创建视图，必须有足够的访问权限，这些限制通常由数据库管理人员授予。</div><div class="line">5. 视图可以和表一起使用，例如编写一条联结表和视图的select语句。</div><div class="line"></div><div class="line">使用视图：</div><div class="line">1. 视图用 create view 语句来创建</div><div class="line">2. 使用 show create view viewname;来查看创建视图的语句。</div><div class="line">3. drop view viewname;</div><div class="line">4. 更新视图时，可以先用drop再用create，也可以直接用create or replace view。</div><div class="line"></div><div class="line">#### 利用视图简化复杂的联结</div><div class="line">视图的最常用的应用之一是隐藏复杂的SQL，这通常会涉及到联结。</div></pre></td></tr></table></figure></p>
<p>ceate view productcustomers as<br>select cust_name, cust_contact, prod_id<br>from customers, orders, orderitems<br>where customers.cust_id = orders.cust_id<br>and orders.order_num = orderitems.order_num;</p>
<p>select cust_name, cust_contact<br>from productcustomers<br>where prod_id = ‘TNT2’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 利用视图重新格式化检索出的数据</div></pre></td></tr></table></figure></p>
<p>select concat(rtrim(vend_name), ‘ (‘, rtrim(vend_county), ‘)’) as vend_title<br>from vendors<br>order by vend_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">现在假设经常需要这个格式的结果，创建视图，重用 SQL 语句。</div></pre></td></tr></table></figure></p>
<p>create view vendorlocations as<br>select concat(rtrim(vend_name), ‘ (‘, rtrim(vend_county), ‘)’) as vend_title<br>from vendors<br>order by vend_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">这样就可以在应用中使用 `select * from vendorlocations;`进行数据检索了，重用了SQL语句，简化了应用中的SQL语句，并且没有造成数据的重复。</div><div class="line"></div><div class="line">#### 用视图过滤不想要的数据</div><div class="line">可以定义 customeremaillist 视图，它过滤了没有电子邮件地址的用户。</div></pre></td></tr></table></figure></p>
<p>create view customeremaillist as<br>select cust_id, cust_name, cust_email<br>from customers<br>where cust_email is not null;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">此时可以在应用中通过`select * from customeremaillist;`进行检索了。</div><div class="line"></div><div class="line">#### 使用视图与计算字段</div></pre></td></tr></table></figure></p>
<p>create view orderitemsexpanded as<br>select order_num, prod_id, quantity, item_price quantity*item_price as expanded_price<br>from orderitems;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 更新视图</div><div class="line">视图是可更新的，即可以对其使用insert，update，delete，更新一个视图将更新其基表，可以回忆一下，视图本身并没数据，如果对视图增加或者删除行，实际上是对其基表增加或者删除行。</div><div class="line">但是并非所有的视图都是可更新的，基本上说，如果MySQL不能正确地确定被更新的基数据，则不允许更新，这实际上是说，如果视图中定义有如下的操作，则不能进行视图的更新：</div><div class="line"></div><div class="line">1. 分组 （使用 group by 和 having）</div><div class="line">2. 联结</div><div class="line">3. 子查询</div><div class="line">4. 并</div><div class="line">5. 聚集函数（min，max， count， sum等）</div><div class="line">6. distinct</div><div class="line">7. 导出（计算）列</div><div class="line"></div><div class="line">### Chapter 23 使用存储过程</div><div class="line">迄今为止，使用的大多数SQL语句都是针对一个或者多个表的**单条语句**，但是并非所有的操作都这么简单，经常会有一个完整的操作需要多条语句才能完成。</div><div class="line">那么如何编写此代码？可以单独编写每条语句，并根据结果有条件地执行另外的语句。在每次需要这个处理时，重复一遍如此的操作即可。</div><div class="line">可以创建存储过程，存储过程简单来说，就为以后使用而保存地一条或者多条MySQL语句的集合，可将其视为批处理文件。</div><div class="line">#### 为什么要使用存储过程？</div><div class="line">1. 把处理封装在容易使用的单元中</div><div class="line">2. 不需要反复建立一系列处理步骤，让所有开发人员和应用程序都使用同一存储过程的相同代码，防止错误，鲁棒性。</div><div class="line">3. 简化对变动的管理，如果表名、列名或者业务逻辑有变动，只需要更改存储过程的代码，使用的它人员甚至对于变动都没有察觉，增加安全性。</div><div class="line">4. 提高性能，因为使用存储过程要比使用单独的SQL语句要快。</div><div class="line">简单来说就是三点，简单，鲁棒，安全，高性能。</div><div class="line">不过将SQL语句转换为存储过程前，也必须知道其缺陷：</div><div class="line">1. 编写存储过程比基本的SQL语句复杂</div><div class="line">2. 可能没有创建存储过程的安全访问权限，很多数据库管理人员允许用户使用存储过程，但是不允许他们创建存储过程。</div><div class="line"></div><div class="line">#### 使用存储过程</div><div class="line">存储过程的执行称之为调用，call 接受存储过程的名字以及需要传递给它的任意参数</div></pre></td></tr></table></figure></p>
<p>call productpricing(<br>    @pricelow,<br>    @pricehigh,<br>    @priceaverage<br>    );<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 创建存储过程</div></pre></td></tr></table></figure></p>
<p>create procedure productpricing()<br>begin<br>    select avg(prod_price) as priceaverage<br>    from products;<br>end;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">call productpricing();</div><div class="line">priceaverage</div><div class="line">16.133571</div></pre></td></tr></table></figure></p>
<h4 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h4><p>存储过程被创建之后，被保存在服务器上以供使用，直至被删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">drop procedure productpricing;</div><div class="line">``` </div><div class="line"></div><div class="line">#### 使用参数</div><div class="line">productpricing 只是一个简单的存储过程，它简单地显示select语句的结果，一般，存储过程并不显示结果，而是把结果返回给你指定的变量。</div><div class="line">**变量内存中的一个特定位置，用来临时存储数据**</div><div class="line">以下是 productpricing 的修改版本，如果不先删除此存储过程，则不能再次创建它</div></pre></td></tr></table></figure></p>
<p>create procedure productpricing (<br>    out pl decimal(8, 2),<br>    out ph decimal(8, 2),<br>    out pa decimal(8, 2)<br>)<br>begin<br>    select min(prod_price)<br>    into pl<br>    from products;<br>    select max(prod_price)<br>    into ph<br>    from products;<br>    select avg(prod_price)<br>    into pa<br>    from products;<br>end;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">关键字 out 指出相应的参数用来从存储过程传出一个值（返回给调用者），MySQL 支持IN（传递给存储过程）、out（从存储过程传出）和inout（对存储过程传入和传出）。</div></pre></td></tr></table></figure></p>
<p>call productpricing(<br>    @pricelow,<br>    @pricehigh,<br>    @priceaverage<br>    );<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">由于此存储过程要求3个参数，因此必须正好传递3个参数，不多也不少，所以，这条call语句给出3个参数，存储过程将把结果保存进这三个变量中。</div></pre></td></tr></table></figure></p>
<p>select @priceaverage;<br>@priceaverage<br>16.133571428<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">下面是一个使用in和out参数的例子，ordertotal 接受订单号并返回该订单的合计：</div></pre></td></tr></table></figure></p>
<p>create procedure ordertotal (<br>    in onumber int,<br>    out ototal decimal(8, 2)<br>)<br>begin<br>    select sum(item_price*quantity)<br>    from orderitems<br>    where order_num = onumber<br>    into ototal;<br>end;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">call ordertotal(20005, @total);</div><div class="line">select @total;</div><div class="line">@total</div><div class="line">149.87</div></pre></td></tr></table></figure></p>
<h3 id="Chapter-24-使用游标"><a href="#Chapter-24-使用游标" class="headerlink" title="Chapter 24 使用游标"></a>Chapter 24 使用游标</h3><p>有时，需要在检索出来的行中前进或者后退一行或者多行，这就是使用游标的原因，cursor 是一个存储在MySQL服务器上的数据库查询，它不是一条select语句，而是被该语句检索出来的数据集，在得到了游标之后，应用程序可以根据需要滚动或者浏览其中的数据。游标主要应用于交互式应用，其中用户可以滚动数据并对数据进行浏览或者做出更改。<br>不像多数DBMS，MySQL游标只能用于存储过程和函数。</p>
<h4 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h4><ol>
<li>在能够使用游标前，必须定义它，这个过程实际上并没有检索数据，它只是定义要使用的select语句。</li>
<li>一旦定义之后，必须打开游标以供使用，这个过程用前面定义的select语句把实际数据检索出来了</li>
<li>对于填有数据的游标，根据需要取出各行</li>
<li>在结束游标使用之后，必须关闭游标。<br>在定义游标之后，可以按需频繁的打开和关闭游标，在游标打开之后，可按需频繁地执行取操作。</li>
</ol>
<h4 id="创建游标"><a href="#创建游标" class="headerlink" title="创建游标"></a>创建游标</h4><p>游标用declare 语句创建，并定义相应地select语句，根据需要带where和其他子句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">create procedure processorders()</div><div class="line">begin</div><div class="line">    declare ordernumbers cursor</div><div class="line">    for</div><div class="line">    select order_num from orders;</div><div class="line">end;</div></pre></td></tr></table></figure></p>
<h4 id="打开和关闭游标"><a href="#打开和关闭游标" class="headerlink" title="打开和关闭游标"></a>打开和关闭游标</h4><p>在处理open语句时执行查询，临时存储检索出的数据以供浏览和滚动。<br><code>open ordernumbers;</code><br>close 释放游标所使用的所有内部内存和资源，因此每个游标在不再需要时就应该关闭。<br><code>close ordernumbers;</code><br><strong>隐含关闭</strong>： 如果你不明确关闭游标，MySQL 将会在到达end语句时自动关闭它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">create procedure processorders()</div><div class="line">begin</div><div class="line">    -- declare the cursor</div><div class="line">    declare ordernumbers cursor</div><div class="line">    for</div><div class="line">    select order_num from orders;</div><div class="line"></div><div class="line">    -- open the cursor</div><div class="line">    open ordernumbers;</div><div class="line"></div><div class="line">    -- close the cursor</div><div class="line">    close ordernumbers;</div><div class="line">end;</div></pre></td></tr></table></figure></p>
<p>这个存储过程定义，打开和关闭了一个游标，但是对于检索出来的数据什么处理也没有做。</p>
<h4 id="使用游标数据"><a href="#使用游标数据" class="headerlink" title="使用游标数据"></a>使用游标数据</h4><p>在一个游标被打开之后，可以使用fetch语句分别访问它的每一行，fetch 指定检索什么数据（所需的列），检索出来的数据存储在什么地方，它还向前移动游标中的内部指针，使得下一条fetch语句检索的是下一行而不是同一行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">create procedure processorders()</div><div class="line">begin</div><div class="line">    -- declare local variable</div><div class="line">    declare o int;</div><div class="line"></div><div class="line">    -- declare the cursor</div><div class="line">    declare ordernumbers cursor</div><div class="line">    for</div><div class="line">    select order_num from orders;</div><div class="line"></div><div class="line">    -- open the cursor</div><div class="line">    open ordernumbers;</div><div class="line"></div><div class="line">    -- get order number</div><div class="line">    fetch ordernumbers into o;</div><div class="line">    </div><div class="line">    -- close the cursor</div><div class="line">    close ordernumbers;</div><div class="line">end;</div></pre></td></tr></table></figure></p>
<p>fetch 检索当前行的 order_num 列（自动从第一行开始）到一个名为 o 的局部变量中，对检索出的数据不做任何处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">create procedure processorders()</div><div class="line">begin</div><div class="line">    -- declare local variable</div><div class="line">    declare done boolean default 0;</div><div class="line">    declare o int;</div><div class="line"></div><div class="line">    -- declare the cursor</div><div class="line">    declare ordernumbers cursor</div><div class="line">    for</div><div class="line">    select order_num from orders;</div><div class="line"></div><div class="line">    -- declare continue handler</div><div class="line">    declare continue handler for sqlstate &apos;02000&apos; set done = 1;</div><div class="line"></div><div class="line">    -- open the cursor</div><div class="line">    open ordernumbers;</div><div class="line"></div><div class="line">    -- loop through all rows</div><div class="line">    repeat</div><div class="line"></div><div class="line">        -- get order number</div><div class="line">        fetch ordernumbers into o;</div><div class="line"></div><div class="line">    -- end of loop</div><div class="line">    until done end repeat;</div><div class="line"></div><div class="line">    -- close the cursor</div><div class="line">    close ordernumbers;</div><div class="line">end;</div></pre></td></tr></table></figure></p>
<p><code>declare continue handler for sqlstate &#39;02000&#39; set done = 1;</code>这条语句定义了一个 continue handler，它是在条件出现时被执行的代码，这里，它指出当 SQLSTATE 为 ‘02000’ 条件出现时，set done = 1。SQLSTATE ‘02000’ 是一个未找到条件，当 repeat 由于没有更多的行供循环时，就会出现这个条件。</p>
<p><strong>declare 语句的次序</strong>：declare 语句的发布存在特定的次序，用declare 语句定义的局部变量必须在定义在任意游标或句柄之前，而句柄必须定义在游标之后，不遵守此顺序将产生错误信息。<br>进一步修改的版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">create procedure processorders()</div><div class="line">begin</div><div class="line">    -- declare local variable</div><div class="line">    declare done boolean default 0;</div><div class="line">    declare o int;</div><div class="line">    declare t decimal(8, 2);</div><div class="line"></div><div class="line">    -- declare the cursor</div><div class="line">    declare ordernumbers cursor</div><div class="line">    for</div><div class="line">    select order_num from orders;</div><div class="line"></div><div class="line">    -- declare continue handler</div><div class="line">    declare continue handler for sqlstate &apos;02000&apos; set done = 1;</div><div class="line"></div><div class="line">    -- create a table to store the results</div><div class="line">    create table if not exists ordertotals (</div><div class="line">        order_num   int,</div><div class="line">        total       decimal(8, 2)</div><div class="line">    );</div><div class="line"></div><div class="line">    -- open the cursor</div><div class="line">    open ordernumbers;</div><div class="line"></div><div class="line">    -- loop through all rows</div><div class="line">    repeat</div><div class="line"></div><div class="line">        -- get order number</div><div class="line">        fetch ordernumbers into o;</div><div class="line"></div><div class="line">        -- get the total for this order </div><div class="line">        call ordertotal(o, t);</div><div class="line"></div><div class="line">        -- insert order and total into ordertotals</div><div class="line">        insert into ordertotals (order_num, total)</div><div class="line">        values (o, t);</div><div class="line"></div><div class="line">    -- end of loop</div><div class="line">    until done end repeat;</div><div class="line"></div><div class="line">    -- close the cursor</div><div class="line">    close ordernumbers;</div><div class="line">end;</div></pre></td></tr></table></figure></p>
<p>此存储过程不返回数据，但它能够创建和填充另一个表，可以查看该表：<br><code>select * from ordertotals;</code>。</p>
<h3 id="Chapter-25-使用触发器"><a href="#Chapter-25-使用触发器" class="headerlink" title="Chapter 25 使用触发器"></a>Chapter 25 使用触发器</h3><p>需要某条语句或者某些语句在事件发生时自动执行。<br>比如：</p>
<ul>
<li>每当增加一个顾客到某个数据库表时，都检查其电话号码格式是否正确，州的缩写是否大写；</li>
<li>每当订购一个产品时，都从库存数量中减去订购的数量</li>
<li>无论何时删除一行，都在某个存档表中保留一个副本</li>
</ul>
<p>所有的这些例子共同之处就是它们都需要在某个表发生变动时自动处理，触发器是MySQL响应以下任意语句时而自动执行的一条MySQL语句（或位于begin和end之间的一组语句）：</p>
<ul>
<li>update</li>
<li>insert</li>
<li>delete<br>其他语句不触发触发器。</li>
</ul>
<h4 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h4><ol>
<li>唯一的触发器名</li>
<li>触发器关联的表</li>
<li>触发器应该响应的活动（update insert delete）</li>
<li>触发器何时执行（处理之前或者处理之后）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">create trigger newproduct after insert on products</div><div class="line">for each row select &apos;Product added&apos;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>文本 Product added 将对每个插入的行显示一次。<br><strong>只有表才支持触发器，视图不支持，临时表也不支持。</strong><br>触发器按每个表每个事件每次地定义，每个表每个事件只允许一个触发器，每个表最多支持6个触发器，每条insert，update，delete的之前和之后，单一触发器不能与多个事件或者多个表关联，所以如果你需要一个对insert和update操作都触发的触发器，则应该定义两个触发器。<br><strong>触发器失败</strong>：如果before触发器失败，则mysql将不执行请求的操作，此外如果before触发器或者语句本身失败，MySQL将不执行after触发器。</p>
<h4 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">drop trigger newproduct;</div></pre></td></tr></table></figure>
<p>触发器不能更改或者覆盖，为了修改一个触发器，必须先删除它，然后再重新创建。</p>
<h4 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h4><h5 id="insert-触发器："><a href="#insert-触发器：" class="headerlink" title="insert 触发器："></a>insert 触发器：</h5><ol>
<li>在insert触发器代码内部可以引用一个名为NEW的虚拟表，访问被插入的行</li>
<li>在before insert触发器中，NEW中的值也可以被更新（允许更改被插入的值）</li>
<li>对于 auto_increment 列，new 在insert执行之前是0，在insert执行之后包含新的自动生成值。<br>比<code>select last_insert_id();</code>更好的方法是<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">create trigger neworder after insert on orders</div><div class="line">for each row select new.order_num;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>为了测试这个触发器<br><code>insert into orders (order_date, cust_id) values (now(), 10001);</code><br>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">order_num</div><div class="line">20010</div></pre></td></tr></table></figure></p>
<p><strong>before or after</strong>: 通常将before用于数据验证和净化，目的是保证插入表中的数据确实是需要的数据。</p>
<h5 id="delete触发器"><a href="#delete触发器" class="headerlink" title="delete触发器"></a>delete触发器</h5><p>在delete触发器代码内部，可以引用一个名为old的虚拟表，访问被删除的行。</p>
<h3 id="Chapter-26-管理事务处理"><a href="#Chapter-26-管理事务处理" class="headerlink" title="Chapter 26 管理事务处理"></a>Chapter 26 管理事务处理</h3><p>并不是所有的引擎都支持事务处理<br>transaction processing 可以用于维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。<br>几个常用的术语：</p>
<ol>
<li>事务 transaction 指一组SQL语句</li>
<li>回退 rollback 指撤销指定SQL语句的过程</li>
<li>提高 commit 指将未存储的SQL语句结果写入数据库表</li>
<li>保留点 savepoint 指事务处理中设置的临时占位符，你可以对它发布回退（与回退整个事务处理不同）</li>
</ol>
<h4 id="控制事务处理"><a href="#控制事务处理" class="headerlink" title="控制事务处理"></a>控制事务处理</h4><p>管理事务处理的关键在于将SQL语句组分解为逻辑块，并明确规定数据何时应该回退，何时不应该回退。<br>用<code>start transaction</code>标识事务的开始</p>
<h6 id="使用rollback-来回退MySQL语句"><a href="#使用rollback-来回退MySQL语句" class="headerlink" title="使用rollback 来回退MySQL语句"></a>使用rollback 来回退MySQL语句</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">select * from ordertotals;</div><div class="line">start transaction;</div><div class="line">delete from ordertotals;</div><div class="line">select * from ordertotals;</div><div class="line">rollback;</div><div class="line">select * from ordertotals;</div></pre></td></tr></table></figure>
<p>哪些语句可以回退？<br>事务处理用来管理insert，update，delete语句，不能回退create或者drop操作，事务处理块中可以使用这两条语句，但是如果你执行回退，它们不会被撤销。</p>
<h6 id="使用-commit"><a href="#使用-commit" class="headerlink" title="使用 commit"></a>使用 commit</h6><p>一般的MySQL语句都是直接针对数据库表执行和编写的，这就是所谓的隐含提交（implicit commit），即提交操作是自动进行的。<br>但是，在事务处理块中，提交不会隐含地进行，为明确地进行提交，使用commit语句，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">start transaction;</div><div class="line">delete from orderitems where order_num = 20010;</div><div class="line">delete from orders where order_num = 20010;</div><div class="line">commit;</div></pre></td></tr></table></figure></p>
<p>在这个例子中，从系统中完全删除订单20010，因为涉及到更新两个数据库表，所以使用事务处理块来保证订单不会被部分删除。最后地commit仅在不出错时写出更改，如果第一条delete起作用，但第二条语句失败，则delete会被撤销。<br>当commit或者rollback之后，事务会自动隐含关闭。</p>
<h5 id="使用保留点"><a href="#使用保留点" class="headerlink" title="使用保留点"></a>使用保留点</h5><p>简单的 rollback 和 commit 语句就可以写入或者撤销整个事务处理，但是更复杂的事务处理可能需要部分提交或者部分回退。<br>为了支持回退部分事务处理，必须在事务处理块中的合适位置放置占位符，这样，如果需要回退，可以回退到某个占位符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">savepoint delete1;</div><div class="line">....</div><div class="line">rollback to delete1;</div></pre></td></tr></table></figure></p>
<p>savepoint 越多越好。<br>保留点在事务处理完成（执行一条rollback或者commit）后自动释放，也可以使用release savepoint 来显式地释放保留点。<br>更改默认的提交行为，默认的MySQL行为是自动提交所有更改，为了指示MySQL不自动提交更改，需要使用以下语句<br><code>set autocommit = 0;</code><br>autocommit 标志是针对每个连接而不是服务器的。</p>
<h3 id="Chapter-28-安全管理"><a href="#Chapter-28-安全管理" class="headerlink" title="Chapter 28 安全管理"></a>Chapter 28 安全管理</h3><p>访问控制，MySQL服务器的安全基础是：用户对于他们需要的数据具有适当的访问权，既不能多也不能少。<br>不要使用root，应该严肃对待root登陆的使用，仅在绝对需要时使用它，或许在你不能登陆其他管理账号时使用，不应该在日常的MySQL操作中使用root。<br>MySQL 用户账号和信息存储在名为mysql的MySQL数据库中，一般不需要直接访问mysql数据库和表，但是有时需要直接访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use mysql;</div><div class="line">select user from user;</div></pre></td></tr></table></figure></p>
<h5 id="创建用户账号"><a href="#创建用户账号" class="headerlink" title="创建用户账号"></a>创建用户账号</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">create user ben identified by &apos;opop&apos;;</div></pre></td></tr></table></figure>
<p>使用 grant 或者 insert 也可以创建用户账号。但是为了安全起见，不建议直接对user表进行插入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rename user ben to bforta;</div><div class="line">...</div><div class="line">drop user bforta;</div></pre></td></tr></table></figure></p>
<p>MySQL 5 之前：自MySQL 5 以来，drop user 删除用户账号和所有相关的账号权限，在MySQL 5以前，drop user 只能用于删除用户账户，不能删除相关的权限，因此如果使用旧版本的MySQL，需要先revoke删除与账号相关的权限，然后再使用 drop user 删除账号。</p>
<h4 id="设置访问权限"><a href="#设置访问权限" class="headerlink" title="设置访问权限"></a>设置访问权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">show grants for bforta;</div><div class="line"></div><div class="line">Grants for bforta@%</div><div class="line">GRANT USAGE ON *.* TO &apos;bforta&apos;@&apos;%&apos;</div></pre></td></tr></table></figure>
<p>USAGE 表示根本没有任何权限，此结果表示在任意数据库和任意表上对任何东西都没有权限。<br>为了设置权限，使用grant语句，grant要求你至少给出以下信息：</p>
<ul>
<li>要授予的权限</li>
<li>被授予访问权限的数据库或表</li>
<li>用户名<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grant select on crashcourse.* to bforta;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>用户 bforta 对于 crashcourse 数据库中的所有数据具有只读访问权限。<br><code>show grants for bforta;</code>反映了这个更改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Grants for bforta@%</div><div class="line">GRANT USAGE ON *.* TO &apos;bforta&apos;@&apos;%&apos;</div><div class="line">GRANT SELECT ON &apos;crashcourse&apos;.* TO &apos;bforta&apos;@&apos;%&apos;</div></pre></td></tr></table></figure></p>
<p>grant 的反操作为 revoke，用它来撤销特定的权限，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">revoke select on crashcourse.* from bforta;</div></pre></td></tr></table></figure></p>
<p>被撤销的访问权限必须存在，否则就会出错。<br>grant 和 revoke 可在几个层次上控制访问权限：</p>
<ul>
<li>整个服务器，grant all 和 revoke all</li>
<li>整个数据库，使用 on database.*</li>
<li>特定的表，使用 on database.table</li>
<li>特定的列</li>
<li>特定的存储过程</li>
</ul>
<h3 id="Chapter-30-改善性能"><a href="#Chapter-30-改善性能" class="headerlink" title="Chapter 30 改善性能"></a>Chapter 30 改善性能</h3><p><strong>数据库管理员把他们生命中的相当一部分时间花在了调整、试验以及改善DBMS性能之上</strong>。在诊断应用的滞缓现象和性能问题时，性能不良的数据库以及数据库查询通常是最常见的祸因。</p>
<ul>
<li>调整内存分配，缓冲区大小，为了查看当前设置，可使用show variable;和show status;。</li>
<li>MySQL 是一个多用户多线程的DBMS，换言之，它经常同时执行多个任务，如果这些任务中的某一个执行缓慢，则所有请求都会执行缓慢，使用 show processlist; 显示所有活动进程以及它们的线程ID和执行时间，还可以使用kill命令终结某个特定的进程。</li>
<li>总是有不止一种方法编写同一条select语句，应该试验join，union，子查询等，找出最佳的方法。</li>
<li>使用explain 语句让MySQL 解释它将如何执行一条select语句</li>
<li>一般而言，存储过程执行得比逐条要快</li>
<li>应该总是使用正确的数据类型</li>
<li>绝不要检索比需求还要多的数据</li>
<li>有的操作（包括insert）支持一个可选的delayed关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。</li>
<li>在导入数据时，应该关闭自动提交，可以删除索引，包括fulltext索引，然后在导入完成后再重建它们。</li>
<li>必须索引数据库表以改善数据检索的性能确认索引挺难的，需要分析实用的select语句以找出重复的where和order by 子句，如果一个简单的where子句返回结果所需的时间太长，则可以判定其中使用的列或者几列就是需要索引的对象。</li>
<li>你的select 语句中有一系列复杂的or条件吗？通过使用多条select语句和连接它们的union语句，你能看到极大的性能提升。</li>
<li>索引可以改善数据检索的性能，但是损害数据插入、删除和更新的性能，如果一些表收集数据且不被经常检索，可以无需索引，索引可以按需添加和删除</li>
<li>like 很慢，一般来说，使用 fulltext 而不是 like。</li>
</ul>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/03/01/C-内存管理/">
                C++内存管理
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-03-01</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h2><p>内存管理在C++中无处不在，内存泄漏几乎在每个C++程序中都会发生，因此要想成为C++高手，内存管理一关是必须要过的，除非放弃C++，转到Java或者.NET，他们的内存管理基本是自动的，当然你也放弃了自由和对内存的支配权，还放弃了C++超绝的性能。<br>本期专题将从内存管理、内存泄漏、内存回收这三个方面来探讨C++内存管理问题。</p>
<h3 id="1-内存管理"><a href="#1-内存管理" class="headerlink" title="1. 内存管理"></a>1. 内存管理</h3><h4 id="1-1-C-内存管理详解"><a href="#1-1-C-内存管理详解" class="headerlink" title="1.1 C++内存管理详解"></a>1.1 C++内存管理详解</h4><h5 id="1-1-1-内存分配方式"><a href="#1-1-1-内存分配方式" class="headerlink" title="1.1.1 内存分配方式"></a>1.1.1 内存分配方式</h5><h5 id="1-1-1-1-分配方式简介"><a href="#1-1-1-1-分配方式简介" class="headerlink" title="1.1.1.1 分配方式简介"></a>1.1.1.1 分配方式简介</h5><p>　　在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。</p>
<p>　　栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>
<p>　　堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p>
<p>　　自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。</p>
<p>　　全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。</p>
<p>　　常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。</p>
<h6 id="1-1-1-2-明确区分堆与栈"><a href="#1-1-1-2-明确区分堆与栈" class="headerlink" title="1.1.1.2 明确区分堆与栈"></a>1.1.1.2 明确区分堆与栈</h6><p>首先，我们举一个例子：</p>
<p>void f() { int* p=new int[5]; }</p>
<p>　　这条短短的一句话就包含了堆与栈，看到new，我们首先就应该想到，我们分配了一块堆内存，那么指针p呢？他分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针p。在程序会先确定在堆中分配内存的大小，然后调用operator new分配内存，然后返回这块内存的首地址，放入栈中，他在VC6下的汇编代码如下：</p>
<p>00401028 push 14h</p>
<p>0040102A call operator new (00401060)</p>
<p>0040102F add esp,4</p>
<p>00401032 mov dword ptr [ebp-8],eax</p>
<p>00401035 mov eax,dword ptr [ebp-8]</p>
<p>00401038 mov dword ptr [ebp-4],eax</p>
<p>　　这里，我们为了简单并没有释放内存，那么该怎么去释放呢？是delete p么？澳，错了，应该是delete []p，这是为了告诉编译器：我删除的是一个数组，VC6就会根据相应的Cookie信息去进行释放内存的工作。</p>
<h6 id="1-1-1-3-堆和栈究竟有什么区别？"><a href="#1-1-1-3-堆和栈究竟有什么区别？" class="headerlink" title="1.1.1.3 堆和栈究竟有什么区别？"></a>1.1.1.3 堆和栈究竟有什么区别？</h6><p>堆和栈究竟有什么区别？<br>主要的区别由以下几点：</p>
<ol>
<li>管理方式不同；</li>
<li>空间大小不同；</li>
<li>能否产生碎片不同；</li>
<li>生长方向不同；</li>
<li>分配方式不同；</li>
<li>分配效率不同；<br>管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。<br>空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改：<br>打开工程，依次操作菜单如下：Project-&gt;Setting-&gt;Link，在Category 中选中Output，然后在Reserve中设定堆栈的最大值和commit。<br>注意：reserve最小值为4Byte；commit是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。<br>碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。<br>生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。<br>分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 alloca 函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。<br>分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。<br>从这里我们可以看到，堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP(扩展基址指针寄存器(extended base pointer) 其内存放一个指针，该指针指向系统栈最上面一个栈帧的底部)和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。<br>虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。<br>无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果。</li>
</ol>
<h5 id="1-1-2-控制C-的内存分配"><a href="#1-1-2-控制C-的内存分配" class="headerlink" title="1.1.2 控制C++的内存分配"></a>1.1.2 控制C++的内存分配</h5><p>在嵌入式系统中使用C++的一个常见问题是内存分配，即对 new 和 delete 操作符的失控。<br>具有讽刺意味的是，问题的根源却是C++对内存的管理非常的容易而且安全。具体地说，当一个对象被消除时，它的析构函数能够安全的释放所分配的内存。这当然是个好事情，但是这种使用的简单性使得程序员们过度使用new 和 delete，而不注意在嵌入式C++环境中的因果关系。并且，在嵌入式系统中，由于内存的限制，频繁的动态分配不定大小的内存会引起很大的问题以及堆破碎的风险。<br>作为忠告，保守的使用内存分配是嵌入式环境中的第一原则。但当你必须要使用new 和delete时，你不得不控制C++中的内存分配。<strong>你需要用一个全局的new 和delete来代替系统的内存分配符，并且一个类一个类的重载new 和delete。<br>一个防止堆破碎的通用方法是从不同固定大小的内存池中分配不同类型的对象。对每个类重载new 和delete就提供了这样的控制。</strong></p>
<h6 id="1-1-2-1-重载全局的new和delete操作符"><a href="#1-1-2-1-重载全局的new和delete操作符" class="headerlink" title="1.1.2.1 重载全局的new和delete操作符"></a>1.1.2.1 重载全局的new和delete操作符</h6><p>可以很容易地重载new 和 delete 操作符，如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void * operator new(size_t size)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">void *p = malloc(size);</div><div class="line"></div><div class="line">return (p);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">void operator delete(void *p);</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">free(p);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码可以代替默认的操作符来满足内存分配的请求。<br>也可以对单个类的new 和 delete 操作符重载。这是你能灵活的控制对象的内存分配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">class A</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    A(): name(&quot;Jasmine&quot;) &#123;&#125;;</div><div class="line">    ~A()&#123;&#125;;</div><div class="line">    void * operator new(size_t);</div><div class="line">    void operator delete(void*);</div><div class="line">    string name;</div><div class="line">&#125;;</div><div class="line">void * A::operator new(size_t size) &#123;</div><div class="line">    cout &lt;&lt; &quot;Newing&quot; &lt;&lt; endl;</div><div class="line">    void * p = malloc(size);</div><div class="line">    return p;</div><div class="line">&#125;</div><div class="line">void A::operator delete(void *p) &#123;</div><div class="line">    cout &lt;&lt; &quot;Deleting&quot; &lt;&lt; endl;</div><div class="line">    free(p);</div><div class="line">&#125;</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    A * a = new A;</div><div class="line">    cout &lt;&lt; a-&gt;name &lt;&lt; endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Newing</div><div class="line">Jasmine</div></pre></td></tr></table></figure></p>
<p>所有A 对象的内存分配都采用这段代码。更进一步，任何从A 继承的类也都采用这一方式，除非它自己也重载了new 和 delete 操作符。通过重载new 和 delete 操作符的方法，你可以自由地采用不同的分配策略，从不同的内存池中分配不同的类对象。</p>
<h6 id="1-1-2-2-为单个的类重载-new-和delete"><a href="#1-1-2-2-为单个的类重载-new-和delete" class="headerlink" title="1.1.2.2 为单个的类重载 new[ ]和delete[ ]"></a>1.1.2.2 为单个的类重载 new[ ]和delete[ ]</h6><p>必须小心对象数组的分配。你可能希望调用到被你重载过的new 和 delete 操作符，但并不如此。内存的请求被定向到全局的new[ ]和delete[ ] 操作符，而这些内存来自于系统堆。<br>C++将对象数组的内存分配作为一个单独的操作，而不同于单个对象的内存分配。为了改变这种方式，你同样需要重载new[ ] 和 delete[ ]操作符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class TestClass &#123;</div><div class="line">public:</div><div class="line">void * operator new[ ](size_t size);</div><div class="line">void operator delete[ ](void *p);</div><div class="line">// .. other members here ..</div><div class="line">&#125;;</div><div class="line"></div><div class="line">void *TestClass::operator new[ ](size_t size)</div><div class="line">&#123;</div><div class="line">void *p = malloc(size);</div><div class="line">return (p);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void TestClass::operator delete[ ](void *p)</div><div class="line">&#123;</div><div class="line">free(p);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">TestClass *p = new TestClass[10];</div><div class="line">// ... etc ...</div><div class="line">delete[ ] p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是注意，对于多数C++的实现，new[]操作符中的个数参数是数组的大小加上额外的存储对象数目的一些字节。在你的内存分配机制中要考虑的这一点。你应该尽量避免分配对象数组，从而使你的内存分配策略简单。</p>
<h5 id="1-1-3-常见的内存错误及其对策"><a href="#1-1-3-常见的内存错误及其对策" class="headerlink" title="1.1.3 常见的内存错误及其对策"></a>1.1.3 常见的内存错误及其对策</h5><p>发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。有时用户怒气冲冲地把你找来，程序却没有发生任何问题，你一走，错误又发作了。 常见的内存错误及其对策如下：</p>
<ol>
<li>内存分配未成功，却使用了它。<br>编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。</li>
<li>内存分配虽然成功，但是尚未初始化就引用它。<br>犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。</li>
<li>内存分配成功并且已经初始化，但操作越过了内存的边界。<br>例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。</li>
<li>忘记了释放内存，造成内存泄露。<br>含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。</li>
<li>释放了内存却继续使用它。<br>有三种情况：<ul>
<li>程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。</li>
<li>函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。</li>
<li>使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。<br>　　【规则1】用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。<br>　　【规则2】不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。<br>　　【规则3】避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。<br>　　【规则4】动态内存的申请与释放必须配对，防止内存泄漏。<br>　　【规则5】用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。</li>
</ul>
</li>
</ol>
<h5 id="1-1-4-指针与数组的对比"><a href="#1-1-4-指针与数组的对比" class="headerlink" title="1.1.4 指针与数组的对比"></a>1.1.4 指针与数组的对比</h5><p>C++/C程序中，指针和数组在不少地方可以相互替换着用，让人产生一种错觉，以为两者是等价的。<br>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而不是指向）一块内存，其地址与容量在生命期内保持不变，只有数组的内容可以改变。<br>指针可以随时指向任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。<br>下面以字符串为例比较指针与数组的特性。</p>
<h6 id="1-1-4-1-修改内容"><a href="#1-1-4-1-修改内容" class="headerlink" title="1.1.4.1 修改内容"></a>1.1.4.1 修改内容</h6><p>下面示例中，字符数组a的容量是6个字符，其内容为hello。a的内容可以改变，如a[0]= ‘X’。指针p指向常量字符串“world”（位于静态存储区，内容为world），常量字符串的内容是不可以被修改的。从语法上看，编译器并不觉得语句p[0]= ‘X’有什么不妥，但是该语句企图修改常量字符串的内容而导致运行错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">char a[] = &quot;hello&quot;;</div><div class="line">a[0] = &apos;X&apos;;</div><div class="line">cout &lt;&lt; a &lt;&lt; endl;</div><div class="line">char *p = &quot;world&quot;; // 注意p指向常量字符串</div><div class="line">p[0] = &apos;X&apos;; // 编译器不能发现该错误，有的编译器会报出警告：</div><div class="line">// warning: ISO C++ forbids converting a string constant to &apos;char*&apos; [-Wwrite-strings]</div><div class="line">// 编译能够通过，但是会导致运行时错误。</div><div class="line">cout &lt;&lt; p &lt;&lt; endl;</div></pre></td></tr></table></figure></p>
<h6 id="1-1-4-2-内容复制与比较"><a href="#1-1-4-2-内容复制与比较" class="headerlink" title="1.1.4.2 内容复制与比较"></a>1.1.4.2 内容复制与比较</h6><p>不能对数组名进行直接复制与比较。若想把数组a的内容复制给数组b，不能用语句 b = a ，否则将产生编译错误。应该用标准库函数strcpy进行复制。同理，比较b和a的内容是否相同，不能用if(b==a) 来判断，应该用标准库函数strcmp进行比较。<br>语句p = a 并不能把a的内容复制指针p，而是把a的地址赋给了p。要想复制a的内容，可以先用库函数malloc为p申请一块容量为strlen(a)+1个字符的内存，再用strcpy进行字符串复制。同理，语句if(p==a) 比较的不是内容而是地址，应该用库函数strcmp来比较。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 数组</div><div class="line">char a[] = &quot;hello&quot;;</div><div class="line">char b[10];</div><div class="line">strcpy(b, a); // 不能用 b = a;</div><div class="line">if(strcmp(b, a) == 0) // 不能用 if (b == a)</div><div class="line"></div><div class="line">// 指针</div><div class="line">int len = strlen(a);</div><div class="line">char *p = (char *)malloc(sizeof(char)*(len+1));</div><div class="line">strcpy(p,a); // 不要用 p = a;</div><div class="line">if(strcmp(p, a) == 0) // 不要用 if (p == a)</div></pre></td></tr></table></figure></p>
<h6 id="1-1-4-3-计算内存容量"><a href="#1-1-4-3-计算内存容量" class="headerlink" title="1.1.4.3 计算内存容量"></a>1.1.4.3 计算内存容量</h6><p>用运算符sizeof可以计算出数组的容量（字节数）。如下示例中，sizeof(a)的值是12（注意别忘了’’）。指针p指向a，但是sizeof(p)的值却是4。这是因为sizeof(p)得到的是一个指针变量的字节数，相当于sizeof(char*)，而不是p所指的内存容量。C++/C语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">char a[] = &quot;hello world&quot;;</div><div class="line">char *p = a;</div><div class="line">cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12字节</div><div class="line">cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4字节</div></pre></td></tr></table></figure></p>
<p>注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。如下示例中，不论数组a的容量是多少，sizeof(a)始终等于sizeof(char *)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">void Func(char a[100])</div><div class="line">&#123;</div><div class="line">　cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4字节而不是100字节</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="1-1-5-杜绝“野指针”"><a href="#1-1-5-杜绝“野指针”" class="headerlink" title="1.1.5 杜绝“野指针”"></a>1.1.5 杜绝“野指针”</h5><p>“野指针”不是NULL指针，是指向“垃圾”内存的指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，if语句对它不起作用。 “野指针”的成因主要有两种：</p>
<ol>
<li><p>指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">char *p = NULL;</div><div class="line">char *str = (char *) malloc(100);</div></pre></td></tr></table></figure>
</li>
<li><p>指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。</p>
</li>
<li>指针操作超越了变量的作用域范围。这种情况让人防不胜防，示例程序如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">class A</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    void Func(void)&#123; cout &lt;&lt; &quot;Func of class A&quot; &lt;&lt; endl; &#125;</div><div class="line">&#125;;</div><div class="line">void Test(void)</div><div class="line">&#123;</div><div class="line">    A *p;</div><div class="line">    &#123;</div><div class="line">        A a;</div><div class="line">        p = &amp;a; // 注意 a 的生命期</div><div class="line">    &#125;</div><div class="line">    p-&gt;Func(); // p是“野指针”</div><div class="line">&#125;</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    Test();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>函数Test在执行语句p-&gt;Func()时，对象a已经消失，而p是指向a的，所以p就成了“野指针”。但奇怪的是我运行这个程序时居然没有出错，这可能与编译器有关。</p>
<h5 id="1-1-7-有了malloc-free为什么还要new-delete？"><a href="#1-1-7-有了malloc-free为什么还要new-delete？" class="headerlink" title="1.1.7 有了malloc/free为什么还要new/delete？"></a>1.1.7 有了malloc/free为什么还要new/delete？</h5><p>malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。<br>对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不能够把执行构造函数和析构函数的任务强加于malloc/free。</p>
<p>因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。我们先看一看malloc/free和new/delete如何实现对象的动态内存管理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Obj</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Obj(void)&#123; cout &lt;&lt; &quot;Initialization&quot; &lt;&lt; endl; &#125;</div><div class="line">    ~Obj(void)&#123; cout &lt;&lt; &quot;Destroy&quot; &lt;&lt; endl; &#125;</div><div class="line">    void Initialize(void)&#123; cout &lt;&lt; &quot;Initialization&quot; &lt;&lt; endl; &#125;</div><div class="line">    void Destroy(void)&#123; cout &lt;&lt; &quot;Destroy&quot; &lt;&lt; endl; &#125;</div><div class="line">&#125;;</div><div class="line">void UseMallocFree(void)</div><div class="line">&#123;</div><div class="line">    Obj *a = (Obj *)malloc(sizeof(Obj)); // 申请动态内存</div><div class="line">    a-&gt;Initialize(); // 初始化</div><div class="line">    //…</div><div class="line">    a-&gt;Destroy(); // 清除工作</div><div class="line">    free(a); // 释放内存</div><div class="line">&#125;</div><div class="line">void UseNewDelete(void)</div><div class="line">&#123;</div><div class="line">    Obj *a = new Obj; // 申请动态内存并且初始化</div><div class="line">    //…</div><div class="line">    delete a; // 清除并且释放内存</div><div class="line">&#125;</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    UseNewDelete();</div><div class="line">    UseMallocFree();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="1-1-8-内存耗尽怎么办？"><a href="#1-1-8-内存耗尽怎么办？" class="headerlink" title="1.1.8 内存耗尽怎么办？"></a>1.1.8 内存耗尽怎么办？</h5><p>如果在申请动态内存时找不到足够大的内存块，malloc和new将返回NULL指针，宣告内存申请失败。通常有三种方式处理“内存耗尽”问题。</p>
<ol>
<li>判断指针是否为NULL，如果是则马上用return语句终止本函数。</li>
<li>判断指针是否为NULL，如果是则马上用exit(1)终止整个程序的运行。</li>
<li>为new和malloc设置异常处理函数。例如Visual C++可以用_set_new_hander函数为new设置用户自己定义的异常处理函数，也可以让malloc享用与new相同的异常处理函数。</li>
</ol>
<h5 id="1-1-9-new-delete的使用要点"><a href="#1-1-9-new-delete的使用要点" class="headerlink" title="1.1.9 new/delete的使用要点"></a>1.1.9 new/delete的使用要点</h5><p>如果用new创建对象数组，那么只能使用对象的无参数构造函数。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Obj *objects = new Obj[100]; // 创建100个动态对象</div><div class="line">不能写成：</div><div class="line">Obj *objects = new Obj[100](1);// 创建100个动态对象的同时赋初值1</div></pre></td></tr></table></figure></p>
<h4 id="1-2-C-中的健壮指针和资源管理"><a href="#1-2-C-中的健壮指针和资源管理" class="headerlink" title="1.2 C++中的健壮指针和资源管理"></a>1.2 C++中的健壮指针和资源管理</h4><h4 id="2-3浅谈C-C-内存泄漏及其检测工具"><a href="#2-3浅谈C-C-内存泄漏及其检测工具" class="headerlink" title="2.3浅谈C/C++内存泄漏及其检测工具"></a>2.3浅谈C/C++内存泄漏及其检测工具</h4><h5 id="2-3-1-内存泄漏的定义"><a href="#2-3-1-内存泄漏的定义" class="headerlink" title="2.3.1 内存泄漏的定义"></a>2.3.1 内存泄漏的定义</h5><p>一般我们常说的内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的，大小任意的（内存块的大小可以在程序运行期决定），使用完后必须显示释放的内存。应用程序一般使用malloc，realloc，new等函数从堆中分配到一块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了。<br>广义的说，内存泄漏不仅仅包含堆内存的泄漏，还包含系统资源的泄漏(resource leak)，比如核心态HANDLE，GDI Object，SOCKET， Interface等，从根本上说这些由操作系统分配的对象也消耗内存，如果这些对象发生泄漏最终也会导致内存的泄漏。而且，某些对象消耗的是核心态内存，这些对象严重泄漏时会导致整个操作系统不稳定。所以相比之下，系统资源的泄漏比堆内存的泄漏更为严重。</p>
<h5 id="2-3-3-检测内存泄漏"><a href="#2-3-3-检测内存泄漏" class="headerlink" title="2.3.3 检测内存泄漏"></a>2.3.3 检测内存泄漏</h5><p>　　检测内存泄漏的关键是要能截获住对分配内存和释放内存的函数的调用。截获住这两个函数，我们就能跟踪每一块内存的生命周期，比如，每当成功的分配一块内存后，就把它的指针加入一个全局的list中；每当释放一块内存，再把它的指针从list中删除。这样，当程序结束的时候，list中剩余的指针就是指向那些没有被释放的内存。这里只是简单的描述了检测内存泄漏的基本原理，详细的算法可以参见Steve Maguire的&lt;<writing solid="" code="">&gt;。<br>　　如果要检测堆内存的泄漏，那么需要截获住malloc/realloc/free和new/delete就可以了（其实new/delete最终也是用malloc/free的，所以只要截获前面一组即可）。对于其他的泄漏，可以采用类似的方法，截获住相应的分配和释放函数。比如，要检测BSTR的泄漏，就需要截获SysAllocString/SysFreeString；要检测HMENU的泄漏，就需要截获CreateMenu/ DestroyMenu。（有的资源的分配函数有多个，释放函数只有一个，比如，SysAllocStringLen也可以用来分配BSTR，这时就需要截获多个分配函数）<br>　　在Windows平台下，检测内存泄漏的工具常用的一般有三种，MS C-Runtime Library内建的检测功能；外挂式的检测工具，诸如，Purify，BoundsChecker等；利用Windows NT自带的Performance Monitor。这三种工具各有优缺点，MS C-Runtime Library虽然功能上较之外挂式的工具要弱，但是它是免费的；Performance Monitor虽然无法标示出发生问题的代码，但是它能检测出隐式的内存泄漏的存在，这是其他两类工具无能为力的地方。</writing></p>
<h6 id="2-3-3-1-VC下内存泄漏的检测方法"><a href="#2-3-3-1-VC下内存泄漏的检测方法" class="headerlink" title="2.3.3.1 VC下内存泄漏的检测方法"></a>2.3.3.1 VC下内存泄漏的检测方法</h6><p>用 MFC 开发的应用程序，在DEBUG版模式下编译后，都会自动加入内存泄漏的检测代码。在程序结束后，如果发生了内存泄漏，在Debug窗口中会显示出所有发生泄漏的内存块的信息，以下两行显示了一块被泄漏的内存块的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">E:&quot;TestMemLeak&quot;TestDlg.cpp(70) : &#123;59&#125; normal block at 0x00881710, 200 bytes long.</div><div class="line"></div><div class="line">Data: &lt;abcdefghijklmnop&gt; 61 62 63 64 65 66 67 68 69 6A 6B 6C 6D 6E 6F 70</div></pre></td></tr></table></figure></p>
<p>第一行显示该内存块由TestDlg.cpp文件，第70行代码分配，地址在0x00881710，大小为200字节，{59}是指调用内存分配函数的Request Order，关于它的详细信息可以参见MSDN中_CrtSetBreakAlloc()的帮助。第二行显示该内存块前16个字节的内容，尖括号内是以ASCII方式显示，接着的是以16进制方式显示。<br>一般大家都误以为这些内存泄漏的检测功能是由MFC提供的，其实不然。MFC只是封装和利用了MS C-Runtime Library的Debug Function。非MFC程序也可以利用MS C-Runtime Library的Debug Function加入内存泄漏的检测功能。MS C-Runtime Library在实现malloc/free，strdup等函数时已经内建了内存泄漏的检测功能。</p>
<p>注意观察一下由MFC Application Wizard生成的项目，在每一个cpp文件的头部都有这样一段宏定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#ifdef _DEBUG</div><div class="line"></div><div class="line">#define new DEBUG_NEW</div><div class="line"></div><div class="line">#undef THIS_FILE</div><div class="line"></div><div class="line">static char THIS_FILE[] = __FILE__;</div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>注：这里的 static 是很有意义的，仅限于此编译单元的语义使得，每个实现文件即调用new的文件中的代码都能正确的知道各自所在的不同文件名。<br>有了这样的定义，在编译DEBUG版时，出现在这个cpp文件中的所有new都被替换成DEBUG_NEW了。那么DEBUG_NEW是什么呢？DEBUG_NEW也是一个宏，以下摘自afx.h，1632行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define DEBUG_NEW new(THIS_FILE, __LINE__)</div></pre></td></tr></table></figure></p>
<p>所以如果有这样一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">char* p = new char[200];</div></pre></td></tr></table></figure></p>
<p>经过宏替换就变成了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">char* p = new( THIS_FILE, __LINE__)char[200];</div></pre></td></tr></table></figure></p>
<p>根据C++的标准，对于以上的new的使用方法，编译器会去找这样定义的operator new：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void* operator new(size_t, LPCSTR, int)</div></pre></td></tr></table></figure></p>
<p>我们在afxmem.cpp 63行找到了一个这样的operator new 的实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">void* AFX_CDECL operator new(size_t nSize, LPCSTR lpszFileName, int nLine)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">　return ::operator new(nSize, _NORMAL_BLOCK, lpszFileName, nLine);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">void* __cdecl operator new(size_t nSize, int nType, LPCSTR lpszFileName, int nLine)</div><div class="line"></div><div class="line">&#123;</div><div class="line"></div><div class="line">　…</div><div class="line"></div><div class="line">　pResult = _malloc_dbg(nSize, nType, lpszFileName, nLine);</div><div class="line"></div><div class="line">　if (pResult != NULL)</div><div class="line"></div><div class="line">　　return pResult;</div><div class="line"></div><div class="line">　…</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二个 operator new 函数比较长，为了简单期间，我只摘录了部分。很显然最后的内存分配还是通过_malloc_dbg函数实现的，这个函数属于MS C-Runtime Library 的Debug Function。这个函数不但要求传入内存的大小，另外还有文件名和行号两个参数。文件名和行号就是用来记录此次分配是由哪一段代码造成的。如果这块内存在程序结束之前没有被释放，那么这些信息就会输出到Debug窗口里。<br>这里顺便提一下<code>THIS_FILE</code>，<code>__FILE</code>和<code>__LINE__</code>。<code>__FILE__</code>和<code>__LINE__</code>都是编译器定义的宏。当碰到<code>__FILE__</code>时，编译器会把<code>__FILE__</code>替换成一个字符串，这个字符串就是当前在编译的文件的路径名。当碰到<code>__LINE__</code>时，编译器会把<code>__LINE__</code>替换成一个数字，这个数字就是当前这行代码的行号。在DEBUG_NEW的定义中没有直接使用<code>__FILE__</code>，而是用了<code>THIS_FILE</code>，其目的是为了减小目标文件的大小。假设在某个cpp文件中有100处使用了new，如果直接使用<code>__FILE__</code>，那编译器会产生100个常量字符串，这100个字符串都是文件的路径名，显然十分冗余。如果使用<code>THIS_FILE</code>，编译器只会产生一个常量字符串，那100处new的调用使用的都是指向常量字符串的指针。<br>再次观察一下由MFC Application Wizard生成的项目，我们会发现在cpp文件中只对new做了映射，如果你在程序中直接使用malloc函数分配内存，调用malloc的文件名和行号是不会被记录下来的。如果这块内存发生了泄漏，MS C-Runtime Library仍然能检测到，但是当输出这块内存块的信息，不会包含分配它的的文件名和行号。<br>要在非MFC程序中打开内存泄漏的检测功能非常容易，你只要在程序的入口处加入以下几行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );</div><div class="line"></div><div class="line">tmpFlag |= _CRTDBG_LEAK_CHECK_DF;</div><div class="line"></div><div class="line">_CrtSetDbgFlag( tmpFlag );</div></pre></td></tr></table></figure></p>
<p>这样，在程序结束的时候，也就是winmain，main或dllmain函数返回之后，如果还有内存块没有释放，它们的信息会被打印到Debug窗口里。<br>如果你试着创建了一个非MFC应用程序，而且在程序的入口处加入了以上代码，并且故意在程序中不释放某些内存块，你会在Debug窗口里看到以下的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;47&#125; normal block at 0x00C91C90, 200 bytes long.</div><div class="line"></div><div class="line">Data: &lt; &gt; 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F</div></pre></td></tr></table></figure></p>
<p>内存泄漏的确检测到了，但是和上面MFC程序的例子相比，缺少了文件名和行号。对于一个比较大的程序，没有这些信息，解决问题将变得十分困难。<br>为了能够知道泄漏的内存块是在哪里分配的，你需要实现类似MFC的映射功能，把new，maolloc等函数映射到_malloc_dbg函数上。这里我不再赘述，你可以参考MFC的源代码。<br>由于Debug Function实现在MS C-RuntimeLibrary中，所以它只能检测到堆内存的泄漏，而且只限于malloc，realloc或strdup等分配的内存，而那些系统资源，比如HANDLE，GDI Object，或是不通过C-Runtime Library分配的内存，比如VARIANT，BSTR的泄漏，它是无法检测到的，这是这种检测法的一个重大的局限性。另外，为了能记录内存块是在哪里分配的，源代码必须相应的配合，这在调试一些老的程序非常麻烦，毕竟修改源代码不是一件省心的事，这是这种检测法的另一个局限性。<br>对于开发一个大型的程序，MS C-Runtime Library提供的检测功能是远远不够的。接下来我们就看看外挂式的检测工具。我用的比较多的是BoundsChecker，一则因为它的功能比较全面，更重要的是它的稳定性。这类工具如果不稳定，反而会忙里添乱。到底是出自鼎鼎大名的NuMega，我用下来基本上没有什么大问题。</p>
<h6 id="2-3-3-2-使用BoundsChecker检测内存泄漏"><a href="#2-3-3-2-使用BoundsChecker检测内存泄漏" class="headerlink" title="2.3.3.2 使用BoundsChecker检测内存泄漏"></a>2.3.3.2 使用BoundsChecker检测内存泄漏</h6><p>BoundsChecker采用一种被称为 Code Injection的技术，来截获对分配内存和释放内存的函数的调用。简单地说，当你的程序开始运行时，BoundsChecker的DLL被自动载入进程的地址空间（这可以通过system-level的Hook实现），然后它会修改进程中对内存分配和释放的函数调用，让这些调用首先转入它的代码，然后再执行原来的代码。BoundsChecker在做这些动作的时，无须修改被调试程序的源代码或工程配置文件，这使得使用它非常的简便、直接。<br>这里我们以malloc函数为例，截获其他的函数方法与此类似。<br>需要被截获的函数可能在DLL中，也可能在程序的代码里。比如，如果静态连结C-Runtime Library，那么malloc函数的代码会被连结到程序里。为了截获住对这类函数的调用，BoundsChecker会动态修改这些函数的指令。<br>以下两段汇编代码，一段没有BoundsChecker介入，另一段则有BoundsChecker的介入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">126: _CRTIMP void * __cdecl malloc (</div><div class="line"></div><div class="line">127: size_t nSize</div><div class="line"></div><div class="line">128: )</div><div class="line"></div><div class="line">129: &#123;</div><div class="line"></div><div class="line">00403C10 push ebp</div><div class="line"></div><div class="line">00403C11 mov ebp,esp</div><div class="line"></div><div class="line">130: return _nh_malloc_dbg(nSize, _newmode, _NORMAL_BLOCK, NULL, 0);</div><div class="line"></div><div class="line">00403C13 push 0</div><div class="line"></div><div class="line">00403C15 push 0</div><div class="line"></div><div class="line">00403C17 push 1</div><div class="line"></div><div class="line">00403C19 mov eax,[__newmode (0042376c)]</div><div class="line"></div><div class="line">00403C1E push eax</div><div class="line"></div><div class="line">00403C1F mov ecx,dword ptr [nSize]</div><div class="line"></div><div class="line">00403C22 push ecx</div><div class="line"></div><div class="line">00403C23 call _nh_malloc_dbg (00403c80)</div><div class="line"></div><div class="line">00403C28 add esp,14h</div><div class="line"></div><div class="line">131: &#125;</div></pre></td></tr></table></figure></p>
<p>以下这一段代码有BoundsChecker介入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">126: _CRTIMP void * __cdecl malloc (</div><div class="line"></div><div class="line">127: size_t nSize</div><div class="line"></div><div class="line">128: )</div><div class="line"></div><div class="line">129: &#123;</div><div class="line"></div><div class="line">00403C10 jmp 01F41EC8</div><div class="line"></div><div class="line">00403C15 push 0</div><div class="line"></div><div class="line">00403C17 push 1</div><div class="line"></div><div class="line">00403C19 mov eax,[__newmode (0042376c)]</div><div class="line"></div><div class="line">00403C1E push eax</div><div class="line"></div><div class="line">00403C1F mov ecx,dword ptr [nSize]</div><div class="line"></div><div class="line">00403C22 push ecx</div><div class="line"></div><div class="line">00403C23 call _nh_malloc_dbg (00403c80)</div><div class="line"></div><div class="line">00403C28 add esp,14h</div><div class="line"></div><div class="line">131: &#125;</div></pre></td></tr></table></figure></p>
<p>当BoundsChecker介入后，函数malloc的前三条汇编指令被替换成一条jmp指令，原来的三条指令被搬到地址01F41EC8处了。当程序进入malloc后先jmp到01F41EC8，执行原来的三条指令，然后就是BoundsChecker的天下了。大致上它会先记录函数的返回地址（函数的返回地址在stack上，所以很容易修改），然后把返回地址指向属于BoundsChecker的代码，接着跳到malloc函数原来的指令，也就是在00403c15的地方。当malloc函数结束的时候，由于返回地址被修改，它会返回到BoundsChecker的代码中，此时BoundsChecker会记录由malloc分配的内存的指针，然后再跳转到到原来的返回地址去。<br>如果内存分配/释放函数在DLL中，BoundsChecker则采用另一种方法来截获对这些函数的调用。BoundsChecker通过修改程序的DLL Import Table让table中的函数地址指向自己的地址，以达到截获的目的。<br>截获住这些分配和释放函数，BoundsChecker就能记录被分配的内存或资源的生命周期。接下来的问题是如何与源代码相关，也就是说当BoundsChecker检测到内存泄漏，它如何报告这块内存块是哪段代码分配的。答案是调试信息（Debug Information）。当我们编译一个Debug版的程序时，编译器会把源代码和二进制代码之间的对应关系记录下来，放到一个单独的文件里(.pdb)或者直接连结进目标程序，通过直接读取调试信息就能得到分配某块内存的源代码在哪个文件，哪一行上。使用Code Injection和Debug Information，使BoundsChecker不但能记录呼叫分配函数的源代码的位置，而且还能记录分配时的Call Stack，以及Call Stack上的函数的源代码位置。</p>
<h4 id="3-1-4-禁止产生堆对象"><a href="#3-1-4-禁止产生堆对象" class="headerlink" title="3.1.4 禁止产生堆对象"></a>3.1.4 禁止产生堆对象</h4><p>禁止堆对象的产生就是禁止 new 表达式正常执行，new 表达式和 delete 表达式我们根本就不能自定义它们的行为。但是由于 new表达式实际执行的动作有三个，delete 实际执行的动作有两个，我们可以通过禁止 new 表达式的第一个动作 operator new 和 delete 的第二个动作 operator delete 来禁止 new 表达式和delete 表达式的执行。对于 operator new 运算符和 operator delete 运算符我们是可以重载的。通过将其声明为类的私有方法，我们可以组织 new 表达式和 delete表达式从外部对它们的访问，从而禁止 new 表达式和 delete表达式的正确执行，禁止堆对象的产生。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Resource</div><div class="line">&#123;</div><div class="line">&#125;;</div><div class="line">class ResourceManager</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    ResourceManager() &#123;</div><div class="line">        ptr = new Resource;</div><div class="line">    &#125;;</div><div class="line">    ~ResourceManager() &#123;</div><div class="line">        delete ptr;</div><div class="line">    &#125;;</div><div class="line">private:</div><div class="line">    Resource* ptr;</div><div class="line">    void* operator new(size_t size)&#123;&#125;;</div><div class="line">    void operator delete(void *p)&#123;&#125;;</div><div class="line">&#125;;</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    // ResourceManager* rm = new ResourceManager;</div><div class="line">    ResourceManager rm;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-1-5-禁止产生栈对象"><a href="#3-1-5-禁止产生栈对象" class="headerlink" title="3.1.5 禁止产生栈对象"></a>3.1.5 禁止产生栈对象</h4><p>禁止栈对象的产生，允许堆对象的产生，就只能通过将类的构造函数和析构函数声明为私有或者受保护，这样就不能直接通过外部代码实例化一个栈对象了，但同时也禁止了new 表达式和 delete表达式的正常执行，不能通过外部的new 表达式和delete表达式调用到私有或者受保护的构造函数和析构函数。解决这一个问题的方式是将 new 和 delete 表达式放到类的方法（静态方法和普通方法）中进行调用，这样就可以访问到类的私有或者受保护的构造函数或者析构函数了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;cstdlib&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class Resource</div><div class="line">&#123;</div><div class="line">&#125;;</div><div class="line">class ResourceManager</div><div class="line">&#123;</div><div class="line">protected:</div><div class="line">    ResourceManager() &#123;</div><div class="line">        ptr = new Resource;</div><div class="line">    &#125;;</div><div class="line">    ~ResourceManager() &#123;</div><div class="line">        delete ptr;</div><div class="line">    &#125;;</div><div class="line">public:</div><div class="line">    static ResourceManager* create_instance();</div><div class="line">    void destory() &#123;</div><div class="line">        // 这样就可以访问到 ~ResourceManager() 析构函数了</div><div class="line">        delete this;</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    Resource* ptr;</div><div class="line">&#125;;</div><div class="line">ResourceManager* ResourceManager::create_instance()</div><div class="line">&#123;</div><div class="line">    // 这样就可以访问到 ResourceManager() 构造函数了</div><div class="line">    return new ResourceManager;</div><div class="line">&#125;</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    // ResourceManager* rm = new ResourceManager;</div><div class="line">    // ResourceManager rm;</div><div class="line">    ResourceManager* rm_ptr = ResourceManager::create_instance();</div><div class="line">    /*code*/</div><div class="line">    rm_ptr-&gt;destory();</div><div class="line">    // 防止悬挂指针的出现</div><div class="line">    rm_ptr = nullptr;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/02/19/C-类型转换/">
                C++类型转换
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-02-19</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="类型转换可以分为-隐式类型转换和显式类型转换-强制类型转换"><a href="#类型转换可以分为-隐式类型转换和显式类型转换-强制类型转换" class="headerlink" title="类型转换可以分为:隐式类型转换和显式类型转换(强制类型转换)"></a>类型转换可以分为:隐式类型转换和显式类型转换(强制类型转换)</h3><p>隐式类型转换比较常见，在混合类型表达式中经常发生，比如在表达式中存在 short 和 int，那么就会发生整型提升。</p>
<h4 id="四种强制类型转换操作符：static-cast、dynamic-cast、const-cast、reinterpret-cast。"><a href="#四种强制类型转换操作符：static-cast、dynamic-cast、const-cast、reinterpret-cast。" class="headerlink" title="四种强制类型转换操作符：static_cast、dynamic_cast、const_cast、reinterpret_cast。"></a>四种强制类型转换操作符：static_cast、dynamic_cast、const_cast、reinterpret_cast。</h4><h4 id="static-cast-与-dynamic-cast"><a href="#static-cast-与-dynamic-cast" class="headerlink" title="static_cast 与 dynamic_cast"></a>static_cast 与 dynamic_cast</h4><p>把这两个放在一起比较容易记忆，”一静一动”，从字面上也可以看出，前者提供的是编译时期的静态类型检测，后者提供的是<br>运行时检测。<br>static_cast 完成以下类型</p>
<ol>
<li>基础数据类型 </li>
<li>同一个继承体系中的类型</li>
<li>任意类型与空指针类型void*之间的转换。<br>dynamic_cast 使用多态的场景，增加了一层对真实调用对象类型的检查<br><strong>C-like 的强制类型转换太“随意”了，而 C++ 的这四个对类型转换提供了相应的类型检查。</strong></li>
</ol>
<h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast:"></a>static_cast:</h4><ol>
<li>基础数据类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    char c  = 65;</div><div class="line">    int *p = (int *)&amp;c;</div><div class="line">    cout &lt;&lt; *p &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; (char)*p &lt;&lt; endl; //&apos;A&apos;</div><div class="line">    *p = 1644054338;</div><div class="line">    cout &lt;&lt; (char)*p &lt;&lt; endl; //&apos;B&apos;</div><div class="line">    *p = 5;</div><div class="line">    // 下面这一行会导致**运行时**错误</div><div class="line">    // cout &lt;&lt; (char)*p &lt;&lt; endl; //&apos;B&apos;</div><div class="line">    // int *q = static_cast&lt;int *&gt;(&amp;c); //编译报错: error: invalid static_cast from type ‘char*’ to type ‘int*’</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>static_cast 可以将错误在编译时期检查出。</p>
<ol>
<li>自定义类型<br><strong>不同继承体系：</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line"></div><div class="line">class A</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    A()&#123;&#125;</div><div class="line">    ~A()&#123;&#125;</div><div class="line">    void printA()</div><div class="line">    &#123;</div><div class="line">        std::cout &lt;&lt;&quot;call printA() in class A&quot; &lt;&lt;std::endl;</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    int i, j;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class C</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    C()&#123;&#125;</div><div class="line">    ~C()&#123;&#125;</div><div class="line">    void printC()</div><div class="line">    &#123;</div><div class="line">        std::cout &lt;&lt;&quot;call printC() in class C&quot; &lt;&lt;std::endl;</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    char c1, c2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    A* ptrA = new A();</div><div class="line">    C* ptrC = (C*)ptrA;</div><div class="line">    //---------------------------------------//</div><div class="line">    ptrC-&gt;printC(); // &quot;call printC() in class C&quot;</div><div class="line">    // 下面一行会报出 error: &apos;class C&apos; has no member named &apos;printA&apos;; did you mean &apos;printC&apos;?</div><div class="line">    // ptrC-&gt;printA();</div><div class="line"></div><div class="line">    //---------------------------------------//</div><div class="line">    ptrA-&gt;printA(); // &quot;call printA() in class A&quot;</div><div class="line">    // 下面一行会报出 error: &apos;class A&apos; has no member named &apos;printC&apos;; did you mean &apos;printA&apos;?</div><div class="line">    // ptrA-&gt;printC();</div><div class="line">    // 上面的测试证明，怎么和具体对象的类型没有了关系，而只与指针的类型有关了？</div><div class="line"></div><div class="line">    //ptrC = static_cast&lt;C*&gt;(ptrA); //编译报错: error: invalid static_cast from type &apos;A*’ to type C*’</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上面A、C是两个无关的类，然而使用 C-like 可以实现这种类型的强制转换，这是十分危险的! 使用static_cast 可以将这种潜在的危险在编译期找出来。<br><strong>同一继承体系：</strong></p>
<ul>
<li>upcast(向上转换即子类转成父类)：这个对象本身是子类对象，但是你“强行”将其 cast 成父类指针，当通过父类的指针调用父类的方法时，由于父类方法中所需的全部成员变量或者成员函数，都是有定义的，因此方法的行为是有定义的。</li>
<li>downcast(向下转换)：有可能会出现问题，编译时可能不会发现，这个对象本身是父类的对象，当通过子类的指针调用子类的方法时，方法所需的成员变量或者成员函数不一定在父类对象中有定义，所以就有可能导致方法的行为无定义。<br>上面是子类类型的指针调用子类的方法，父类类型的指针调用父类的方法。<br>下面是两者的交叉行为：</li>
<li>当通过父类的指针调用子类特有的方法时就会报出 has no member named 的错误。</li>
<li>当通过子类的指针调用父类的方法时，没有一点问题。<br>一个类的行为和自身的类型相关，就是一个A类型的指针总会优先调用自己A类内的函数，当然继承中的虚函数例外。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line">class A</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    A():i(1), j(1)&#123;&#125;</div><div class="line">    ~A()&#123;&#125;</div><div class="line">    void printA()</div><div class="line">    &#123;</div><div class="line">        std::cout &lt;&lt; &quot;call printA() in class A&quot; &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">    void printSum()</div><div class="line">    &#123;</div><div class="line">        std::cout &lt;&lt; &quot;sum = in class A: &quot; &lt;&lt; i+j &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    int i, j;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class B : public A</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    B():a(2), b(2) &#123;&#125;</div><div class="line">    ~B()&#123;&#125;</div><div class="line">    void printB()</div><div class="line">    &#123;</div><div class="line">        std::cout &lt;&lt; &quot;call printB() in class B&quot; &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">    void printSum()</div><div class="line">    &#123;</div><div class="line">        std::cout &lt;&lt; &quot;sum = in class B: &quot; &lt;&lt; a+b &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">    void Add()</div><div class="line">    &#123;</div><div class="line">        a++;</div><div class="line">        b++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">private:</div><div class="line">  double a, b;</div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    A *ptrA=nullptr;</div><div class="line">    B *ptrB=nullptr;</div><div class="line">    </div><div class="line">    ptrB = new B;</div><div class="line">    ptrB -&gt; printSum();</div><div class="line">    ptrA = static_cast&lt;A *&gt;(ptrB);</div><div class="line">    ptrA -&gt; printA();</div><div class="line">    ptrA -&gt; printSum();</div><div class="line">    std::cout &lt;&lt; &quot;-------&quot; &lt;&lt; std::endl;</div><div class="line">    //打印结果：sum = 2</div><div class="line">    //在进行 upcast 的时候，行为与指针类型相关。</div><div class="line"></div><div class="line">    ptrA = new A;</div><div class="line">    ptrB = static_cast&lt;B *&gt;(ptrA);</div><div class="line">    ptrB -&gt; printB();</div><div class="line">    ptrB -&gt; printSum();</div><div class="line">    //打印结果：sum = 0</div><div class="line">    //在进行 downcast 的时候，调用的函数是对的，但是值不对，是因为确实无法正确地找到值。</div><div class="line"></div><div class="line">    std::cout &lt;&lt; &quot;#######&quot; &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    B b;</div><div class="line">    B &amp; rB = b;</div><div class="line">    rB.printSum();</div><div class="line">    A &amp; rA = static_cast&lt;A &amp;&gt;(b);</div><div class="line">    rA.printA();</div><div class="line">    rA.printSum();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; &quot;+++++++&quot; &lt;&lt; std::endl;</div><div class="line">    </div><div class="line">    A a;</div><div class="line">    A &amp; rA1 = a;</div><div class="line">    rA1.printSum();</div><div class="line">    B &amp; rB1 = static_cast&lt;B &amp;&gt;(a);</div><div class="line">    rB1.printB();</div><div class="line">    rB1.printSum();</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">sum = in class B: 4</div><div class="line">call printA() in class A</div><div class="line">sum = in class A: 2</div><div class="line">-------</div><div class="line">call printB() in class B</div><div class="line">sum = in class B: 2.01105e-317</div><div class="line">#######</div><div class="line">sum = in class B: 4</div><div class="line">call printA() in class A</div><div class="line">sum = in class A: 2</div><div class="line">+++++++</div><div class="line">sum = in class A: 2</div><div class="line">call printB() in class B</div><div class="line">sum = in class B: 2</div></pre></td></tr></table></figure></p>
<h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><ol>
<li>dynamic_cast 是在运行时检查的，用于在继承体系中进行安全的向下转换，即：基类指针/引用 -&gt; 派生类指针/引用，如果源和目标没有继承/被继承关系，编译器会报错！</li>
<li>dynamic_cast 是4个转换中唯一的RTTI操作符，提供运行时类型检查。</li>
<li>dynamic_cast不是强制转换，而是带有某种”咨询“性质的，如果不能转换，返回NULL。这是强制转换做不到的。</li>
<li>源类中必须要有虚函数，保证多态，才能使用dynamic_cast<source>(expression)。</li>
</ol>
<h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><p>仅仅是复制 n 的比特位到 d_r，没有进行必要的分析，interpret_cast 是映射到一个完全不同类型<br>的意思，这是所有映射中最危险的。</p>
<h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h4><p>去除 const 常量属性，使其可以修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;cstdio&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">class A &#123;</div><div class="line">    public:</div><div class="line">    A()&#123;&#125;;</div><div class="line">    int m_a;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class B &#123;</div><div class="line">    public:</div><div class="line">    int m_b;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class C : public A, public B &#123;&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    const A a;</div><div class="line">    // a.m_a = 1;</div><div class="line">    A &amp; a_ref = const_cast&lt;A &amp;&gt;(a);</div><div class="line">    a_ref.m_a = 2;</div><div class="line">    // a.m_a = 3; // 编译不能通过</div><div class="line">    cout &lt;&lt; a.m_a &lt;&lt;endl;</div><div class="line">    int n = 9;</div><div class="line">    double d_s = static_cast&lt;double&gt;(n);</div><div class="line">    double d_r = reinterpret_cast&lt;double&amp;&gt;(n);</div><div class="line">    cout &lt;&lt; d_s &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; d_r &lt;&lt; endl;//4.24399e-314</div><div class="line">    // 在进行计算以后, d_r 包含无用值. 这是因为 reinterpret_cast 仅仅是复制n的比特位到d_r, </div><div class="line">    // 没有进行必要的分析.</div><div class="line"></div><div class="line">    C c;</div><div class="line">    printf(&quot;%p, %p, %p\n&quot;, &amp;c, reinterpret_cast&lt;B*&gt;(&amp;c), static_cast&lt;B*&gt;(&amp;c));</div><div class="line">    // 前两个的输出值是相同的，最后一个则会在原基础上偏移4个字节，这是因为static_cast计算了父子类指针转换的偏移量,</div><div class="line">    // 并将之转换到正确的地址（c里面有m_a, m_b, 转换为 B* 指针后指到 m_b 处），而 reinterpret_cast 却不会做这一层转换.</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/02/17/多线程编程/">
                多线程编程
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-02-17</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h3><h4 id="lock-guard、unique-lock：互斥对象管理类模板"><a href="#lock-guard、unique-lock：互斥对象管理类模板" class="headerlink" title="lock_guard、unique_lock：互斥对象管理类模板"></a>lock_guard、unique_lock：互斥对象管理类模板</h4><ol>
<li>std::lock_guard，与 Mutex RAII 相关，方便线程对互斥量上锁。</li>
<li>std::unique_lock，与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。</li>
</ol>
<p>另外还提供了几个与锁类型相关的 Tag 类，分别如下:</p>
<ol>
<li>std::adopt_lock_t，一个空的标记类，定义为 <code>struct adopt_lock_t {};</code><br>该类型的常量对象adopt_lock，定义为 <code>constexpr adopt_lock_t adopt_lock {};</code>，通常作为参数传入给 unique_lock 或 lock_guard 的构造函数。</li>
<li>std::defer_lock_t，一个空的标记类，定义为 <code>structdefer_lock_t {};</code> 该类型的常量对象 defer_lock 定义为<br><code>constexpr defer_lock_t defer_lock {};</code>，通常作为参数传入给 unique_lock 或 lock_guard 的构造函数。</li>
<li>std::try_to_lock_t，一个空的标记类，定义为<code>structtry_to_lock_t {};</code>，该类型的常量对象 try_to_lock 定义为<br><code>constexpr try_to_lock_t try_to_lock {};</code>，通常作为参数传入给 unique_lock 或 lock_guard 的构造函数。</li>
</ol>
<h5 id="lock-guard-类模板-基于作用域"><a href="#lock-guard-类模板-基于作用域" class="headerlink" title="lock_guard 类模板 基于作用域"></a>lock_guard 类模板 基于作用域</h5><p>声明为 <code>template&lt;class Mutex&gt; class lock_guard;</code><br>在某个 lock_guard 对象的生命周期内，它所管理的锁对象会一直保持上锁状态；而 lock_guard 的生命周期结束之后，它所管理的锁对象会被解锁(注：类似 shared_ptr 等智能指针管理动态分配的内存资源 )。</p>
<p>模板参数 Mutex 代表互斥类型，例如 std::mutex 类型，它应该是一个基本的 BasicLockable 类型，标准库中定义几种基本的 BasicLockable 类型，分别 std::mutex, std::recursive_mutex, std::timed_mutex，std::recursive_timed_mutex 以及 std::unique_lock。</p>
<ol>
<li>BasicLockable 类型，只需满足两种操作 lock 和 unlock</li>
<li>Lockable 类型，在 BasicLockable 类型的基础上新增了 try_lock 操作</li>
<li>TimedLockable 类型，在 Lockable 类型的基础上又新增了 try_lock_for 和 try_lock_until 两种操作</li>
</ol>
<p>工作原理：</p>
<ol>
<li>在 lock_guard 对象构造时，传入的 Mutex 对象(即<strong>互斥对象管理模板类对象</strong>所管理的 Mutex 对象)会被当前线程锁住</li>
<li>在 lock_guard 对象被析构时，它所管理的 Mutex 对象会自动解锁</li>
<li>由于不需要程序员手动调用 lock 和 unlock 对 Mutex 对象 进行上锁和解锁操作，因此这也是最简单安全的上锁和解锁方式，尤其是在程序抛出异常后先前已被上锁的 Mutex 对象可以正确进行解锁操作，极大地简化了程序员编写与 Mutex 相关的异常处理代码。</li>
<li>值得注意的是，lock_guard 对象并不负责管理 Mutex 对象的生命周期<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;  // 使用复合语句块封装临界区操作，块结束时即释放局部对象</div><div class="line">    std::lock_guard&lt;std::mutex&gt;  locker( x );    //  构造对象的同时加锁</div><div class="line">    *r = _x + _y;</div><div class="line"> &#125; // 无需手工解锁，locker对象在析构时自动解锁</div></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="std-lock-guard-构造函数"><a href="#std-lock-guard-构造函数" class="headerlink" title="std::lock_guard 构造函数"></a>std::lock_guard 构造函数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">locking (1) </div><div class="line">explicit lock_guard (mutex_type&amp; m);</div><div class="line">adopting (2)    </div><div class="line">lock_guard (mutex_type&amp; m, adopt_lock_t tag);</div><div class="line">copy [deleted](3)   </div><div class="line">lock_guard (const lock_guard&amp;) = delete;</div></pre></td></tr></table></figure>
<ol>
<li>locking 初始化<br>lock_guard 对象管理 Mutex 对象 m，并在构造时对 m 进行上锁（调用 m.lock()）。<br>adopting初始化</li>
<li>lock_guard 对象管理 Mutex 对象 m，与 locking 初始化(1) 不同的是， 不加锁，假定<strong>当前</strong>线程已获得锁的所有权，即Mutex 对象 m 已被<strong>当前</strong>线程锁住。</li>
<li>拷贝构造<br>lock_guard 对象的拷贝构造和移动构造均被禁用，因此 lock_guard 对象不可被拷贝构造或移动构造，所有权不可转移。</li>
</ol>
<h5 id="unique-lock-（独一锁）类模板"><a href="#unique-lock-（独一锁）类模板" class="headerlink" title="unique_lock （独一锁）类模板"></a>unique_lock （独一锁）类模板</h5><p>unique_lock 对象以独占所有权的方式（unique owership）管理 Mutex 对象的上锁和解锁操作，所谓独占所有权，就是没有其他的 unique_lock 对象同时拥有某个 Mutex 对象的所有权。<br>在构造(或移动(move)赋值)时，unique_lock 需要传递一个 Mutex 对象作为它的参数，新创建的 unique_lock 对象负责传入的 Mutex 对象的上锁和解锁操作。<br>std::unique_lock 对象也能保证在其自身析构时它所管理的 Mutex 对象能够被正确地解锁（即使没有显式地调用 unlock 函数）。因此，和 lock_guard 一样，这也是一种简单安全的上锁和解锁方式，尤其是在程序抛出异常后先前已被上锁的 Mutex 对象可以正确进行解锁操作，极大地简化了程序员编写与 Mutex 相关的异常处理代码。<br>值得注意的是，unique_lock 对象同样也不负责管理 Mutex 对象的生命周期</p>
<h6 id="std-unique-lock-构造函数"><a href="#std-unique-lock-构造函数" class="headerlink" title="std::unique_lock 构造函数"></a>std::unique_lock 构造函数</h6><p>std::unique_lock 的构造函数的数目相对来说比 std::lock_guard 多：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">default (1) </div><div class="line">    unique_lock() noexcept;</div><div class="line">locking (2) </div><div class="line">    explicit unique_lock(mutex_type&amp; m);</div><div class="line">try-locking (3) </div><div class="line">    unique_lock(mutex_type&amp; m, try_to_lock_t tag);</div><div class="line">deferred (4)    </div><div class="line">    unique_lock(mutex_type&amp; m, defer_lock_t tag) noexcept;</div><div class="line">adopting (5)    </div><div class="line">    unique_lock(mutex_type&amp; m, adopt_lock_t tag);</div><div class="line">locking for (6) </div><div class="line">    template &lt;class Rep, class Period&gt;</div><div class="line">    unique_lock(mutex_type&amp; m, const chrono::duration&lt;Rep,Period&gt;&amp; rel_time);</div><div class="line">locking until (7)   </div><div class="line">    template &lt;class Clock, class Duration&gt;</div><div class="line">    unique_lock(mutex_type&amp; m, const chrono::time_point&lt;Clock,Duration&gt;&amp; abs_time);</div><div class="line">copy [deleted] (8)  </div><div class="line">    unique_lock(const unique_lock&amp;) = delete;</div><div class="line">move (9)    </div><div class="line">    unique_lock(unique_lock&amp;&amp; x);</div></pre></td></tr></table></figure></p>
<p>下面来分别介绍以上各个构造函数：<br>(1) 默认构造函数<br>新创建的 unique_lock 对象不管理任何 Mutex 对象。<br>(2) locking 初始化<br>新创建的 unique_lock 对象管理 Mutex 对象 m，并尝试调用 m.lock() 对 Mutex 对象进行上锁，如果此时另外某个 unique_lock 对象已经管理了该 Mutex 对象 m，则当前线程将会被阻塞。<br>(3) try-locking 初始化<br>新创建的 unique_lock 对象管理 Mutex 对象 m，并尝试调用 m.try_lock() 对 Mutex 对象进行上锁，但如果上锁不成功，并不会阻塞当前线程。<br>(4) deferred 初始化<br>新创建的 unique_lock 对象管理 Mutex 对象 m，但是在初始化的时候并不锁住 Mutex 对象。 m 应该是一个没有<strong>当前</strong>线程锁住的 Mutex 对象。<br>(5) adopting 初始化<br>新创建的 unique_lock 对象管理 Mutex 对象 m， m 应该（假定）是一个已经被<strong>当前</strong>线程锁住的 Mutex 对象。(并且当前新创建的 unique_lock 对象拥有锁(Lock)的所有权)。<br>(6) locking 一段时间(duration)<br>新创建的 unique_lock 对象管理 Mutex 对象 m，并试图通过调用 m.try_lock_for(rel_time) 来锁住 Mutex 对象一段时间(rel_time)。<br>(7) locking 直到某个时间点(time point)<br>新创建的 unique_lock 对象管理 Mutex 对象m，并试图通过调用 m.try_lock_until(abs_time) 来在某个时间点(abs_time)之前锁住 Mutex 对象。<br>(8) 拷贝构造 [被禁用]<br>unique_lock 对象不能被拷贝构造。<br>(9) 移动(move)构造<br>新创建的 unique_lock 对象获得了由 x 所管理的 Mutex 对象的所有权(包括当前 Mutex 的状态)。调用 move 构造之后， x 对象如同是通过默认构造函数所创建的，就不再管理任何 Mutex 对象了，即被窃取了资源，之后 x 应该被析构或者去管理新的Mutex 对象（或者再将资源切窃取回来）。<br>综上所述，由 (2) 和 (5) 创建的 unique_lock 对象通常拥有 Mutex 对象的锁。而通过 (1) 和 (4) 创建的则不会拥有锁。通过 (3)，(6) 和 (7) 创建的 unique_lock 对象，则在 lock 成功时获得锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#include &lt;thread&gt;</div><div class="line">#include &lt;mutex&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">std::mutex foo,bar;  </div><div class="line">void task_a() &#123;  </div><div class="line">    std::lock(foo, bar);//foo和bar已被当前线程锁住  </div><div class="line">    /******************************************************* </div><div class="line">    *adopting 初始化: </div><div class="line">    *adopt_lock 是一个常量对象,通常作为参数传入给unique_lock 或  </div><div class="line">    *lock_guard 的构造函数。新创建的 unique_lock 对象管理 Mutex  </div><div class="line">    *对象 m， m 应该是一个已经被当前线程锁住的 Mutex 对象。 </div><div class="line">    *******************************************************/  </div><div class="line">    std::unique_lock&lt;std::mutex&gt; lck1(foo, std::adopt_lock);  </div><div class="line">    std::unique_lock&lt;std::mutex&gt; lck2(bar, std::adopt_lock);  </div><div class="line">    std::cout &lt;&lt; &quot;task a\n&quot;;  </div><div class="line">&#125;  </div><div class="line">void task_b() &#123;  </div><div class="line">    //新创建的 unique_lock 对象不管理任何 Mutex 对象。  </div><div class="line">    std::unique_lock&lt;std::mutex&gt; lck1, lck2;  </div><div class="line">    /****************************************************** </div><div class="line">    * deferred 初始化: </div><div class="line">    *新创建的 unique_lock 对象管理 Mutex 对象 m，但是在初始化 </div><div class="line">    *的时候并不锁住 Mutex 对象。 m 应该是一个没有**当前**线程锁住的  </div><div class="line">    *Mutex 对象。 </div><div class="line">    ******************************************************/  </div><div class="line">    // 等号右边是临时对象，即不具名，调用了移动赋值运算符，进行了资源的窃取（锁所有权的转移）</div><div class="line">    // 然后临时对象就被析构了，如此窃取其资源是安全的。</div><div class="line">    lck1 = std::unique_lock&lt;std::mutex&gt;(bar, std::defer_lock);  </div><div class="line">    lck2 = std::unique_lock&lt;std::mutex&gt;(foo, std::defer_lock);  </div><div class="line">    std::lock(lck1, lck2);</div><div class="line">    std::cout &lt;&lt; &quot;task b\n&quot;;</div><div class="line">&#125;  </div><div class="line">int main() &#123;  </div><div class="line">    std::thread th1(task_a);  </div><div class="line">    std::thread th2(task_b);  </div><div class="line">    th1.join();  </div><div class="line">    th2.join();  </div><div class="line">    return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="乐观锁和悲观锁的区别"><a href="#乐观锁和悲观锁的区别" class="headerlink" title="乐观锁和悲观锁的区别"></a>乐观锁和悲观锁的区别</h4><ol>
<li>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</li>
<li>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于 write_condition 机制的其实都是提供的乐观锁。</li>
<li>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，即写的太多了，上层应用会不断的进行 retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。<br>乐观锁，使用版本标识来确定<strong>读时读到的数据</strong>与<strong>提交时的数据</strong>是否一致。<br>提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。<br>记录1，id,status1,status2,stauts3,version，表示有三个不同的状态，以及数据当前的版本<br>操作1：update table set status1=1,status2=0,status3=0 where id=111;<br>操作2：update table set status1=0,status2=1,status3=0 where id=111;<br>操作3：update table set status1=0,status2=0,status3=1 where id=111;<br>没有任何控制的情况下，顺序执行3个操作，最后前两个操作会被直接覆盖。<br>加上version字段，每一次的操作都会更新version，提交时如果version不匹配，停止本次提交，可以尝试下一次的提交，以保证拿到的是操作1提交后的结果。</li>
</ol>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="" href="/page/2/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/4/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a href="https://github.com/klugjo">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2018/08/13/消失的梯度/">消失的梯度</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/11/MobileNet-V1-and-V2-带来的卷积结构革命/">MobileNet V1 and V2 带来的卷积</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/09/卷积转置卷积关系在-TensorFLow-中的验证/">卷积转置卷积关系在 TensorFLow 中的验证</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/08/转置卷积-Transposed-Convolution/">转置卷积 Transposed Convoluti</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/klugjo/hexo-theme-alpha-dust">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://twitter.com/?lang=en">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.facebook.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.instagram.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://dribbble.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://plus.google.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-google-plus"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.behance.net/">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://500px.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>