<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    

    <!--Author-->
    
        <meta name="author" content="Robert Lexis">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="This is Robert Lexis."/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="This is Robert Lexis."/>

    <!--Type page-->
    
        <meta property="og:type" content="website" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>page - This is Robert Lexis.</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
            <h1 id="main-title" class="title">This is Robert Lexis.</h1>
        
    </div>
</header>

        <section class="main">
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/05/28/Deep-learning-资料汇总/">
                Deep learning 资料汇总
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-05-28</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p><a href="https://web.stanford.edu/class/cs20si/" target="_blank" rel="external">CS 20: Tensorflow for Deep Learning Research</a><br><a href="https://github.com/chiphuyen/stanford-tensorflow-tutorials" target="_blank" rel="external">stanford-tensorflow-tutorials from github</a><br><a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="external">Understanding LSTM Networks from colah’s blog</a><br><a href="https://blog.csdn.net/qunnie_yi/article/details/80129434" target="_blank" rel="external">详解TensorBoard如何调参</a><br><a href="https://github.com/Hvass-Labs/TensorFlow-Tutorials" target="_blank" rel="external">TensorFlow Tutorial from Hvass Laboratories YouTube</a><br><a href="http://rail.eecs.berkeley.edu/deeprlcourse-fa17/index.html" target="_blank" rel="external">CS 294: Deep Reinforcement Learning, Fall 2017</a><br>Amazing!!!看过的最好的关于Python高级（专家）特性的讲解 <a href="https://www.youtube.com/watch?v=7lmCu8wz8ro&amp;index=2&amp;list=WL" target="_blank" rel="external">What Does It Take To Be An Expert At Python?</a><br><a href="https://www.pyimagesearch.com/" target="_blank" rel="external">pyimagesearch 博客</a><br><a href="http://cv-tricks.com/" target="_blank" rel="external">Learn Machine Learning, AI &amp; Computer vision</a><br><a href="https://www.youtube.com/watch?v=oaxf3rk0KGM&amp;list=PL9Hr9sNUjfsmEu1ZniY0XpHSzl5uihcXZ&amp;index=26" target="_blank" rel="external">TensorFlow Tutorial #19 Hyper-Parameter Optimization from YouTube Hvass Laboratories</a></p>
<h3 id="深度学习产品化"><a href="#深度学习产品化" class="headerlink" title="深度学习产品化"></a>深度学习产品化</h3><p><a href="http://www.bitbionic.com/2017/08/18/run-your-keras-models-in-c-tensorflow/" target="_blank" rel="external">Run your Keras models in C++ Tensorflow</a><br><a href="https://blog.keras.io/building-a-simple-keras-deep-learning-rest-api.html" target="_blank" rel="external">Building a simple Keras + deep learning REST API</a><br><a href="https://scotch.io/bar-talk/processing-incoming-request-data-in-flask" target="_blank" rel="external">Processing Incoming Request Data in Flask</a><br><a href="https://www.pyimagesearch.com/2018/01/29/scalable-keras-deep-learning-rest-api/" target="_blank" rel="external">A scalable Keras + deep learning REST API</a><br><a href="https://www.pyimagesearch.com/2018/02/05/deep-learning-production-keras-redis-flask-apache/" target="_blank" rel="external">Deep learning in production with Keras, Redis, Flask, and Apache</a><br><a href="https://www.youtube.com/watch?v=f6Bf3gl4hWY" target="_blank" rel="external">How to Deploy Keras Models to Production from YouTube Siraj Raval</a><br><a href="https://www.youtube.com/watch?v=T_afaArR0E8" target="_blank" rel="external">How to Deploy a Tensorflow Model to Production from YouTube Siraj Raval</a></p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/05/17/For-FreeWheel/">
                For FreeWheel
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-05-17</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>epoll is a Linux kernel <strong>system call</strong> for a scalable <strong>I/O event notification mechanism</strong>. Its function is to monitor multiple file descriptors to see if I/O is possible on any of them. It is meant to replace the older POSIX select(2) and poll(2) system calls, to achieve better performance in more demanding applications, where the number of watched file descriptors is large (unlike the older system calls, which operate in O(n) time, epoll operates in O(1) time).</p>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int epoll_create1(int flags);</div></pre></td></tr></table></figure>
<p>Creates an epoll object and returns its file descriptor(标识内核事件表). The flags parameter allows epoll behavior to be modified. It has only one valid value, EPOLL_CLOEXEC. epoll_create() is an older variant of epoll_create1() and is deprecated as of Linux kernel version 2.6.27 and glibc version 2.9.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</div></pre></td></tr></table></figure></p>
<p>Controls (configures) which file descriptors are watched by this object, and for which events. op can be ADD, MODIFY or DELETE.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</div></pre></td></tr></table></figure></p>
<p>Waits for any of the events registered for with epoll_ctl, until at least one occurs or the timeout elapses. Returns the occurred events in events, up to maxevents at once.</p>
<h4 id="Triggering-modes"><a href="#Triggering-modes" class="headerlink" title="Triggering modes"></a>Triggering modes</h4><p>epoll provides both edge-triggered and level-triggered modes. In edge-triggered mode, a call to epoll_wait will return only when a new event is enqueued with the epoll object, while in level-triggered mode, epoll_wait will return as long as the condition holds（可读）.</p>
<p>For instance, if a pipe registered with epoll has received data, a call to epoll_wait will return, signaling the presence of data to be read. Suppose the reader only consumed part of data from the buffer. In level-triggered mode, further calls to epoll_wait will return immediately, as long as the pipe’s buffer contains data to be read. （每次读一部分就可以了，因为会不断地触发）In edge-triggered mode, however, epoll_wait will return only once new data is written to the pipe.（因此需要一次性读完）<br>ET 是高效工作模式，很大程度上降低同一个事件被重复触发的次数。</p>
<h2 id="HTTP-Hypertext-Transfer-Protocol"><a href="#HTTP-Hypertext-Transfer-Protocol" class="headerlink" title="HTTP Hypertext Transfer Protocol"></a>HTTP Hypertext Transfer Protocol</h2><p>Client request<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GET /index.html HTTP/1.1</div><div class="line">Host: www.example.com</div></pre></td></tr></table></figure></p>
<p>Server response<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Mon, 23 May 2005 22:38:34 GMT</div><div class="line">Content-Type: text/html; charset=UTF-8</div><div class="line">Content-Encoding: UTF-8</div><div class="line">Content-Length: 138</div><div class="line">Last-Modified: Wed, 08 Jan 2003 23:11:55 GMT</div><div class="line">Server: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)</div><div class="line">ETag: &quot;3f80f-1b6-3e1cb03b&quot;</div><div class="line">Accept-Ranges: bytes</div><div class="line">Connection: close</div><div class="line"></div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">  &lt;title&gt;An Example Page&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">  Hello World, this is a very simple HTML document.</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>Status codes<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Informational 1XX</div><div class="line">Successful 2XX</div><div class="line">Redirection 3XX</div><div class="line">Client Error 4XX</div><div class="line">Server Error 5XX</div></pre></td></tr></table></figure></p>
<p>The <strong>ETag (entity tag)</strong> header field is used to determine if a cached version of the requested resource is identical to the current version of the resource on the server.<br>Content-Type specifies the Internet media type of the data conveyed by the HTTP message, while Content-Length indicates its length in bytes. The HTTP/1.1 webserver publishes its ability to respond to requests for certain byte ranges of the document by setting the field Accept-Ranges: bytes. This is useful, if the client needs to have only certain portions of a resource sent by the server, which is called <strong>byte serving</strong>.<br>When Connection: close is sent, it means that the web server will close the TCP connection immediately after the transfer of this response.<br>A Content-Encoding like gzip can be used to compress the transmitted data.</p>
<h4 id="Message-format"><a href="#Message-format" class="headerlink" title="Message format"></a>Message format</h4><p>The client and server communicate by sending plain-text (ASCII) messages. The client sends requests to the server and the server sends responses.</p>
<h6 id="Request-message"><a href="#Request-message" class="headerlink" title="Request message"></a>Request message</h6><p>The request message consists of the following:<br><strong>A request line</strong> (e.g., GET /images/logo.png HTTP/1.1, which requests a resource called /images/logo.png from the server).<br><strong>Request header fields</strong> (e.g., Accept-Language: en).<br>An empty line.<br>An optional message body.<br>The request line and other header fields must each end with <cr><lf>. The empty line must consist of only <cr><lf> and no other whitespace. In the HTTP/1.1 protocol, all header fields except Host are optional.</lf></cr></lf></cr></p>
<h6 id="Response-message"><a href="#Response-message" class="headerlink" title="Response message"></a>Response message</h6><p>The response message consists of the following:<br><strong>A status line</strong> which includes the status code and reason message (e.g., HTTP/1.1 200 OK, which indicates that the client’s request succeeded).<br><strong>Response header fields</strong> (e.g., Content-Type: text/html).<br>An empty line.<br>An optional message body.<br>The status line and other header fields must all end with <cr><lf>. The empty line must consist of only <cr><lf> and no other whitespace.</lf></cr></lf></cr></p>
<h2 id="C-内存布局"><a href="#C-内存布局" class="headerlink" title="C++ 内存布局"></a>C++ 内存布局</h2><p>在 C++ 中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。</p>
<ol>
<li>栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li>
<li>堆，就是那些由 new 分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</li>
<li>自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。</li>
<li>全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。</li>
<li>常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。</li>
</ol>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>Fork (system call)<br>In computing, particularly in the context of the Unix operating system, fork is an operation whereby a process creates a copy of itself. It is usually a system call, implemented in the kernel. Fork is the primary (and historically, only) method of process creation on Unix-like operating systems.</p>
<h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><p>In multitasking operating systems, processes (running programs) need a way to create new processes, e.g. to run other programs. Fork and its variants are typically the only way of doing so in Unix-like systems. For a process to start the execution of a different program, it first forks to create a copy of itself. Then, the copy, called the “child process”, calls the <strong>exec system call</strong> to overlay itself with the other program: it ceases execution of its former program in favor of the other.</p>
<p>The fork operation creates a separate <strong>address space</strong> for the child. The child process has an exact copy of all the memory segments of the parent process. In modern UNIX variants that follow the <strong>virtual memory model</strong> from SunOS-4.0, <strong>copy-on-write</strong> semantics are implemented and the physical memory need not be actually copied. Instead, <strong>virtual memory pages in both processes may refer to the same pages of physical memory until one of them writes to such a page: then it is copied</strong>. This optimization is important in the common case where fork is used in conjunction with exec to execute a new program: typically, the child process performs only a small set of actions before it ceases execution of its program in favour of the program to be started, and it requires very few, if any, of its parent’s data structures.<br>堆、栈、全局/静态存储区均被复制成独立的两份，但打开的文件等是同一个，总不能因为 fork 复制进程映像就去拷贝文件吧。</p>
<h2 id="strcpy-memcpy-memset"><a href="#strcpy-memcpy-memset" class="headerlink" title="strcpy/memcpy/memset"></a>strcpy/memcpy/memset</h2><p>都是标准 C 库函数。</p>
<h4 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h4><p>strcpy 提供了字符串的复制。即 strcpy 只用于字符串复制，并且它不仅复制字符串内容，还会复制字符串的结束符。<br>strcpy 函数的原型是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">char* strcpy(char* dest, const char* src);</div></pre></td></tr></table></figure></p>
<p>实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">char * strcpy(char * dest, const char * src) // 实现src到dest的复制 </div><div class="line">&#123; </div><div class="line">　　if ((src == NULL) || (dest == NULL)) // 判断参数src和dest的有效性 </div><div class="line">　　&#123;</div><div class="line"></div><div class="line">　　　　　　return NULL; </div><div class="line">　　&#125; </div><div class="line">　　char *strdest = dest; // 保存目标字符串的首地址 </div><div class="line">　　while ((*dest++ = *src++)!=’\0’); // 把src字符串的内容复制到dest下 </div><div class="line">　　return strdest; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h4><p>memcpy 提供了一般内存的复制。即 memcpy 对于需要复制的内容没有限制，因此用途更广。<br>函数的原型是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void *memcpy( void *dest, const void *src, size_t count );</div></pre></td></tr></table></figure></p>
<p>实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void *memcpy(void *memTo, const void *memFrom, size_t size) </div><div class="line">&#123; </div><div class="line">　　if((memTo == NULL) || (memFrom == NULL)) // memTo和memFrom必须有效 </div><div class="line">        return NULL; </div><div class="line">　　char* tempFrom = (char* )memFrom; // 保存memFrom首地址 </div><div class="line">　　char* tempTo = (char* )memTo; // 保存memTo首地址 </div><div class="line">　　while(size-–&gt;0) // 循环size次，复制memFrom的值到memTo中 </div><div class="line">        *tempTo++ = *tempFrom++ ; </div><div class="line">　　return memTo; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>说明： memTo 和 memFrom 所指内存区域不能重叠，函数返回指向 memTo 的指针.可以拿它拷贝任何数据类型的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">char a[10],b[5];              </div><div class="line">memcpy(b, a, sizeof(b)); /*注意如果用sizeof(a)，会造成b的内存地址溢出*/</div></pre></td></tr></table></figure></p>
<h4 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h4><p>把 buffer 所指内存区域的前 count 个字节设置成字符 c，主要用于初始化某个内存空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extern void *memset(void *buffer, int c, int count);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">char a[10];                        </div><div class="line">memset(a, &apos;\0&apos;, sizeof(a));</div></pre></td></tr></table></figure>
<h4 id="strcpy-和-memcpy-主要有以下3方面的区别。"><a href="#strcpy-和-memcpy-主要有以下3方面的区别。" class="headerlink" title="strcpy 和 memcpy 主要有以下3方面的区别。"></a>strcpy 和 memcpy 主要有以下3方面的区别。</h4><p>1、复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。<br>2、复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。<br>3、用途不同。<br>emcpy和strcpy区别以及它们的效率分析<br>2015年08月13日 17:46:21<br>阅读数：3457<br>1、首先介绍这两个函数的原型：</p>
<p> #include <cstring><br>char <em>strcpy( char </em>to, const char *from );</cstring></p>
<p> #include <cstring><br>  void <em>memcpy( void </em>to, const void *from, size_t count );<br>从以上两个函数的参数类型和返回类型，可以看出两个函数的第一个不同点：<br>a、strcpy只能应用字符类型的复制，而memcpy应用范围更广，任何类型都可以；</cstring></p>
<p>其次，函数memcpy多了一个count参数，用于拷贝指定字节大小的数据。从这可以得出它们的第二个不同点，</p>
<p>b、memcpy相比使用strcpy会更加的安全，当然也可以使用strcpy的安全板本strncpy函数；</p>
<p>从表面我们还是不能看到这两个函数更加深入的异同，以及它们到底哪个效率更高。下面从它们的源码出发，期望可以解决问题。</p>
<p>2、strcpy函数和memcpy的源码的windows版本</p>
<p>strcpy函数源码：</p>
<p>[cpp] view plain copy<br>char <em> __cdecl strcpy(char </em> dst, const char <em> src)<br>{<br>        char </em> cp = dst;  </p>
<pre><code>while( *cp++ = *src++ )  
        ;               /* Copy src over dst */  

return( dst );  
</code></pre><p>}  </p>
<p>memcpy函数源码：<br>[cpp] view plain copy<br>void <em> __cdecl memcpy (<br>        void </em> dst,<br>        const void <em> src,<br>        size_t count<br>        )<br>{<br>        void </em> ret = dst;  </p>
<p>#if defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC)<br>        {<br>        extern void RtlMoveMemory( void <em>, const void </em>, size_t count );  </p>
<pre><code>RtlMoveMemory( dst, src, count );  
}  
</code></pre><p>#else  /<em> defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) </em>/<br>        /* </p>
<pre><code> * copy from lower addresses to higher addresses 
 */  
while (count--) {  
        *(char *)dst = *(char *)src;  
        dst = (char *)dst + 1;  
        src = (char *)src + 1;  
}  
</code></pre><p>#endif  /<em> defined (_M_MRX000) || defined (_M_ALPHA) || defined (_M_PPC) </em>/  </p>
<pre><code>return(ret);  
</code></pre><p>}  </p>
<p>memcpy中的预定义不用考虑，现在都不支持了，先分析strcpy源码中关键代码：<br>[cpp] view plain copy<br>while( <em>cp++ = </em>src++ )<br>可以看出该循环退出的条件是*cp = ‘\0’，也就是说，源字符串中的结尾‘\0’也被拷贝到目的字符串中，这个很关键。<br>而memcpy中退出循环是count为0,也就是按照用户的要求，拷贝count个字节。</p>
<p>所以从这可以得出两个函数的第3个不同点：</p>
<p>C、strcpy一定会拷贝字符串结尾符’\0’，memcpy在拷贝字符串的时候，根据指定拷贝字节数拷贝字符串，是否拷贝‘\0’结束符，根据count的大小。</p>
<p>最后，从两个函数的源码中，可以分析出哪个函数的效率更快（当然是都拷贝相同的字符串），比较它们的关键代码，也就是循环，可以看出，memcpy函数中，有3个变量在变化，分别是count, dst, src，而strcpy只有两个变量变化，分别是cp和src，从这可以看出strcpy更胜一筹。再者，</p>
<p>[cpp] view plain copy<br><em>cp++ = </em>src++   和   <pre name="code" class="cpp"><em>(char </em>)dst = <em>(char </em>)src;<br>dst = (char <em>)dst + 1;<br>src = (char </em>)src + 1;<br>效果是一样，但下面耗费更大，它有类型转换的花费，在上面中没有的，从这也可以看出strcpy更胜一筹。</pre></p>
<p>综上两点，我认为在拷贝相同字符串，相同字节的情况下，strcpy的效率比memcpy效率更高。</p>
<p>3、下面再实践证明下，如下图。</p>
<p>测试代码：</p>
<p>[cpp] view plain copy</p>
<p>#include <stdio.h>  </stdio.h></p>
<p>#include <string.h><br>int main()<br>{<br>    char src[] = “hello,memcpy and strcpy!”;<br>    char dest[32];<br>    memcpy(dest, src, 25);<br>    //strcpy(dest, src);<br>    return 0;<br>}  </string.h></p>
<p>运行上面代码用时如下：</p>
<p>将memcpy(dest, src, 25);注释，取消下面strcpy(dest, src）运行代码用时如下：</p>
<p>从上可以看出，strcpy以微弱的优势，相比memcpy效率更快。</p>
<p>所以memcpy和strcpy的第四个不同点是：</p>
<p>d、在拷贝相同的字符串，且字节数相同(包括‘]0’)的情况下，strcpy效率比memcpy效率更快。</p>
<p>4、总结，memcpy和strcpy的区别与比较</p>
<p>a、strcpy只能应用字符类型的复制，而memcpy应用范围更广，任何类型都可以；</p>
<p>b、memcpy相比使用strcpy会更加的安全，当然也可以使用strcpy的安全板本strncpy函数；</p>
<p>c、strcpy一定会拷贝字符串结尾符’\0’，memcpy在拷贝字符串的时候，根据指定拷贝字节数拷贝字符串，是否拷贝‘\0’结束符，根据count的大小;</p>
<p>d、在拷贝相同的字符串，且字节数相同(包括‘]0’)的情况下，strcpy效率比memcpy效率更快。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/05/17/ssd-源码分析/">
                ssd 源码分析
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-05-17</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>本文主要讲解 Annotations 中的 label 和 bboxes 是如何在 SSD 中使用的。<br>网络的输入 <code>glabels</code> 和 <code>gbboxes</code> 是无法直接和网络的输出进行比较并计算 losses 的。因此需要首先通过 <code>bboxes_encode</code> 进行编码，得到对应于不同特征层（block）的 <code>feat_labels</code>，<code>feat_localizations</code>，<code>feat_scores</code>(杰卡德系数)，再通过<br><code>feat_labels</code>，<code>feat_localizations</code> 与网络不同特征层（block）的输出进行比较并计算 losses。</p>
<h3 id="anchors-的生成"><a href="#anchors-的生成" class="headerlink" title="anchors 的生成"></a>anchors 的生成</h3><h5 id="维度："><a href="#维度：" class="headerlink" title="维度："></a>维度：</h5><p>anchors type: list A of list B<br>len(A): num_of_blocks, for 300 it’s 6, for 512 it’s 7.<br>B: [y, x, h, w]<br>shape of y, x: for block 4 of 300 is 38 <em> 38 </em> 1(1 is an expanded dim)<br>shape of h, w: for block 4 of 300 is (len(sizes) + len(ratios) = 4, )</p>
<h5 id="生成过程-of-300"><a href="#生成过程-of-300" class="headerlink" title="生成过程 of 300"></a>生成过程 of 300</h5><ol>
<li>feat_shapes: [(38, 38), (19, 19), (10, 10), (5, 5), (3, 3), (1, 1)]<br>分别对应 blocks: [‘block4’, ‘block7’, ‘block8’, ‘block9’, ‘block10’, ‘block11’]</li>
<li>anchor_sizes: [(21., 45.), (45., 99.), (99., 153.), (153., 207.), (207., 261.), (261., 315.)]</li>
<li>anchor_ratios: [[2, .5], [2, .5, 3, 1./3], [2, .5, 3, 1./3], [2, .5, 3, 1./3], [2, .5], [2, .5]]</li>
<li>anchor_steps: [8, 16, 32, 64, 100, 300]</li>
<li>anchor_offset: 0.5<br>For the first feature map (block 4), the y, x:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">y, x = np.mgrid[0:feat_shape[0], 0:feat_shape[1]]</div><div class="line">y = (y.astype(dtype) + offset) * step / img_shape[0]</div><div class="line">x = (x.astype(dtype) + offset) * step / img_shape[1]</div><div class="line"></div><div class="line"># Expand dims to support easy broadcasting.</div><div class="line">y = np.expand_dims(y, axis=-1)</div><div class="line">x = np.expand_dims(x, axis=-1)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>(38 - 1 + 0.5) * 8 = 300<br>So the range of y, x is [4/300, 1.0].<br>y, x 在后续的处理中是当作中心使用的。<br>对于各个 block 的 y，x ，它们都是映射到（大概）原图上的 (0, 1) 之间的值，标记着一些散布在原图上的锚点。</p>
<p>For the first feature map (block 4), the h, w:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">num_anchors = len(sizes) + len(ratios)</div><div class="line">h = np.zeros((num_anchors, ), dtype=dtype)</div><div class="line">w = np.zeros((num_anchors, ), dtype=dtype)</div><div class="line"># Add first anchor boxes with ratio=1.</div><div class="line">h[0] = sizes[0] / img_shape[0]</div><div class="line">w[0] = sizes[0] / img_shape[1]</div><div class="line">di = 1</div><div class="line">if len(sizes) &gt; 1:</div><div class="line">    h[1] = math.sqrt(sizes[0] * sizes[1]) / img_shape[0]</div><div class="line">    w[1] = math.sqrt(sizes[0] * sizes[1]) / img_shape[1]</div><div class="line">    di += 1</div><div class="line">for i, r in enumerate(ratios):</div><div class="line">    h[i+di] = sizes[0] / img_shape[0] / math.sqrt(r)</div><div class="line">    w[i+di] = sizes[0] / img_shape[1] * math.sqrt(r)</div></pre></td></tr></table></figure></p>
<p><img src="http://oytnj8g2y.bkt.clouddn.com/hw.jpg" alt=""></p>
<p>feat_shapes 并非任意指定的值，而真的就是来自卷积神经网络的某一层特征图的尺寸值，即该层特征图的输出尺寸决定了 feat_shapes，feat_shapes 用来指导 anchors 的生成，anchors 的生成决定了神经网络输入的编码，最终<strong>特征图的输出</strong>和<strong>输入编码</strong>之间计算 Loss，指导神经网络的学习过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">def ssd_multibox_layer(inputs,</div><div class="line">                       num_classes,</div><div class="line">                       sizes,</div><div class="line">                       ratios=[1],</div><div class="line">                       normalization=-1,</div><div class="line">                       bn_normalization=False):</div><div class="line">    &quot;&quot;&quot;Construct a multibox layer, return a class and localization predictions.</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    net = inputs</div><div class="line">    if normalization &gt; 0:</div><div class="line">        net = custom_layers.l2_normalization(net, scaling=True)</div><div class="line">    # Number of anchors.</div><div class="line">    num_anchors = len(sizes) + len(ratios)</div><div class="line"></div><div class="line">    # Location.</div><div class="line">    num_loc_pred = num_anchors * 4</div><div class="line">    loc_pred = slim.conv2d(net, num_loc_pred, [3, 3], activation_fn=None,</div><div class="line">                           scope=&apos;conv_loc&apos;)</div><div class="line">    loc_pred = custom_layers.channel_to_last(loc_pred)</div><div class="line">    loc_pred = tf.reshape(loc_pred,</div><div class="line">                          tensor_shape(loc_pred, 4)[:-1]+[num_anchors, 4])</div><div class="line">    # Class prediction.</div><div class="line">    num_cls_pred = num_anchors * num_classes</div><div class="line">    cls_pred = slim.conv2d(net, num_cls_pred, [3, 3], activation_fn=None,</div><div class="line">                           scope=&apos;conv_cls&apos;)</div><div class="line">    cls_pred = custom_layers.channel_to_last(cls_pred)</div><div class="line">    cls_pred = tf.reshape(cls_pred,</div><div class="line">                          tensor_shape(cls_pred, 4)[:-1]+[num_anchors, num_classes])</div><div class="line">    return cls_pred, loc_pred</div></pre></td></tr></table></figure></p>
<h3 id="输入编码"><a href="#输入编码" class="headerlink" title="输入编码"></a>输入编码</h3><p><code>bboxes_encode -&gt; tf_ssd_bboxes_encode -&gt; tf_ssd_bboxes_encode_layer</code><br>input: labels, bboxes of a single image, not a batch of images, because the call of bboxes_encode is invoked before the construction of batch.<br>labels: such as [1, 1, 3]<br>bboxes: such as [[…, …, …, …], […, …, …, …], […, …, …, …]]</p>
<h6 id="编码过程"><a href="#编码过程" class="headerlink" title="编码过程"></a>编码过程</h6><p>一张图，一份 labels ，一份 bboxes，一个 anchor_layer ====&gt;&gt;&gt;&gt; for 循环遍历 labels 和 bboxes，不断计算杰卡德系数，更新属于该 anchor_layer 的对应于该图的 feat_labels 和 feat_scores(也就是杰卡德系数)。<br><img src="http://oytnj8g2y.bkt.clouddn.com/jaccard.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line">def tf_ssd_bboxes_encode_layer(labels,</div><div class="line">                               bboxes,</div><div class="line">                               anchors_layer,</div><div class="line">                               num_classes,</div><div class="line">                               no_annotation_label,</div><div class="line">                               ignore_threshold=0.5,</div><div class="line">                               prior_scaling=[0.1, 0.1, 0.2, 0.2],</div><div class="line">                               dtype=tf.float32):</div><div class="line">    # 这里的 anchors_layer 就是上面讲到的 anchors 生成中的一个</div><div class="line">    # 下面的代码利用到了 numpy 的 auto broadcasting，</div><div class="line">    # 使得 ymin，xmin，ymax，xmax，vol_anchors 的维度都成为类似 block4 的 (38, 38, 4)。</div><div class="line">    yref, xref, href, wref = anchors_layer</div><div class="line">    ymin = yref - href / 2.</div><div class="line">    xmin = xref - wref / 2.</div><div class="line">    ymax = yref + href / 2.</div><div class="line">    xmax = xref + wref / 2.</div><div class="line">    vol_anchors = (xmax - xmin) * (ymax - ymin)</div><div class="line"></div><div class="line">    # feat_labels，feat_scores，feat_ymin，feat_xmin，feat_ymax，feat_xmax 的维度</div><div class="line">    # 都成为类似 block4 的 (38, 38, 4)。</div><div class="line">    shape = (yref.shape[0], yref.shape[1], href.size)</div><div class="line">    feat_labels = tf.zeros(shape, dtype=tf.int64)</div><div class="line">    feat_scores = tf.zeros(shape, dtype=dtype)</div><div class="line">    feat_ymin = tf.zeros(shape, dtype=dtype)</div><div class="line">    feat_xmin = tf.zeros(shape, dtype=dtype)</div><div class="line">    feat_ymax = tf.ones(shape, dtype=dtype)</div><div class="line">    feat_xmax = tf.ones(shape, dtype=dtype)</div><div class="line"></div><div class="line">    # 计算一个 bbox 与该 anchor_layer 上所有 anchor 的杰卡德系数</div><div class="line">    # 返回的 jaccard 维度也类似于 (38, 38, 4)</div><div class="line">    def jaccard_with_anchors(bbox):</div><div class="line">        &quot;&quot;&quot;Compute jaccard score between a box and the anchors.</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        int_ymin = tf.maximum(ymin, bbox[0])</div><div class="line">        int_xmin = tf.maximum(xmin, bbox[1])</div><div class="line">        int_ymax = tf.minimum(ymax, bbox[2])</div><div class="line">        int_xmax = tf.minimum(xmax, bbox[3])</div><div class="line">        h = tf.maximum(int_ymax - int_ymin, 0.)</div><div class="line">        w = tf.maximum(int_xmax - int_xmin, 0.)</div><div class="line">        # Volumes.</div><div class="line">        inter_vol = h * w</div><div class="line">        union_vol = vol_anchors - inter_vol \</div><div class="line">            + (bbox[2] - bbox[0]) * (bbox[3] - bbox[1])</div><div class="line">        jaccard = tf.div(inter_vol, union_vol)</div><div class="line">        return jaccard</div><div class="line"></div><div class="line">    def condition(i, feat_labels, feat_scores,</div><div class="line">                    feat_ymin, feat_xmin, feat_ymax, feat_xmax):</div><div class="line">        &quot;&quot;&quot;Condition: check label index.</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        r = tf.less(i, tf.shape(labels))</div><div class="line">        return r[0]</div><div class="line"></div><div class="line">    def body(i, feat_labels, feat_scores,</div><div class="line">                feat_ymin, feat_xmin, feat_ymax, feat_xmax):</div><div class="line">        &quot;&quot;&quot;Body: update feature labels, scores and bboxes.</div><div class="line">        Follow the original SSD paper for that purpose:</div><div class="line">            - assign values when jaccard &gt; 0.5;</div><div class="line">            - only update if beat the score of other bboxes.</div><div class="line">        &quot;&quot;&quot;</div><div class="line"></div><div class="line">        label = labels[i]</div><div class="line">        bbox = bboxes[i]</div><div class="line">        jaccard = jaccard_with_anchors(bbox)</div><div class="line"></div><div class="line">        # mask 代表仅更新 jaccard 系数大于当前的 feat_scores 的，且 label 有效的部分，其余部分不更新。</div><div class="line">        # label 与 num_classes 的大小关系一定要对，这在 mask = tf.logical_and(mask, label &lt; num_classes) </div><div class="line">        # 中提出了要求，</div><div class="line">        # 一旦 label &lt; num_classes 为假，那么 mask 就会被全部清零，失去更新 feat_labels 和 feat_scores 的机会，</div><div class="line">        # 从而无法作为输入参与到训练中来。</div><div class="line">        # 这会影响到 mAP么？ TO DO!!!!</div><div class="line"></div><div class="line">        mask = tf.greater(jaccard, feat_scores)</div><div class="line">        mask = tf.logical_and(mask, feat_scores &gt; -0.5)</div><div class="line">        mask = tf.logical_and(mask, label &lt; num_classes)</div><div class="line">        imask = tf.cast(mask, tf.int64)</div><div class="line">        fmask = tf.cast(mask, dtype)</div><div class="line"></div><div class="line">        # Update values using mask.</div><div class="line">        feat_labels = imask * label + (1 - imask) * feat_labels</div><div class="line">        feat_scores = tf.where(mask, jaccard, feat_scores)</div><div class="line">        feat_ymin = fmask * bbox[0] + (1 - fmask) * feat_ymin</div><div class="line">        feat_xmin = fmask * bbox[1] + (1 - fmask) * feat_xmin</div><div class="line">        feat_ymax = fmask * bbox[2] + (1 - fmask) * feat_ymax</div><div class="line">        feat_xmax = fmask * bbox[3] + (1 - fmask) * feat_xmax</div><div class="line">        return [i+1, feat_labels, feat_scores,</div><div class="line">                feat_ymin, feat_xmin, feat_ymax, feat_xmax]</div><div class="line">    # Main loop definition.</div><div class="line">    i = 0</div><div class="line">    [i, feat_labels, feat_scores,</div><div class="line">        feat_ymin, feat_xmin,</div><div class="line">        feat_ymax, feat_xmax] = tf.while_loop(condition, body,</div><div class="line">                                            [i, feat_labels, feat_scores,</div><div class="line">                                            feat_ymin, feat_xmin,</div><div class="line">                                            feat_ymax, feat_xmax])</div><div class="line">    </div><div class="line">    # Transform to center / size.</div><div class="line">    feat_cy = (feat_ymax + feat_ymin) / 2.</div><div class="line">    feat_cx = (feat_xmax + feat_xmin) / 2.</div><div class="line">    feat_h = feat_ymax - feat_ymin</div><div class="line">    feat_w = feat_xmax - feat_xmin</div><div class="line"></div><div class="line">    # Encode features.</div><div class="line">    feat_cy = (feat_cy - yref) / href / prior_scaling[0]</div><div class="line">    feat_cx = (feat_cx - xref) / wref / prior_scaling[1]</div><div class="line">    feat_h = tf.log(feat_h / href) / prior_scaling[2]</div><div class="line">    feat_w = tf.log(feat_w / wref) / prior_scaling[3]</div><div class="line"></div><div class="line">    # Use SSD ordering: x / y / w / h instead of ours.</div><div class="line">    feat_localizations = tf.stack([feat_cx, feat_cy, feat_w, feat_h], axis=-1)</div><div class="line">    return feat_labels, feat_localizations, feat_scores</div></pre></td></tr></table></figure></p>
<p>shape of feat_labels, feat_scores is: such as 38 38 4<br>feat_localizations: such as 38 38 4 4<br>feat_localizations 中的每一个值都不是绝对数值，而是相对数值并经过了缩放编码，缩放可控制坐标、长宽两者之间对于 loss 的相对影响力，以及它们和 feat_labels 之间对于 loss的相对影响力。<br>这样就将 glabels 和 gbboxes 通过杰卡德系数这一标准映射到了 anchors 上，glabels 没什么可说的，就是给了 anchor 一个标签，关于 gbboxes 则是给了 anchor 一个绝对的上下左右的界限，并在后续将这个界限转成了相对的缩放后的中心位置和长宽。<br>即将 glabels 和 gbboxes 编到了 anchors 上，形成了图 feat_labels, feat_localizations, feat_scores。</p>
<h3 id="losses-的计算"><a href="#losses-的计算" class="headerlink" title="losses 的计算"></a>losses 的计算</h3><p>logits shape：类似于 (N, 38, 38, 4, num_classes)<br>计算的思想就是首先根据 groundtruth 构建正负样本，gscores 中杰卡德系数大于门限值的对应的就是正样本，小于门限值的对应的就是负样本。由于负样本会远远多于正样本，因此只选择预测最差的一部分进行 hard mining。分别计算在正负样本上的loss并综合起来。一张图片会产生很多个（可能多于目标个数）的正样本以及很多的负样本。<br>上一步的输入编码之后得到的一系列 feat_labels, feat_localizations, feat_scores，分别组装成 list 输入到下面的函数用于与网络的各个特征 block 的输出计算 loss。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"># 参数 logits, localisations, gclasses, glocalisations, gscores 都是对应的是一个批次 batch。</div><div class="line">def ssd_losses(logits, localisations,</div><div class="line">               gclasses, glocalisations, gscores,</div><div class="line">               match_threshold=0.5,</div><div class="line">               negative_ratio=3.,</div><div class="line">               alpha=1.,</div><div class="line">               label_smoothing=0.,</div><div class="line">               scope=None):</div><div class="line">    with tf.name_scope(scope, &apos;ssd_losses&apos;):</div><div class="line">        l_cross_pos = []</div><div class="line">        l_cross_neg = []</div><div class="line">        l_loc = []</div><div class="line">        # 一个 block 一个 block 的来处理</div><div class="line">        for i in range(len(logits)):</div><div class="line">            dtype = logits[i].dtype</div><div class="line">            with tf.name_scope(&apos;block_%i&apos; % i):</div><div class="line">                # positive mask 正样本的 mask</div><div class="line">                pmask = gscores[i] &gt; match_threshold</div><div class="line">                # final positive mask</div><div class="line">                fpmask = tf.cast(pmask, dtype)</div><div class="line">                n_positives = tf.reduce_sum(fpmask)</div><div class="line"></div><div class="line">                # Negative mask. 负样本的 mask，并利用 nvalues 进行筛选。</div><div class="line">                # no_classes 与所有目标重合度不足的为0，表示是背景，1 表示是目标。one vs others。</div><div class="line">                no_classes = tf.cast(pmask, tf.int32)</div><div class="line">                predictions = slim.softmax(logits[i])</div><div class="line">                nmask = tf.logical_and(tf.logical_not(pmask),</div><div class="line">                                       gscores[i] &gt; -0.5)</div><div class="line">                fnmask = tf.cast(nmask, dtype)</div><div class="line">                # nvalues 若anchor是目标则为1， 若anchor是背景则为预测为背景的概率，</div><div class="line">                # nvalues 的值用来筛选 hard negative，如果anchor 即 groundtruth 为背景，</div><div class="line">                # 而predictions[:, :, :, :, 0]很小，则其为 hard negative。</div><div class="line">                # 由 predictions[:, :, :, :, 0] 可知将背景作为一个0类“目标”的必要性。</div><div class="line">                nvalues = tf.where(nmask,</div><div class="line">                                   predictions[:, :, :, :, 0],</div><div class="line">                                   1. - fnmask)</div><div class="line">                nvalues_flat = tf.reshape(nvalues, [-1])</div><div class="line">                # Number of negative entries to select.</div><div class="line">                n_neg = tf.cast(negative_ratio * n_positives, tf.int32)</div><div class="line">                n_neg = tf.maximum(n_neg, tf.size(nvalues_flat) // 8)</div><div class="line">                n_neg = tf.maximum(n_neg, tf.shape(nvalues)[0] * 4)</div><div class="line">                max_neg_entries = 1 + tf.cast(tf.reduce_sum(fnmask), tf.int32)</div><div class="line">                n_neg = tf.minimum(n_neg, max_neg_entries)</div><div class="line"></div><div class="line">                val, idxes = tf.nn.top_k(-nvalues_flat, k=n_neg)</div><div class="line">                minval = val[-1]</div><div class="line">                # Final negative mask.</div><div class="line">                nmask = tf.logical_and(nmask, -nvalues &gt; minval)</div><div class="line">                fnmask = tf.cast(nmask, dtype)</div><div class="line"></div><div class="line">                # Add cross-entropy loss.</div><div class="line">                with tf.name_scope(&apos;cross_entropy_pos&apos;):</div><div class="line">                    loss = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits[i],</div><div class="line">                                                                          labels=gclasses[i])</div><div class="line">                    # 只计算 positive 的loss</div><div class="line">                    loss = tf.losses.compute_weighted_loss(loss, fpmask)</div><div class="line">                    l_cross_pos.append(loss)</div><div class="line"></div><div class="line">                with tf.name_scope(&apos;cross_entropy_neg&apos;):</div><div class="line">                    loss = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits[i],</div><div class="line">                                                                          labels=no_classes)</div><div class="line">                    # 只计算 hard negative 的 loss</div><div class="line">                    loss = tf.losses.compute_weighted_loss(loss, fnmask)</div><div class="line">                    l_cross_neg.append(loss)</div><div class="line"></div><div class="line">                # Add localization loss: smooth L1, L2, ...</div><div class="line">                with tf.name_scope(&apos;localization&apos;):</div><div class="line">                    # Weights Tensor: positive mask + random negative.</div><div class="line">                    weights = tf.expand_dims(alpha * fpmask, axis=-1)</div><div class="line">                    loss = custom_layers.abs_smooth(localisations[i] - glocalisations[i])</div><div class="line">                    loss = tf.losses.compute_weighted_loss(loss, weights)</div><div class="line">                    l_loc.append(loss)</div><div class="line"></div><div class="line">        # Additional total losses...</div><div class="line">        with tf.name_scope(&apos;total&apos;):</div><div class="line">            total_cross_pos = tf.add_n(l_cross_pos, &apos;cross_entropy_pos&apos;)</div><div class="line">            total_cross_neg = tf.add_n(l_cross_neg, &apos;cross_entropy_neg&apos;)</div><div class="line">            total_cross = tf.add(total_cross_pos, total_cross_neg, &apos;cross_entropy&apos;)</div><div class="line">            total_loc = tf.add_n(l_loc, &apos;localization&apos;)</div><div class="line"></div><div class="line">            # Add to EXTRA LOSSES TF.collection</div><div class="line">            tf.add_to_collection(&apos;EXTRA_LOSSES&apos;, total_cross_pos)</div><div class="line">            tf.add_to_collection(&apos;EXTRA_LOSSES&apos;, total_cross_neg)</div><div class="line">            tf.add_to_collection(&apos;EXTRA_LOSSES&apos;, total_cross)</div><div class="line">            tf.add_to_collection(&apos;EXTRA_LOSSES&apos;, total_loc)</div></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整个过程就是生成 anchors，将 labels 和 bboxes 编码到 anchors 上，并和网络的输出比较分别计算出正负样本以及位置的loss。<br>重要的点是：</p>
<ol>
<li>num_classes 与每一个 label 的值关系要对，对于 num_classes =4 ,其 labels 就应该为[0, 1, 2, 3]，而不能是大于等于 num_classes 的其他值。</li>
<li>背景的 label 必须设为 0。</li>
<li><p>sparse_softmax_cross_entropy_with_logits 的实现就是 label = 0 对应着 logits 的第一“列”，label = 1 就对应着 logits 的第二“列”，以此类推，因此如果在设置类名和label之间的映射时出现错误则会使得 loss 的计算不能正确反映真实的loss。比如 num_classes = 3，此时logits为三列，而如果 labels = [0, 1, 3]，如此这般时 loss 的计算就会受到影响。</p>
<ul>
<li>labels: Tensor of shape [d_0, d_1, …, d_{r-1}] (where r is rank of labels and result) and dtype int32 or int64. Each entry in labels must be an index in [0, num_classes). Other values will raise an exception when this op is run on CPU, and return NaN for corresponding loss and gradient rows on GPU.</li>
<li>logits: Unscaled log probabilities of shape [d_0, d_1, …, d_{r-1}, num_classes] and dtype float32 or float64.</li>
</ul>
</li>
</ol>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/05/17/C-Miscellaneous/">
                C++ Miscellaneous
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-05-17</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="子类父类的同名函数"><a href="#子类父类的同名函数" class="headerlink" title="子类父类的同名函数"></a>子类父类的同名函数</h3><p>子类和父类的方法之间就只能是重写，不允许重载，如果你试图重载发生的就只能是隐藏，子类的方法会完全隐藏父类所有的同名函数，即<strong>你在子类中定义了一个父类中函数的同名函数，则父类中所有的同名函数对于子类来说均不可用了</strong>，一是因为发生重写，二是因为不允许子类和父类的方法之间发生重载，子类中的这个函数会完全隐藏父类所有的同名函数。</p>
<h3 id="为什么对于存在虚函数的类中析构函数要定义成虚函数"><a href="#为什么对于存在虚函数的类中析构函数要定义成虚函数" class="headerlink" title="为什么对于存在虚函数的类中析构函数要定义成虚函数"></a>为什么对于存在虚函数的类中析构函数要定义成虚函数</h3><p>存在虚函数的类，也就是多态，<strong>经常会（如果不是总会的话）</strong>用一个基类指针去指向一个派生类对象，如果析构函数是 non-virtual 的，当 delete 基类指针时，其结果是未定义的，实际执行时通常发生的是对象的 derived 成分未被销毁。 即调用的是基类的析构函数，而派生类的析构函数未能执行，会造成一个诡异的“局部销毁”对象，这会导致资源泄露，数据结构败坏，在调试器上浪费很多的时间。<br>用一个基类指针指向派生类的对象时，不管存不存在虚函数，delete 基类指针都会陷入局部销毁的陷阱。如果你企图继承一个标准容器或者任何其他的“带有non-virtual析构函数”的 class，拒绝诱惑吧。<strong>基类应该有个虚析构函数。</strong>这一句话说的是带有多态性质的基类，即“通过基类的接口处理派生类对象”。有的类不是意图当作基类的，有的基类并不用于多态性质，即并非被设计用来“通过基类的接口处理派生类对象”，这样的类是不需为其提供虚析构函数的，因为它们就不可能陷入“局部销毁”陷阱。如果一个类你是企图设计它作为基类，那么它就应该拥有一个虚析构函数，这样的话，就当 delete 一个指向派生类对象的基类指针时就绝不会陷入“局部销毁”的陷阱了。由于像 string 这些标准库中的类就不是设计用来当作基类的，所有没有虚析构函数，不该尝试对其进行继承操作。<br>不是企图当作基类的类，不该为其定义虚函数，这是出于空间和移植性的考虑；虚函数的语义就是强制派生类对其进行重写，也就是这个类是意图当作基类的语义。所以在一个侧面，虚函数和基类是挂钩的。<br>当将一个类的析构函数申明为纯虚函数，这个类变成了一个抽象类，与普通的纯虚函数不一样的是，你必须要为这个纯虚析构函数提供一份定义，不然的话就会导致链接错误，这和析构函数的运作方式有关。析构函数的运作方式是：最深层派生的那个class其析构函数最先被调用，然后是其每一个基类的析构函数被调用，编译器会在类A的派生类的析构函数中创建一个对 ~A 的调用动作， 所以必须要为这个函数提供一份定义，否则链接器就会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class A</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    virtual ~A()=0;    </div><div class="line">&#125;;</div><div class="line">A::~A() &#123;&#125;</div></pre></td></tr></table></figure></p>
<h3 id="析构函数能抛出异常吗"><a href="#析构函数能抛出异常吗" class="headerlink" title="析构函数能抛出异常吗"></a>析构函数能抛出异常吗</h3><p>C++ 并不禁止析构函数抛出异常，当它并不鼓励你这样做。只要析构函数抛出异常，即使并非使用容器或者array，程序也可能过早结束或者出现不明确的行为。请记住：</p>
<ol>
<li>析构函数绝对不要抛出异常，如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吐下它们（不传播）或者结束程序。</li>
<li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通函数（而非在析构函数）中执行该操作。</li>
</ol>
<h3 id="构造函数和析构函数中能调用虚函数吗？"><a href="#构造函数和析构函数中能调用虚函数吗？" class="headerlink" title="构造函数和析构函数中能调用虚函数吗？"></a>构造函数和析构函数中能调用虚函数吗？</h3><p>绝对不要在构造函数和析构函数中调用虚函数，而且确保它们调用的所有函数也都服从这一约束。是因为如此并不能做到多态，这与构造函数和析构函数的运作方式有关，当在继承链中执行构造或者析构时，派生类的对象尚未存在或者已经不复存在，不能做到多态，这与你的设计初衷不符会使得程序的执行结果不符预期，所以就不要这样做。在构造和析构期间不要调用虚函数，因为这类调用从不能下降至派生类，这是合理的，是因为此时派生类的特有成员变量会呈现未定义状态，不管是因为尚未定义或是已经销毁，一旦下降至派生类并调用函数可能会触发对这些未定义变量的访问。</p>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><ol>
<li>什么时候改变引用计数？<br>构造函数中计数初始化为1；拷贝构造函数中计数值加1；赋值运算符中，左边的对象引用计数减一，右边的对象引用计数加一；析构函数中引用计数减一；在赋值运算符和析构函数中，如果减一后为0，则调用delete释放对象。</li>
</ol>
<ul>
<li>当用一个 shared_ptr 初始化另一个 shared_ptr</li>
<li>作为函数参数传递给一个函数</li>
<li>作为函数的返回值</li>
<li>给 shared_ptr 赋予一个新值</li>
<li>shared_ptr 被销毁，例如一个局部的 shared_ptr 离开其作用域</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;memory&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    shared_ptr&lt;string&gt; p1(new string(&quot;Jasmine&quot;));</div><div class="line">    shared_ptr&lt;string&gt; p2(new string(&quot;Robert&quot;), [] (string* p) &#123;</div><div class="line">        cout &lt;&lt; &quot;But maybe there is hope.&quot; &lt;&lt; endl;</div><div class="line">        delete p;</div><div class="line">    &#125;);</div><div class="line">    vector&lt;shared_ptr&lt;string&gt;&gt; v;</div><div class="line">    v.push_back(p1);</div><div class="line">    v.push_back(p1);</div><div class="line">    v.push_back(p2);</div><div class="line">    cout &lt;&lt; *p1 &lt;&lt; &quot; Love &quot; &lt;&lt; *p2 &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; p1.use_count() &lt;&lt; &quot;;&quot; &lt;&lt; p2.use_count() &lt;&lt; endl;</div><div class="line">    p1 = p2;</div><div class="line">    // 这时候 p1 和 p2 是 “同一个” shared_ptr。</div><div class="line">    cout &lt;&lt; p1.use_count() &lt;&lt; &quot;;&quot; &lt;&lt; p2.use_count() &lt;&lt; endl;</div><div class="line">    // 这样查看才是正确的。</div><div class="line">    cout &lt;&lt; v[0].use_count() &lt;&lt; &quot;;&quot; &lt;&lt; p2.use_count() &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; &quot;This is a sad story~&quot; &lt;&lt; endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Jasmine Love Robert</div><div class="line">3;2</div><div class="line">3;3</div><div class="line">2;3</div><div class="line">This is a sad story~</div><div class="line">But maybe there is hope.</div></pre></td></tr></table></figure></p>
<ol>
<li><p>智能指针是怎么实现的？<br>基于引用计数的智能指针实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">// 基于引用计数的智能指针简单实现</div><div class="line">template&lt;class T&gt;</div><div class="line">class SmartPtr</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    SmartPtr(T *p);</div><div class="line">    ~SmartPtr();</div><div class="line">    SmartPtr(const SmartPtr &amp; orig);            // 浅拷贝</div><div class="line">    SmartPtr&amp; operator=(const SmartPtr &amp; rhs);    // 浅拷贝</div><div class="line">private:</div><div class="line">    T *ptr;</div><div class="line">    // 将 use_count 声明成指针是为了方便对其的递增或递减操作</div><div class="line">    int *use_count;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">template&lt;class T&gt;</div><div class="line">SmartPtr&lt;T&gt;::SmartPtr(T *p) : ptr(p)</div><div class="line">&#123;</div><div class="line">    try</div><div class="line">    &#123;   // 动态分配一个整型对象，并用 1 进行初始化</div><div class="line">        use_count = new int(1);</div><div class="line">    &#125;</div><div class="line">    catch (...)</div><div class="line">    &#123;</div><div class="line">        delete ptr;</div><div class="line">        ptr = nullptr;</div><div class="line">        use_count = nullptr;</div><div class="line">        cout &lt;&lt; &quot;Allocate memory for use_count fails.&quot; &lt;&lt; endl;</div><div class="line">        exit(1);</div><div class="line">    &#125;</div><div class="line">    cout &lt;&lt; &quot;Constructor is called!&quot; &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">template&lt;class T&gt;</div><div class="line">SmartPtr&lt;T&gt;::~SmartPtr()</div><div class="line">&#123;</div><div class="line">    // 只在最后一个对象引用ptr时才释放内存</div><div class="line">    if (--(*use_count) == 0)</div><div class="line">    &#123;</div><div class="line">        delete ptr;</div><div class="line">        delete use_count;</div><div class="line">        ptr = nullptr;</div><div class="line">        use_count = nullptr;</div><div class="line">        cout &lt;&lt; &quot;Destructor is called!&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">template&lt;class T&gt;</div><div class="line">SmartPtr&lt;T&gt;::SmartPtr(const SmartPtr&lt;T&gt; &amp;orig)</div><div class="line">&#123;</div><div class="line">    ptr = orig.ptr;</div><div class="line">    use_count = orig.use_count;</div><div class="line">    ++(*use_count);</div><div class="line">    cout &lt;&lt; &quot;Copy constructor is called!&quot; &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 拷贝赋值运算符不同于拷贝构造函数，即等号左边的对象可能已经指向某块内存。</div><div class="line">// 这样，我们就需要判断左边对象指向的内存已经被引用的次数。如果次数为1，</div><div class="line">// 表明我们可以释放这块内存；反之则不释放，由其他对象来释放。</div><div class="line">template&lt;class T&gt;</div><div class="line">SmartPtr&lt;T&gt;&amp; SmartPtr&lt;T&gt;::operator=(const SmartPtr&lt;T&gt; &amp;rhs)</div><div class="line">&#123;</div><div class="line">    // 《C++ primer》：“这个赋值操作符在减少左操作数的使用计数之前使 rhs 的使用计数加1，</div><div class="line">    // 从而防止自身赋值”而导致的提早释放内存</div><div class="line">    ++(*rhs.use_count);</div><div class="line"></div><div class="line">    // 将左操作数对象的使用计数减1，若该对象的使用计数减至0，则删除该对象</div><div class="line">    if (--(*use_count) == 0)</div><div class="line">    &#123;   </div><div class="line">        // 左操作数是最后一个指向管理对象的智能指针了，</div><div class="line">        // 虽然左侧操作数这个对象本身不至删除，但是左操作数所管理的对象及左操作数原来所分配的空间必须被销毁。</div><div class="line">        delete ptr;</div><div class="line">        delete use_count;</div><div class="line">        cout &lt;&lt; &quot;Left side object is deleted!&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ptr = rhs.ptr;</div><div class="line">    use_count = rhs.use_count;</div><div class="line">    </div><div class="line">    cout &lt;&lt; &quot;Assignment operator is called!&quot; &lt;&lt; endl;</div><div class="line">    return *this;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>share_prt与weak_ptr的区别？<br>只要有一个 shared_ptr 指向一个对象，这个对象就不会被销毁。<br>而一旦指向一个对象的最后一个 shared_ptr 被销毁，这个对象就会被销毁，即使有 weak_ptr 指向这个对象。<br>weak_ptr 不控制所指向对象的生存期，将一个 weak_ptr 绑定到一个 shared_ptr 上，并不增加 shared_ptr 所管理对象的引用计数，体现出了“弱”共享对象的特点。</p>
</li>
</ol>
<h3 id="内存对齐的原则"><a href="#内存对齐的原则" class="headerlink" title="内存对齐的原则"></a>内存对齐的原则</h3><p>CPU 的优化原则: 对于 n 个字节的元素(n=2, 4, 8,…) ,它的首地址能被 n 整除,才能获得最好的性能.设计编译器时可以这样做:对于每一个变量,从当前位置向后找到第一个满足这样条件的地址作为首地址.<br>结构体长度一定是最长元素的整数倍,这样当其放入数组的时候,才不会为遵守CPU 的优化原则而产生空隙.</p>
<h3 id="内联函数有什么优点？内联函数与宏定义的区别？"><a href="#内联函数有什么优点？内联函数与宏定义的区别？" class="headerlink" title="内联函数有什么优点？内联函数与宏定义的区别？"></a>内联函数有什么优点？内联函数与宏定义的区别？</h3><p>内联函数和普通函数相比可以加快程序运行的速度，因为不需要中断调用，在编译的时候内联函数可以直接被镶嵌到目标代码中。<br>用内联函数完全取代宏：</p>
<ol>
<li>内联函数可利用调试器进行调试，而宏定义不可以;</li>
<li>编译器会对内联函数的参数类型做安全检查或自动类型转换（同普通函数），而宏定<br>义则不会； </li>
<li>内联函数可以访问类的成员变量，宏定义则不能； </li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数。</li>
</ol>
<p>inline 是指嵌入代码，就是在调用函数的地方不是跳转，而是把代码直接写到那里去。对于短小的代码来说，inline可以带来一定的效率提升，而且和C时代的宏函数相比，inline 更安全可靠。可是这个是以增加空间消耗为代价的。至于是否需要inline函数就需要根据你的实际情况取舍了, 频繁的调用内联函数和宏定义容易造成代码膨胀，消耗更大的内存而<strong>造成过多的换页操作</strong>。</p>
<p>inline一般只用于如下情况：</p>
<ol>
<li>一个函数不断被重复调用。</li>
<li>函数只有简单的几行，且函数不包含for、while、switch语句等复杂结构, 否则编译器不会将其当作内联函数看待，而是把它决议成为一个静态函数.<br>宏不是函数，只是在编译预处理阶段将程序中有关字符串替换成宏体。<br>inline函数是函数，但在编译中不单独产生代码，而是将有关代码嵌入到调用处。<br>关于类的例子如下:<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Class A</div><div class="line">&#123;</div><div class="line">public：</div><div class="line">    int readTest（）</div><div class="line">    &#123;</div><div class="line">        return nTest；</div><div class="line">    &#125;</div><div class="line">    void setTest（int i);</div><div class="line">&#125;;</div><div class="line">inline void A::setTest(int i)</div><div class="line">&#123;</div><div class="line">    nTest=i;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>类A的成员函数readTest（）和setTest（）都是内联函数，readTest（）函数的定义体被放在类声明之中，因而 readTest（）自动转换成inline函数，setTest函数的定义体在类声明之外，因此要加上inline关键字。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/05/05/喂饱GPU：多线程加载图像数据/">
                喂饱GPU：多线程加载图像数据
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-05-05</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>在训练卷积神经网络时，为了充分利用GPU的计算能力，让GPU充分运转，减少GPU等待批次（batch）数据的时间，需要进行图像数据加载的并行编程。可以进行多进程或者多线程编程，需要注意的是，由于 Python GIL 的存在，基于多线程的并行编程仅适用于 I/O 密集型的并发，并不适用于 CPU 计算密集型的并发。因此，如果图像数据加载（I/O密集型）后，需要进行图像数据的预处理（CPU 计算密集型），推荐使用多进程编程，关于多进程编程我后续会写一篇博客进行介绍，本文主要介绍我在使用使用多线程加载图像数据时遇到的一些知识点，主要包括：</p>
<ul>
<li>加锁：关键代码区访问控制</li>
<li>双重锁验证</li>
<li>长时代码移出关键代码区</li>
</ul>
<p>另外如果想了解关于线程之间通信的相关知识，可以查看我的另一篇博文<a href="https://robertlexis.github.io/2017/11/05/Python-threads-communication-and-stopping/" target="_blank" rel="external">Python threads: communication and stopping</a>。</p>
<h3 id="加锁，关键代码区访问控制"><a href="#加锁，关键代码区访问控制" class="headerlink" title="加锁，关键代码区访问控制"></a>加锁，关键代码区访问控制</h3><p>利用锁划定关键代码区，使得同一时刻只能有一个线程在执行该关键代码区的代码，之所以要进行如此的访问控制，是因为在多线程中，“全局”变量是由线程共享的，进行访问控制可以防止多个线程同时修改同一个“全局”变量造成变量的值的错乱。</p>
<p>在 Python 中利用锁划定关键代码区有两种方式，<strong>手动方式</strong>和<strong>上下文管理器方式</strong>，无论使用哪种方式，都要求即使在关键代码区的代码发生异常时，依然可以正常的释放锁，不然该异常线程一直持有锁会导致其他线程一直处于等待锁被释放的状态，不能正常的处理工作和退出。</p>
<p>手动方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">lock = threading.Lock()</div><div class="line">def thread_function():</div><div class="line">    ...</div><div class="line">    lock.acquire()</div><div class="line">    ~~~~~~~~~~~~~~~~~~~~~~ begin of critical code region</div><div class="line">    try:</div><div class="line">        ...</div><div class="line">    finally:</div><div class="line">    ~~~~~~~~~~~~~~~~~~~~~~ end of critical code region</div><div class="line">        lock.release()</div><div class="line">    ...</div></pre></td></tr></table></figure></p>
<p>上下文管理器方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">lock = threading.Lock()</div><div class="line">def thread_function():</div><div class="line">    ...</div><div class="line">    with lock：</div><div class="line">        ~~~~~~~~~~~~~~~~~~~~~~ begin of critical code region</div><div class="line">        ...</div><div class="line">        ~~~~~~~~~~~~~~~~~~~~~~ end of critical code region</div><div class="line">    ...</div></pre></td></tr></table></figure></p>
<p>上下文管理器方式的方式可以自动在异常时释放锁，并且代码结构上也更加简洁清晰，是推荐的划定关键代码区的方式。</p>
<h3 id="双重锁验证"><a href="#双重锁验证" class="headerlink" title="双重锁验证"></a>双重锁验证</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">import numpy as np</div><div class="line">from skimage import io</div><div class="line">import os</div><div class="line"></div><div class="line">directory = &quot;images/&quot;</div><div class="line">filenames = [name for name in os.listdir(directory)]</div><div class="line">num_images = len(filenames)</div><div class="line"></div><div class="line">images = np.empty((num_images, 256, 256, 3))</div><div class="line">current_image_index = 0</div><div class="line">lock = threading.Lock()</div><div class="line"></div><div class="line">def load_images(directory):</div><div class="line">    global current_image_index</div><div class="line">    global images</div><div class="line">    while current_image_index &lt; num_images: # 第一次验证</div><div class="line">        with lock:</div><div class="line">            if current_image_index &lt; num_images: # 第二次验证</div><div class="line">                image = io.imread(os.path.join(directory, filenames[current_image_index]))</div><div class="line">                images[current_image_index] = image</div><div class="line">                current_image_index += 1</div><div class="line">num_threads = 4</div><div class="line">threads = []</div><div class="line">for i in range(num_threads):</div><div class="line">    t = threading.Thread(target=load_images, args=(directory, ))</div><div class="line">    threads.append(t)</div><div class="line"></div><div class="line"># Fire all threads up</div><div class="line">for t in threads:</div><div class="line">    t.start()</div><div class="line"></div><div class="line"># wait for all threads</div><div class="line">for t in threads:</div><div class="line">    t.join()</div></pre></td></tr></table></figure>
<p>上面的代码起了4个线程，它们分别根据全局变量 <code>current_image_index</code> 的指示加载图像并将图像数据赋给全局变量 <code>images</code>。<br>第一次验证控制循环的退出和线程的退出，只要 <code>current_image_index</code> 小于 <code>num_images</code>，说明目录中尚有图像未被加载，需要进入循环继续加载。进入循环之后首先请求锁构建关键代码区，因为我们要对共享全局变量进行修改了，而这必须发生在关键代码区。如果线程获得锁，就进入关键代码区执行；如果当前有其他线程持有锁，该线程就“堵塞”在此处直到其他线程释放锁并且该线程获得锁，才进入关键代码区。</p>
<p>进入关键代码区之后，我们进行了第二次验证，这是因为线程在等待获得锁的过程中流逝了一段时间，可能有其他线程加载了一些图像并修改了 <code>current_image_index</code> 的值，导致目录中的图像文件被加载完并设置 <code>current_image_index</code> 等于了 <code>num_images</code>，因此在进行加载之前需要再次进行验证，仅在 <code>current_image_index</code> 小于 <code>num_images</code> 时才进行加载，否则就会发生filenames 列表的访问越界错误。</p>
<h3 id="长时代码移出关键代码区"><a href="#长时代码移出关键代码区" class="headerlink" title="长时代码移出关键代码区"></a>长时代码移出关键代码区</h3><p>上一部分中的代码实际上是“伪”多线程，我们是起了 4 个线程，但是难道这 4 个线程真的是在并行地处理各自的工作吗？<br><code>image = io.imread(os.path.join(directory, filenames[current_image_index]))</code> 这一行是每一个线程的主要功能代码，也是耗时较长的部分（涉及到 I/O 操作，虽然没有太多的指令，即不是 CPU 密集型，但是却是耗时较长的部分），它被放到了关键代码区！！这意味着这实际上是在“单线程”执行着的，因为在关键代码区实际上由于锁的控制使得同一时刻只能有一个线程进入关键代码区。</p>
<p>我们要做就是要把长时代码移出关键代码区，从而实现“真”多线程。</p>
<p>这里需要记住的一点就是：关键代码区的代码运行时间要短，这是因为在关键代码区实际上由于锁的控制使得同一时刻只能有一个线程进入关键代码区，即“单线程模式”，为了减少其他线程的等待时间，提高“并行模式”运行时间 vs “单线程模式”运行时间的比例。做到这一点，就要求在关键代码区中仅进行全局共享变量的修改，而将长时代码移出关键代码区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">import numpy as np</div><div class="line">from skimage import io</div><div class="line">import os</div><div class="line"></div><div class="line">directory = &quot;images/&quot;</div><div class="line">filenames = [name for name in os.listdir(directory)]</div><div class="line">num_images = len(filenames)</div><div class="line"></div><div class="line">images = np.empty((num_images, 256, 256, 3))</div><div class="line">current_image_index = 0</div><div class="line">lock = threading.Lock()</div><div class="line"></div><div class="line">def load_images(directory):</div><div class="line">    global current_image_index</div><div class="line">    global images</div><div class="line">    while current_image_index &lt; num_images: # 第一次验证</div><div class="line">        with lock:</div><div class="line">            if current_image_index &lt; num_images: # 第二次验证</div><div class="line">                index = current_image_index</div><div class="line">                current_image_index += 1</div><div class="line">            else:</div><div class="line">                break</div><div class="line"></div><div class="line">        image = io.imread(os.path.join(directory, filenames[index]))</div><div class="line"></div><div class="line">        with lock:</div><div class="line">            images[index] = image</div><div class="line"></div><div class="line">num_threads = 4</div><div class="line">threads = []</div><div class="line">for i in range(num_threads):</div><div class="line">    t = threading.Thread(target=load_images, args=(directory, ))</div><div class="line">    threads.append(t)</div><div class="line"></div><div class="line"># Fire all threads up</div><div class="line">for t in threads:</div><div class="line">    t.start()</div><div class="line"></div><div class="line"># wait for all threads</div><div class="line">for t in threads:</div><div class="line">    t.join()</div></pre></td></tr></table></figure></p>
<p>上面的代码通过将一个关键代码区分成两个关键代码区，将图像文件打开代码移出了关键代码区，并使用线程局部变量 <code>index</code> 来标识该线程当前要加载的图像。通过实验可以发现，整个程序的运行时间减少了。</p>
<h3 id="实验对比"><a href="#实验对比" class="headerlink" title="实验对比"></a>实验对比</h3><p><img src="http://oytnj8g2y.bkt.clouddn.com/python/concurrency/compare.png" alt="compare"><br>“真”多线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">import time</div><div class="line"></div><div class="line"></div><div class="line">num_iterations = 100</div><div class="line"></div><div class="line">current_iteration = 0</div><div class="line"></div><div class="line">lock = threading.Lock()</div><div class="line"></div><div class="line">def thread_function():</div><div class="line">    global current_iteration</div><div class="line">    while current_iteration &lt; num_iterations: # 第一次验证</div><div class="line">        with lock:</div><div class="line">            if current_iteration &lt; num_iterations: # 第二次验证</div><div class="line">                iteration = current_iteration</div><div class="line">                current_iteration += 1</div><div class="line">            else:</div><div class="line">                break</div><div class="line"></div><div class="line">        # using iteration</div><div class="line">        # Long running time code </div><div class="line">        time.sleep(0.1)</div><div class="line"></div><div class="line">        with lock:</div><div class="line">            pass</div><div class="line"></div><div class="line">num_threads = 4</div><div class="line">threads = []</div><div class="line">for i in range(num_threads):</div><div class="line">    t = threading.Thread(target=thread_function)</div><div class="line">    threads.append(t)</div><div class="line"></div><div class="line">tic = time.time()</div><div class="line"># Fire all threads up</div><div class="line">for t in threads:</div><div class="line">    t.start()</div><div class="line"></div><div class="line"># wait for all threads</div><div class="line">for t in threads:</div><div class="line">    t.join()</div><div class="line">toc = time.time()</div><div class="line">print(&quot;Time elapsed %.2f&quot; % (toc - tic))</div></pre></td></tr></table></figure></p>
<p>“伪”多线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">import time</div><div class="line"></div><div class="line"></div><div class="line">num_iterations = 100</div><div class="line"></div><div class="line">current_iteration = 0</div><div class="line"></div><div class="line">lock = threading.Lock()</div><div class="line"></div><div class="line">def thread_function():</div><div class="line">    global current_iteration</div><div class="line">    while current_iteration &lt; num_iterations: # 第一次验证</div><div class="line">        with lock:</div><div class="line">            if current_iteration &lt; num_iterations: # 第二次验证</div><div class="line">                iteration = current_iteration</div><div class="line">                current_iteration += 1</div><div class="line">                # using iteration</div><div class="line">                # Long running time code </div><div class="line">                time.sleep(0.1)</div><div class="line"></div><div class="line">num_threads = 4</div><div class="line">threads = []</div><div class="line">for i in range(num_threads):</div><div class="line">    t = threading.Thread(target=thread_function)</div><div class="line">    threads.append(t)</div><div class="line"></div><div class="line">tic = time.time()</div><div class="line"># Fire all threads up</div><div class="line">for t in threads:</div><div class="line">    t.start()</div><div class="line"></div><div class="line"># wait for all threads</div><div class="line">for t in threads:</div><div class="line">    t.join()</div><div class="line">toc = time.time()</div><div class="line">print(&quot;Time elapsed %.2f&quot; % (toc - tic))</div></pre></td></tr></table></figure></p>
<p>单线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">import time</div><div class="line"></div><div class="line"></div><div class="line">num_iterations = 100</div><div class="line"></div><div class="line">tic = time.time()</div><div class="line"></div><div class="line">for iteration in range(num_iterations):</div><div class="line">    # using iteration</div><div class="line">    # Long running time code </div><div class="line">    time.sleep(0.1)</div><div class="line"></div><div class="line">toc = time.time()</div><div class="line">print(&quot;Time elapsed %.2f&quot; % (toc - tic))</div></pre></td></tr></table></figure></p>
<p>相关的代码放置在我的 GitHub <a href="https://github.com/RobertLexis/python_concurrency" target="_blank" rel="external">仓库</a>中。</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/04/12/Loss-functions-推导及理解/">
                Loss functions 推导及理解
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-04-12</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <p>本博文主要是在学习 <a href="http://cs231n.stanford.edu/2017/" target="_blank" rel="external">CS231n: Convolutional Neural Networks for Visual Recognition Spring 2017</a> Lecture 3: Loss Functions and Optimization 之后的总结。<br></p>
        </div>
        <a href="/2018/04/12/Loss-functions-推导及理解/" class="read-more">Read More</a>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/04/01/C-多态/">
                C++多态
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-04-01</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="C-多态的实现？"><a href="#C-多态的实现？" class="headerlink" title="C++多态的实现？"></a>C++多态的实现？</h3><p>多态性可以简单地概括为“一个接口，多种实现”，程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。<br>C++多态性是通过虚函数来实现的，重写虚函数。<br>多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译时就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。<br>封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。<br>最常见的用法就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同类型而调用不同的方法。如果没有使用虚函数的话，即没有利用C++多态性，则利用基类指针调用相应的函数的时候，将总被限制在基类函数，而无法调用到子类中被重写过的函数。因为没有多态性，函数调用的地址将是一定的，而固定的地址将始终调用到同一个函数，这就无法实现一个接口，多种实现的目的了。</p>
<h3 id="虚函数的作用？"><a href="#虚函数的作用？" class="headerlink" title="虚函数的作用？"></a>虚函数的作用？</h3><p>虚函数用于实现多态，这点大家都能答上来但是虚函数在设计上还具有封装和抽象的作用。比如抽象工厂模式。<br>每个虚函数都有一个虚函数列表，根据指向对象的类型不同，函数地址也将不同。</p>
<h3 id="virtual-的语义就是强制派生类重写该函数。"><a href="#virtual-的语义就是强制派生类重写该函数。" class="headerlink" title="virtual 的语义就是强制派生类重写该函数。"></a>virtual 的语义就是强制派生类重写该函数。</h3><h3 id="C-纯虚函数"><a href="#C-纯虚函数" class="headerlink" title="C++纯虚函数"></a>C++纯虚函数</h3><p>引入原因：在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。含有纯虚拟函数的类称为抽象类，它不能生成对象。<br>多态性：指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。C++支持两种多态性：编译时多态性，运行时多态性。 </p>
<ul>
<li>编译时多态性：通过重载函数实现</li>
<li>运行时多态性：通过虚函数实现<br>静态多态和动态多态。静态多态是指通过模板技术或者函数重载技术实现的多态，其在编译期确定行为。动态多态是指通过虚函数技术实现在运行期动态绑定的技术。</li>
</ul>
<h3 id="动态绑定的实现"><a href="#动态绑定的实现" class="headerlink" title="动态绑定的实现"></a>动态绑定的实现</h3><ol>
<li>为每一个包含虚函数的类设置一个虚表（VTABLE）<br>每当创建一个包含有虚函数的类或从包含虚函数的类派生一个类时，编译器就会为这个类创建一个 VTABLE。在 VTABLE 中，编译器放置了这个类中，或者它的基类中所有已经声明为 virtual 的函数的地址。如果在这个派生类中没有对基类中声明为 virtual 的函数进行重新定义，编译器就使用基类的这个虚函数的地址。<strong>而且所有 VTABLE 中虚函数地址的顺序是完全相同的。</strong></li>
<li>初始化虚指针（VPTR）<br>编译器在这个类的<strong>每个对象</strong>中放置 VPTR。VPTR 在对象的相同的位置（通常都在对象的开头）。VPTR 必须被初始化为指向相应的 VTABLE。</li>
<li>为虚函数调用插入代码<br>当通过基类的指针调用派生类的虚函数时，编译器将在调用处插入相应的代码，以实现通过 VPTR 找到 VTABLE，并根据 VTABLE 中存储的正确的虚函数地址，访问到正确的函数。</li>
</ol>
<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><p>C++ 中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。<br>C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。这意味着我们可以通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。<br>假设我们有这样的一个类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">class Base</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Base()&#123;&#125;;</div><div class="line">    ~Base()&#123;&#125;;</div><div class="line">    virtual void f() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    virtual void g() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    virtual void h() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl;</div><div class="line">    &#125;      </div><div class="line">&#125;;</div><div class="line">typedef void(*Func)(void);</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;   </div><div class="line">    Base b;</div><div class="line">    Func fp = nullptr, gp = nullptr, hp = nullptr;</div><div class="line">    // 打印值一样，值是一样的，但是这个值的意义是不一样的，分别指向32bit空间，整个对象空间，64bit空间，</div><div class="line">    // 这在解引用时就会出现本质的差异。</div><div class="line">    cout &lt;&lt; &quot;虚函数表地址：&quot; &lt;&lt; (int*)(&amp;b) &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; &quot;虚函数表地址：&quot; &lt;&lt; &amp;b &lt;&lt; endl;</div><div class="line">    cout &lt;&lt; &quot;虚函数表地址：&quot; &lt;&lt; (long long*)(&amp;b) &lt;&lt; endl;</div><div class="line">    // 下面这一行会报错，是因为这台机器是64位的，*(int*)(&amp;b) 是一个整型，空间只有32位，</div><div class="line">    // 在强制将其cast成64位地址时，就会报出 cast to pointer from integer of different size [-Wint-to-pointer-cast]</div><div class="line">    // cout &lt;&lt; &quot;虚函数表 — 第一个函数地址：&quot; &lt;&lt; (int*)*(int*)(&amp;b) &lt;&lt; endl;</div><div class="line">    // 当将 int 改成 long long 时就好了，如此将一个 long long 转换成指针（无论是何种类型的指针，此处是整型指针）。</div><div class="line">    // 在64位机器上用 long long*  cast 指针是安全的，而用 int* 则是不安全的。</div><div class="line">    cout &lt;&lt; &quot;虚函数表 — 第一个函数地址：&quot; &lt;&lt; (int*)*(long long*)(&amp;b) &lt;&lt; endl;</div><div class="line">    // Invoke the first virtual function </div><div class="line">    fp = (Func)*((long long*)*(long long*)(&amp;b));</div><div class="line">    fp();</div><div class="line">    gp = (Func)*((long long*)*(long long*)(&amp;b) + 1);</div><div class="line">    gp();</div><div class="line">    hp = (Func)*((long long*)*(long long*)(&amp;b) + 2);</div><div class="line">    hp();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“/0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。</p>
<p>下面将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。</p>
<h4 id="一般继承（无虚函数覆盖）"><a href="#一般继承（无虚函数覆盖）" class="headerlink" title="一般继承（无虚函数覆盖）"></a>一般继承（无虚函数覆盖）</h4><p><img src="http://oytnj8g2y.bkt.clouddn.com/vtable0.JPG" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">class Base</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Base()&#123;&#125;;</div><div class="line">    ~Base()&#123;&#125;;</div><div class="line">    virtual void f() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    virtual void g() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    virtual void h() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl;</div><div class="line">    &#125;      </div><div class="line">&#125;;</div><div class="line">class Derive : public Base</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Derive()&#123;&#125;;</div><div class="line">    ~Derive()&#123;&#125;;</div><div class="line">    virtual void f1() &#123;</div><div class="line">        cout &lt;&lt; &quot;Derive::f1&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    virtual void g1() &#123;</div><div class="line">        cout &lt;&lt; &quot;Derive::g1&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    virtual void h1() &#123;</div><div class="line">        cout &lt;&lt; &quot;Derive::h1&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;;</div><div class="line">typedef void(*Func)(void);</div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;   </div><div class="line"></div><div class="line">    Derive d;</div><div class="line">    Func fp = nullptr, gp = nullptr, hp = nullptr;</div><div class="line">    fp = (Func)*((long long*)*(long long*)(&amp;d));</div><div class="line">    fp();</div><div class="line">    gp = (Func)*((long long*)*(long long*)(&amp;d) + 1);</div><div class="line">    gp();</div><div class="line">    hp = (Func)*((long long*)*(long long*)(&amp;d) + 2);</div><div class="line">    hp();</div><div class="line"></div><div class="line">    Func f1p = nullptr, g1p = nullptr, h1p = nullptr;</div><div class="line">    f1p = (Func)*((long long*)*(long long*)(&amp;d) + 3);</div><div class="line">    f1p();</div><div class="line">    g1p = (Func)*((long long*)*(long long*)(&amp;d) + 4);</div><div class="line">    g1p();</div><div class="line">    h1p = (Func)*((long long*)*(long long*)(&amp;d) + 5);</div><div class="line">    h1p();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Base::f</div><div class="line">Base::g</div><div class="line">Base::h</div><div class="line">Derive::f1</div><div class="line">Derive::g1</div><div class="line">Derive::h1</div></pre></td></tr></table></figure>
<p><img src="http://oytnj8g2y.bkt.clouddn.com/vtable1.JPG" alt=""><br>我们可以看到下面几点：</p>
<ol>
<li>虚函数按照其声明顺序放于表中。</li>
<li>父类的虚函数在子类的虚函数前面。<h4 id="一般继承（有虚函数覆盖）"><a href="#一般继承（有虚函数覆盖）" class="headerlink" title="一般继承（有虚函数覆盖）"></a>一般继承（有虚函数覆盖）</h4>覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。<br><img src="http://oytnj8g2y.bkt.clouddn.com/vtable2.JPG" alt=""><br>为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子：<br><img src="http://oytnj8g2y.bkt.clouddn.com/vtable3.JPG" alt=""><br>我们从表中可以看到下面几点，</li>
<li>覆盖的f()函数被放到了虚表中原来父类虚函数的位置。</li>
<li>没有被覆盖的函数依旧。<br>这样，我们就可以看到对于下面这样的程序，<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Base *b = new Derive();</div><div class="line">b-&gt;f();</div></pre></td></tr></table></figure>
</li>
</ol>
<p>由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。</p>
<h4 id="多重继承（无虚函数覆盖）"><a href="#多重继承（无虚函数覆盖）" class="headerlink" title="多重继承（无虚函数覆盖）"></a>多重继承（无虚函数覆盖）</h4><p>下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。<br><img src="http://oytnj8g2y.bkt.clouddn.com/vtable4.JPG" alt=""><br>对于子类实例中的虚函数表，是下面这个样子：<br><img src="http://oytnj8g2y.bkt.clouddn.com/vtable5.JPG" alt=""><br>我们可以看到：</p>
<ol>
<li>每个父类都有自己的虚表。</li>
<li>子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）</li>
</ol>
<p>这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。</p>
<h4 id="多重继承（有虚函数覆盖）"><a href="#多重继承（有虚函数覆盖）" class="headerlink" title="多重继承（有虚函数覆盖）"></a>多重继承（有虚函数覆盖）</h4><p>下面我们再来看看，如果发生虚函数覆盖的情况。<br>下图中，我们在子类中覆盖了父类的f()函数。<br><img src="http://oytnj8g2y.bkt.clouddn.com/vtable6.JPG" alt=""><br>下面是对于子类实例中的虚函数表的图：<br><img src="http://oytnj8g2y.bkt.clouddn.com/vtable7.JPG" alt=""><br>我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Derive d;</div><div class="line">Base1 *b1 = &amp;d;</div><div class="line">Base2 *b2 = &amp;d;</div><div class="line">Base3 *b3 = &amp;d;</div><div class="line">b1-&gt;f(); //Derive::f()</div><div class="line">b2-&gt;f(); //Derive::f()</div><div class="line">b3-&gt;f(); //Derive::f()</div><div class="line">b1-&gt;g(); //Base1::g()</div><div class="line">b2-&gt;g(); //Base2::g()</div><div class="line">b3-&gt;g(); //Base3::g()</div></pre></td></tr></table></figure></p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>每次写C++的文章，总免不了要批判一下C++。这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。</p>
<ol>
<li>通过父类型的指针访问子类自己的虚函数</li>
</ol>
<p>我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的<strong>自有虚函数</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Base1 *b1 = new Derive();</div><div class="line">b1-&gt;f1();  //编译出错</div></pre></td></tr></table></figure></p>
<p>任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。</p>
<ol>
<li>访问 non-public 的虚函数<br>另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">class Base</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Base()&#123;&#125;;</div><div class="line">    ~Base()&#123;&#125;;</div><div class="line">    virtual void f() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl;</div><div class="line">    &#125;;</div><div class="line">private:</div><div class="line">    virtual void h() &#123;</div><div class="line">        cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line">class Derive: public Base</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    Derive()&#123;&#125;;</div><div class="line">    ~Derive()&#123;&#125;;</div><div class="line">    virtual void f() &#123;</div><div class="line">        cout &lt;&lt; &quot;Derive::f&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">    virtual void g() &#123;</div><div class="line">        cout &lt;&lt; &quot;Derive::g&quot; &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">typedef void(*Func)(void);</div><div class="line"></div><div class="line">int main(int argc, char const *argv[])</div><div class="line">&#123;</div><div class="line">    Base* ptr = new Derive;</div><div class="line">    ptr-&gt;f();</div><div class="line">    // ptr-&gt;g();</div><div class="line">    Func func_ptr = nullptr;</div><div class="line">    func_ptr = (Func)*((long long*)*(long long*)ptr + 1); </div><div class="line">    func_ptr();</div><div class="line">    func_ptr = (Func)*((long long*)*(long long*)ptr + 2); </div><div class="line">    func_ptr();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Derive::f</div><div class="line">Base::h</div><div class="line">Derive::g</div></pre></td></tr></table></figure>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/03/25/STL-内存池实现/">
                STL 内存池实现
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-03-25</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="STL-里的内存池实现"><a href="#STL-里的内存池实现" class="headerlink" title="STL 里的内存池实现"></a>STL 里的内存池实现</h3><h4 id="内存池的目的是什么？"><a href="#内存池的目的是什么？" class="headerlink" title="内存池的目的是什么？"></a>内存池的目的是什么？</h4><ol>
<li>通过 new 表达式动态分配一个对象时，会调用 operator new 进行内存分配，这一步是直接和操作系统打交道的, 操作系统可能需要经过相对繁琐的过程才能将一块指向空闲内存的指针返回给用户, 所以这也是 new 比较耗时的一部分, 而第二步就是使用构造函数进行初始化。既然内存分配耗时, 那我们很容易想到的就是一次性分配一大块内存, 然后在用户需要的时候再划分其中一部分给用户, 这样的话, 一次分配, 多次使用, 自然而然提高了效率, 而用来管理这所谓的一大块内存的内存结构, 也就是今天我们要说的内存池。</li>
<li>内存池带来的另外一个好处在于，频繁地使用new将导致系统内存空间碎片化严重， 容易导致的后果就是很难找到一块连续的大块内存, 空间利用率低，而内存池是一次性分配一大块内存空间，就缓解了内存碎片的问题。</li>
</ol>
<h4 id="一、STL中的内存管理"><a href="#一、STL中的内存管理" class="headerlink" title="一、STL中的内存管理"></a>一、STL中的内存管理</h4><p>当我们 new 一个对象时：</p>
<ol>
<li>使用 operator new 申请了一块内存。</li>
<li>执行构造函数。<br>在SGI中，这两步独立出了两个函数：allocate申请内存，construct调用构造函数。这两个函数分别在<code>&lt;stl_alloc.h&gt;</code>和<code>&lt;stl_construct.h&gt;</code>中。<br><img src="http://oytnj8g2y.bkt.clouddn.com/1.jfif" alt=""></li>
</ol>
<h4 id="二、第一级配置器"><a href="#二、第一级配置器" class="headerlink" title="二、第一级配置器"></a>二、第一级配置器</h4><p>第一级配置器以 malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。</p>
<h4 id="三、第二级配置器"><a href="#三、第二级配置器" class="headerlink" title="三、第二级配置器"></a>三、第二级配置器</h4><p>第二级配置器维护着16个空闲链表（free list），各自管理大小分别为8、16、24、32、40、48、56、64、72、80、88、96、104、112、120、128 bytes的小内存块。<br>如果要分配的内存大于 128bytes，则移交给第一级配置器处理，直接用malloc。<br>如果要分配的内存小于 128bytes，则以内存池管理（memory pool），使用第二级配置器，找出适合的空闲链表, 从其上摘下一个节点将其头指针返回给用户，这就完成了对用户的内存分配。<br>释放过程则正好与分配相对应，如果用户分配的内存大于128bytes，直接用free，否则找出适当的空闲链表， 将指针所指的该段内存重新连接到空闲链表中(注意此时并不把内存返回给操作系统, 如此可以重复利用)。 </p>
<h5 id="1-空闲链表（free-list）的设计"><a href="#1-空闲链表（free-list）的设计" class="headerlink" title="1. 空闲链表（free list）的设计"></a>1. 空闲链表（free list）的设计</h5><p>空闲链表节点的设计十分巧妙，用了一个联合体既可以记录下一个空闲内存块（存在于空闲链表中）的地址，也可以给出分配给用户使用内存块的地址。<br><img src="http://oytnj8g2y.bkt.clouddn.com/2.jfif" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">template &lt;bool threads, int inst&gt;  </div><div class="line">class __default_alloc_template  </div><div class="line">&#123;  </div><div class="line">private:  </div><div class="line">    //将bytes上调至8的倍数  </div><div class="line">    static size_t ROUND_UP(size_t bytes)  </div><div class="line">    &#123;  </div><div class="line">        return (((bytes) + __ALIGN - 1) &amp; ~(__ALIGN - 1));//等价于(bytes + 7) / 8  </div><div class="line">    &#125;  </div><div class="line">    //空闲链表的节点构造 </div><div class="line">    union obj  </div><div class="line">    &#123;  </div><div class="line">        union obj * free_list_link;  </div><div class="line">        char client_data[1];  </div><div class="line">    &#125;;  </div><div class="line">private:  </div><div class="line">    //16个空闲链表，初始化为0，即每个链表中都没有空闲内存块  </div><div class="line">    static obj * volatile free_list[__NFREELISTS];  </div><div class="line">    //根据申请内存块的大小找到相应空闲链表的下标  </div><div class="line">    static  size_t FREELIST_INDEX(size_t bytes)  </div><div class="line">    &#123;  </div><div class="line">        return (((bytes) + __ALIGN - 1)/__ALIGN - 1);  </div><div class="line">    &#125;  </div><div class="line">    ......  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="2-从空闲列表中取内存块"><a href="#2-从空闲列表中取内存块" class="headerlink" title="2. 从空闲列表中取内存块"></a>2. 从空闲列表中取内存块</h5><p>首先先要检查申请空间的大小，如果大于128字节就调用第一级配置器，小于128字节就检查对应的空闲链表，如果该空闲链表中有可用内存块，则直接拿来用（拿取空闲链表中的第一个可用内存块，然后把该空闲链表的地址设置为该内存块指向的下一个地址），如果没有可用内存块，则调用 refill 为该空闲链表填充新的空间。<br><img src="http://oytnj8g2y.bkt.clouddn.com/3.jfif" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//申请大小为 n 的内存块，返回该内存块的起始地址</div><div class="line">static void * allocate(size_t n)  </div><div class="line">&#123;  </div><div class="line">    obj * __VOLATILE * my_free_list;  </div><div class="line">    obj * __RESTRICT result;  </div><div class="line">  </div><div class="line">    if (n &gt; (size_t) __MAX_BYTES)//大于128字节调用第一级配置器  </div><div class="line">    &#123;  </div><div class="line">        return(malloc_alloc::allocate(n));  </div><div class="line">    &#125;  </div><div class="line">    my_free_list = free_list + FREELIST_INDEX(n);//根据申请空间的大小寻找相应的空闲链表（16个空闲链表中的一个）  </div><div class="line">  </div><div class="line">    result = *my_free_list;  </div><div class="line">    if (result == 0)//如果该空闲链表没有空闲的内存块</div><div class="line">    &#123;  </div><div class="line">        void *r = refill(ROUND_UP(n));//为该空闲链表填充新的空间  </div><div class="line">        return r;  </div><div class="line">    &#125;  </div><div class="line">    *my_free_list = result -&gt; free_list_link;//如果空闲链表中有空闲内存块，则取出一个，并把空闲链表的指针指向下一个内存块</div><div class="line">    return (result);  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h5 id="3-从内存池取空间，重新填充空闲链表"><a href="#3-从内存池取空间，重新填充空闲链表" class="headerlink" title="3. 从内存池取空间，重新填充空闲链表"></a>3. 从内存池取空间，重新填充空闲链表</h5><p>在用 allocate 配置空间时，如果空闲链表中没有可用内存块，就会调用refill来为该空闲链表填充新的空间，新的空间取自内存池。缺省取20个内存块，如果内存池空间不足，那么能取多少个节点就取多少个。<br>这里有两种情况会导致没有可用的内存块, 第一种是用光了, 第二种是这是该内存池初始化以来第一次使用这个大小的空闲链表, 所以还未为空闲链表分配过空间。<br><img src="http://oytnj8g2y.bkt.clouddn.com/5.jfif" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">template &lt;bool threads, int inst&gt;  </div><div class="line">void* refill(size_t n)  </div><div class="line">&#123;  </div><div class="line">    int nobjs = 20;  </div><div class="line">    //从内存池里取出nobjs个大小为n的内存块,返回值nobjs为真实申请到的内存块个数，注意这里nobjs个大小为n的内存块所在的空间是连续的</div><div class="line">    char * chunk = chunk_alloc(n, nobjs);</div><div class="line">    obj * __VOLATILE * my_free_list;  </div><div class="line">    obj * result;  </div><div class="line">    obj * current_obj, * next_obj;  </div><div class="line">    int i;  </div><div class="line">  </div><div class="line">    if (1 == nobjs) return(chunk);//如果只获得一个内存块，那么这个内存块就直接分给调用者，空闲链表中不会增加新节点  </div><div class="line">    my_free_list = free_list + FREELIST_INDEX(n);//否则根据申请内存块的大小找到相应空闲链表  </div><div class="line">  </div><div class="line">    result = (obj *)chunk;  </div><div class="line">    *my_free_list = next_obj = (obj *)(chunk + n);//第0个内存块给调用者，地址访问即chunk~chunk + n - 1  </div><div class="line">    for (i = 1; ; i++)//1~nobjs-1的内存块插入到空闲链表  </div><div class="line">    &#123;  </div><div class="line">        current_obj = next_obj;  </div><div class="line">        next_obj = (obj *)((char *)next_obj + n);//由于之前内存池里申请到的空间连续，所以这里需要人工划分成小块一次插入到空闲链表  </div><div class="line">  </div><div class="line">        if (nobjs - 1 == i)  </div><div class="line">        &#123;  </div><div class="line">            current_obj -&gt; free_list_link = 0;  </div><div class="line">            break;  </div><div class="line">        &#125;  </div><div class="line">        else  </div><div class="line">        &#123;  </div><div class="line">            current_obj -&gt; free_list_link = next_obj;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    return(result);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="4-从系统内存取空间给内存池"><a href="#4-从系统内存取空间给内存池" class="headerlink" title="4. 从系统内存取空间给内存池"></a>4. 从系统内存取空间给内存池</h5><p>首先根据end_free-start_free来判断内存池中的剩余空间是否足以调出nobjs个大小为size的内存块出去，如果内存连一个内存块的空间都无法供应，需要用malloc取堆中申请内存。<br><img src="http://oytnj8g2y.bkt.clouddn.com/6.jfif" alt=""><br>申请内存后，如果要拨出去20个大小为8字节的内存块。<br><img src="http://oytnj8g2y.bkt.clouddn.com/7.jfif" alt=""><br>假如山穷水尽，整个系统的堆空间都不够用了，malloc失败，那么chunk_alloc会从空闲链表中找是否有大的内存块，然后将该内存块的空间分给内存池（这个内存块会从链表中去除）。即内存池强制回收空闲链表的内存空间。<br><img src="http://oytnj8g2y.bkt.clouddn.com/8.jfif" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">template &lt;bool threads, int inst&gt;  </div><div class="line">class __default_alloc_template  </div><div class="line">&#123;  </div><div class="line">private:  </div><div class="line">    ......  </div><div class="line">    static char *start_free;//内存池可用空间的起始位置，初始化为0  </div><div class="line">    static char *end_free;//内存池可用空间的结束位置,初始化为0  </div><div class="line">    static size_t heap_size;//内存池的总大小  </div><div class="line">  </div><div class="line">public:  </div><div class="line">    // 申请 nobjs 个大小为size的内存块， </div><div class="line">    // nobjs传进去的是引用，因为可能会出现内存池空间不够的情况，nobjs最终为最后真实申请到的内存块个数</div><div class="line">    static char *chunk_alloc(size_t size, int &amp;nobjs)  </div><div class="line">    &#123;  </div><div class="line">        char * result;  </div><div class="line">        size_t total_bytes = size * nobjs;//需要申请空间的大小  </div><div class="line">        size_t bytes_left = end_free - start_free;//计算内存池剩余空间  </div><div class="line">  </div><div class="line">        //如果内存池剩余空间完全满足需求量  </div><div class="line">        if (bytes_left &gt;= total_bytes)  </div><div class="line">        &#123;  </div><div class="line">            result = start_free;  </div><div class="line">            start_free += total_bytes;  </div><div class="line">            return(result);  </div><div class="line">        &#125;  </div><div class="line">        //内存池剩余空间不满足需求量，但是至少能够提供一个以上内存块  </div><div class="line">        else if (bytes_left &gt;= size)  </div><div class="line">        &#123;  </div><div class="line">            nobjs = bytes_left / size;  </div><div class="line">            total_bytes = size * nobjs;  </div><div class="line">            result = start_free;  </div><div class="line">            start_free += total_bytes;  </div><div class="line">            return(result);  </div><div class="line">        &#125;  </div><div class="line">        //剩余空间连一个内存块（大小为size）也无法提供  </div><div class="line">        else  </div><div class="line">        &#123;  </div><div class="line">            size_t bytes_to_get = 2 * total_bytes + ROUND_UP(heap_size &gt;&gt; 4);  </div><div class="line">  </div><div class="line">            //内存池的剩余空间分给合适的空闲链表  </div><div class="line">            if (bytes_left &gt; 0)  </div><div class="line">            &#123;  </div><div class="line">                obj * __VOLATILE * my_free_list = free_list + FREELIST_INDEX(bytes_left);  </div><div class="line">  </div><div class="line">                ((obj *)start_free) -&gt; free_list_link = *my_free_list;  </div><div class="line">                *my_free_list = (obj *)start_free;  </div><div class="line">            &#125;  </div><div class="line">            start_free = (char *)malloc(bytes_to_get);//配置heap空间，用来补充内存池  </div><div class="line">            if (0 == start_free)  </div><div class="line">            &#123;  </div><div class="line">                int i;  </div><div class="line">                obj * __VOLATILE * my_free_list, *p;  </div><div class="line">  </div><div class="line">                //从空闲链表中找出一个比较大的空闲内存块还给内存池（之后会将这个大的空闲内存块切成多个小的空闲内存块再次加入到空闲链表）  </div><div class="line">                for (i = size; i &lt;= __MAX_BYTES; i += __ALIGN)  </div><div class="line">                &#123;  </div><div class="line">                    my_free_list = free_list + FREELIST_INDEX(i);  </div><div class="line">                    p = *my_free_list;  </div><div class="line">                    if (0 != p)  </div><div class="line">                    &#123;  </div><div class="line">                        *my_free_list = p -&gt; free_list_link;  </div><div class="line">                        start_free = (char *)p;  </div><div class="line">                        end_free = start_free + i;  </div><div class="line">                        return(chunk_alloc(size, nobjs));//递归调用自己，为了修正nobjs  </div><div class="line">                    &#125;  </div><div class="line">                &#125;  </div><div class="line">                end_free = 0;  </div><div class="line">                start_free = (char *)malloc_alloc::allocate(bytes_to_get);//如果连这个大的内存块都找不出来则调用第一级配置器  </div><div class="line">            &#125;  </div><div class="line">            //如果分配成功  </div><div class="line">            heap_size += bytes_to_get;//内存池大小增加  </div><div class="line">            end_free = start_free + bytes_to_get;//修改内存池可用空间的结束位置  </div><div class="line">            return(chunk_alloc(size, nobjs));//递归调用自己，为了修正nobjs  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h5 id="5-空间释放函数deallocate"><a href="#5-空间释放函数deallocate" class="headerlink" title="5. 空间释放函数deallocate"></a>5. 空间释放函数deallocate</h5><p>首先先要检查释放内存块的大小，如果大于128字节就调用第一级配置器，小于128字节则根据内存块的大小来判断回收后的空间会被插入到哪个空闲链表。<br>例如回收下面指定位置大小为16字节的内存块，首先内存块的大小判断回收后的内存块应该插入到第二个空闲链表，把该节点指向的下一个地址修改为原链表指向的地址（这里是NULL）,然后将原链表指向该节点。<br><img src="http://oytnj8g2y.bkt.clouddn.com/4.jfif" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//释放地址为p，释放大小为n  </div><div class="line">static void deallocate(void *p, size_t n)  </div><div class="line">&#123;  </div><div class="line">    obj *q = (obj *)p;  </div><div class="line">    obj * __VOLATILE * my_free_list;  </div><div class="line">  </div><div class="line">    if (n &gt; (size_t) __MAX_BYTES)//如果空间大于128字节，采用普通的方法析构  </div><div class="line">    &#123;  </div><div class="line">        malloc_alloc::deallocate(p, n);  </div><div class="line">        return;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    my_free_list = free_list + FREELIST_INDEX(n);//否则将空间回收到相应空闲链表（由释放块的大小决定）中  </div><div class="line">    q -&gt; free_list_link = *my_free_list;  </div><div class="line">    *my_free_list = q;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h4><ol>
<li>使用 allocate 请求size大小的内存空间, 如果需要请求的内存大小大于128bytes, 直接使用malloc.</li>
<li>如果需要的内存大小小于128bytes, allocate根据size找到最适合的空闲链表.<br>&nbsp;a. 如果链表不为空, 返回第一个内存块, 链表头改为第二个内存块。<br>&nbsp;b. 如果链表为空, 使用refill为该空闲链表填充新的空间。<br>&nbsp;&nbsp;x. 如果内存池中有大于一个内存块的空间, 分配尽可能多的内存块(但是最多20个), 将一个内存块返回, 其他的内存块添加到链表中。<br>&nbsp;&nbsp;y. 如果内存池只有一个内存块的空间, 直接返回给用户.<br>&nbsp;&nbsp;z. 如果内存池连一个内存块的空间都没有, 再次向操作系统请求分配内存.<br>&nbsp;&nbsp;&nbsp;I 系统内存足够，分配成功，再次进行b过程<br>&nbsp;&nbsp;&nbsp;II 分配失败, 循环各个空闲链表, 寻找空间<br>&nbsp;&nbsp;&nbsp;&nbsp;A. 找到空间, 再次进行过程b<br>&nbsp;&nbsp;&nbsp;&nbsp;B. 找不到空间, 抛出异常</li>
<li>用户调用deallocate释放内存空间, 如果要求释放的内存空间大于128bytes, 直接调用free。</li>
<li>否则按照其大小找到合适的空闲链表, 并将其插入。</li>
</ol>
<p>特点其实是这样的:</p>
<ol>
<li>刚开始初始化内存池的时候, 其实内存池中并没有内存, 同时所有的空闲链表都为空链表.</li>
<li>只有用户第一次向内存池请求内存时, 内存池会依次执行上述过程的 1-&gt;2-&gt;b-&gt;z来完成内存池以及链表的首次填充, 而此时, 其他未使用链表仍然是空的.<br><img src="http://oytnj8g2y.bkt.clouddn.com/10.png" alt=""><br><img src="http://oytnj8g2y.bkt.clouddn.com/11.png" alt=""><br><img src="http://oytnj8g2y.bkt.clouddn.com/12.png" alt=""></li>
</ol>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/03/16/计算机概念的英文表述/">
                计算机概念的英文表述
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-03-16</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h3 id="map-vs-set"><a href="#map-vs-set" class="headerlink" title="map vs set"></a>map vs set</h3><p>In C++ STL, a map sometimes is referred to as a dictionary, consists of key/value pairs. The key is used to order the sequence, and the value is somehow associated with that key. For example, a map might contain keys representing every unique word in a text and values representing the number of times that word appears in that text.<br>a set is simply an ascending container of unique elements.<br>STL’s map and set are implemented with RB-Tree.<br>Both set and map support bidirectional iterators.<br>While not officially part of the STL standard, hash_map and hash_set are commonly used to improve searching time. These containers store elements as a hash table, with each table entry (bucket) containing a bidirectional linked list of elements.<br>Additionally, python’s dict and set is implemented with hash table. This is different from C++.</p>
<h3 id="stack-vs-heap"><a href="#stack-vs-heap" class="headerlink" title="stack vs heap"></a>stack vs heap</h3><p>stack:</p>
<ol>
<li>abstract data type, concept, LIFO</li>
<li>call stack<br>heap:</li>
<li>data structure, commonly used to implement a priority queue. A Specialized tree-based data structure that satisfies heap property: if P is parent node of C, then the key of P is either greater than or equal to the key of C. And it is a complete binary tree.</li>
<li>free store, an area of memory used for dynamic memory allocation</li>
</ol>
<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>is compact, allow random access.</p>
<h3 id="linked-list"><a href="#linked-list" class="headerlink" title="linked list"></a>linked list</h3><p>elements can be inserted or removed without a lot of movement operations because the data items need not to be stored<br>continuously in memory.</p>
<h3 id="singly-linked-list"><a href="#singly-linked-list" class="headerlink" title="singly linked list"></a>singly linked list</h3><p>A singly linked list node have a data field, a next field.</p>
<h3 id="Doubly-linked-list"><a href="#Doubly-linked-list" class="headerlink" title="Doubly linked list"></a>Doubly linked list</h3><p>A doubly linked list node has a data field, a next field and a previous field.</p>
<h3 id="Circular-linked-list"><a href="#Circular-linked-list" class="headerlink" title="Circular linked list"></a>Circular linked list</h3><p>the next field of the last node points to the first node</p>
<h3 id="Multithreading’s-drawback"><a href="#Multithreading’s-drawback" class="headerlink" title="Multithreading’s drawback"></a>Multithreading’s drawback</h3><ol>
<li>Synchronization: deadlock, race over resource.</li>
<li>an illegal operation performed by a thread crashes the entire process.</li>
</ol>
<h3 id="Dining-philosophers-problem"><a href="#Dining-philosophers-problem" class="headerlink" title="Dining philosophers problem"></a>Dining philosophers problem</h3><p>is an example problem used in concurrent algorithm design to illustrate synchronization issues.<br>Fiving slient philosophers sit at a round table. Forks are placed between each pair of adjacent philosophers.<br>Each philosopher must alternately think and eat.<br>A philosopher can eat only when he have both left and ritht forks. No philosopher knows when others may want to eat or think.<br>The challenge is to avoid deadlock, a system state in which no progress is possible.<br>In this problem, the deadlock happens when each philosopher pick up the left fork, and is waiting for the right fork to be available. Then the philosophers will wait for each other to release a fork.<br>timing and retry. There may be a rule that the philosopher put down a fork after waiting 10 minutes for another fork and wait a 5 minutes before making a next attempt. This scheme eliminates the possibility of deadlock but still suffers from livelock when five philosophers pick up the left fork at the same time.</p>
<h5 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h5><ol>
<li>Resource hierarchy solution<br>Here, the resources (forks) will be numbered 1 through 5 and each unit of work (philosopher) will always pick up the lower-numbered fork first, and then the higher-numbered fork, from among the two forks they plan to use. The order in which each philosopher puts down the forks does not matter. In this case, if four of the five philosophers simultaneously pick up their lower-numbered fork, only the highest-numbered fork will remain on the table, so the fifth philosopher will not be able to pick up any fork. Moreover, only one philosopher will have access to that highest-numbered fork, so they will be able to eat using two forks.</li>
<li>Arbitrator solution<br>Another approach is to guarantee that a philosopher can only pick up both forks or none by introducing an arbitrator, e.g., a waiter. In order to pick up the forks, a philosopher must ask permission of the waiter. The waiter gives permission to only one philosopher at a time until the philosopher has picked up both of their forks. Putting down a fork is always allowed. The waiter can be implemented as a mutex. In addition to introducing a new central entity (the waiter), this approach can result in reduced parallelism: if a philosopher is eating and one of their neighbors is requesting the forks, all other philosophers must wait until this request has been fulfilled even if forks for them are still available.</li>
</ol>
<h3 id="priority-queue-vs-heap"><a href="#priority-queue-vs-heap" class="headerlink" title="priority queue vs heap"></a>priority queue vs heap</h3><p>A priority queue is an abstract data type where each element has a “priority” associated with it.<br>In priority queue, an element with high priority dequeue before the element with low priority.<br>While priority queue is often implemented with heap, they are conceptually different from heap.<br>A priority queue is abstract concept like “a map”, a map can be implemented with RB-Tree or hash table, a priority can be implemented with a heap or something else.</p>
<h3 id="heap-sort"><a href="#heap-sort" class="headerlink" title="heap sort"></a>heap sort</h3><p>is an improved selection sort: like that algorithm, it divides its input into a sorted region and an unsorted region. It iteratively shrinks the unsorted region by extracting the largest element and moving that into the sorted region.<br>Although somewhat slower than a well-implemented quick sort, it has the advantage of a more favourable worst-case O<br>(nlogn) runtime. And it is an inplace but not a stable algorithm.<br>steps:</p>
<ol>
<li>call heapify(), build a heap in O(n) operations. Floyd down to top siftdown.</li>
<li>swap the first element of the input vector with the final element. Now the final element is in its correct position. Decrease the considered range of the vector by one.</li>
<li>call siftdown() to restore the unsorted region into a heap.</li>
<li>Go to step 2, unless the considered range of the vector has only one element.</li>
</ol>
<h3 id="SQL-injection"><a href="#SQL-injection" class="headerlink" title="SQL injection"></a>SQL injection</h3><p>nefarious SQL statements are inserted into an entry field.<br>May dump the database contents to attackers.</p>
<ol>
<li>incorrectly filtered escape characters<br>This form of SQL injection occurs when user input is not filterd for escape characters and then is passed into an SQL statement.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&quot;select * from users where name = &apos;&quot; + username +&quot;&apos;;&quot;</div><div class="line">username = &apos; OR &apos;1&apos; = &apos;1</div></pre></td></tr></table></figure>
</li>
</ol>
<p>now attackers will get all data in users table.</p>
<ol>
<li>incorrect type handling<br>occurs when a user-supplied field is not strongly typed or is not checked for type constraints.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;select * from userinfo where id=&quot; + a_variable +&quot;;&quot;</div><div class="line">a_variable is intended to be a number </div><div class="line">but if it is a string such as &quot;1; drop table users&quot;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>solution:<br>escaping and type checking</p>
<h3 id="Cross-site-Scripting-XSS"><a href="#Cross-site-Scripting-XSS" class="headerlink" title="Cross-site Scripting (XSS)"></a>Cross-site Scripting (XSS)</h3><p>typically found in web applications<br>XSS enables attackers to inject client-side scripts into the web pages which are viewed by other users.<br>A XSS vulnerability may be used by attackers to bypass access controls such as the same-origin policy.<br>same-origin policy:<br>A web browser permits scripts contained in the first web page to access data in the second web page, only if both web pages have the same origin.<br>same-origin: same protocol, same host and same port.</p>
<h3 id="Singleton-pattern"><a href="#Singleton-pattern" class="headerlink" title="Singleton pattern"></a>Singleton pattern</h3><p>is a software design pattern that restricts the instantiation of a class to only one object.<br>It’s useful when exactly one object is needed to coordinate actions across the whole system.<br>How to implement a singleton class</p>
<ol>
<li>protected or private constructor</li>
<li>private static pointer to the only instance</li>
<li>public static member function that returns the pointer<br>A singleton implementation may use lazy initialization, where the instance is created when the static method is first invoked. If the static method might be called from multiple threads simultaneously, we should pay attention to race condition that could result in the creation of multiple instances of the class.<br>Solution:<br>lazy initialization + double check :check + acquire the mutex + check</li>
</ol>
<h3 id="stack-overflow"><a href="#stack-overflow" class="headerlink" title="stack overflow"></a>stack overflow</h3><p>the website? a question and answer website on the topic of programming.<br>occurs [əˈkɜ:(r)] when the call stack pointer exceeds the stack bound.<br><em>The call stack may consist of a limited amount of address space, often determined at the start of the program. The size depends on many factors including programming language, machine architecture, multithreading, and amount of available memory.</em><br>stack overflow typically results in program crash.</p>
<ol>
<li>Infinite / very deep recursion<br>a function calls itself so many times that the space needed to store the variables and information associated with each call is more than can fit on the stack.</li>
<li>very large stack variables<br>an attempt to allocate more memory than can fit on the stack.<br>For example, create local array varibles that are too large. For this reason, it is recommended that arrays larger than a few kilobytes should be allocated dynamically instead of as stack variables.</li>
</ol>
<h3 id="binary-tree"><a href="#binary-tree" class="headerlink" title="binary tree"></a>binary tree</h3><p>is tree data structure in which each node has at most two child nodes, which refered to as left child and right child.<br>A binary tree node typically has a data field, left field and right field.<br>tree: In graph theory, a tree is a connected acyclic[ˌeɪˈsaɪklɪk] graph.</p>
<h3 id="binary-sorted-tree-binary-search-tree"><a href="#binary-sorted-tree-binary-search-tree" class="headerlink" title="binary sorted tree/ binary search tree"></a>binary sorted tree/ binary search tree</h3><p>keeps their keys in sorted order, so that lookup and other operations can use the principle of binary search.<br>search/ insertion/ deletion logn<br>That’s much better than the linear time required to find items by key in an unsorted array, but slower than the corresponding operations on hash table.<br>BST satisfies the binary search property, which states that the key in each node must be greater than or equal to any keys stored in the left sub-tree, and less than or equal to any keys stored in the right sub-tree.<br>BST can be used to implement either dynamic set of items or look up table that allow finding items by key.</p>
<h3 id="Database-index"><a href="#Database-index" class="headerlink" title="Database index"></a>Database index</h3><p>is a data structure that improves the speed of data retrieval[rɪˈtri:vl]<br> operations at the cost of additional space and effort to maintain the structure.</p>
<p>indexes are used to quickly locate data without having to search every row in a database table. Indexes can be created using one or more columns.<br>An index is a copy of data from the selected columns and include a low-level disk block address or direct link to a complete row.<br>Tree Node key: index column value<br>Tree Node value: address or link</p>
<ul>
<li>Dense Index: pairs of key and pointer for every record in data file.</li>
<li>Spare Index: pairs of key and pointer for every block in data file.</li>
</ul>
<h3 id="memory-leak"><a href="#memory-leak" class="headerlink" title="memory leak"></a>memory leak</h3><p>memory which is no longer needed is not released.<br>In oop, a memory leak may happen when an object is stored in memory but can be accessed by running code.<br>Because memory leak can exhaust available system memory as application runs, memory leak is often a cause of or a contributing factor for software aging. </p>
<h5 id="solutions"><a href="#solutions" class="headerlink" title="solutions"></a>solutions</h5><ol>
<li>RAII resource acqusition is initialization<br>is an approch to this problem commonly taken in C++.<br>It associates scoped objects with required resources, and automatically release resources once the objects go out of scope. Unlike garbage collection, RAII has the advantage of knowing when objects exist and when they don’t.</li>
<li>reference counting, smart pointer<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/*C version */</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">void f(int n) &#123;</div><div class="line">    int* array = calloc(n, sizeof(int));</div><div class="line">    do_somework(array);</div><div class="line">    free(array);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/* C++ version */</div><div class="line">#include &lt;vector&gt;</div><div class="line">void f(int n) &#123;</div><div class="line">    std::vector&lt;int&gt; array(n);</div><div class="line">    do_somework(array);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The C++ version requires no explicit deallocation.<br>It will always occur automatically once the object goes out of scope, including if a exception is thrown.<br>RAII also works with open files, open windows, objects in a graphics drawing library, thread synchronization primitives, network connections and connections to database.</p>
<h3 id="multiple-inheritance"><a href="#multiple-inheritance" class="headerlink" title="multiple inheritance"></a>multiple inheritance</h3><p>is a feature of oop in which a class can inherit from more than one parent class.<br>It has been a sensitive issue for many years and it may result in “Diamond Problem”.</p>
<h3 id="pass-by-value"><a href="#pass-by-value" class="headerlink" title="pass-by-value"></a>pass-by-value</h3><p>means that the value of function parameter is copied into another location of you memory.<br>When accessing and modifying the variable within the function, only the copy is accessed and modified, the original is left untouched. In other word, the inner variable and the outer variable are not the same one.</p>
<h3 id="pass-by-reference"><a href="#pass-by-reference" class="headerlink" title="pass-by-reference"></a>pass-by-reference</h3><p>means that the address of the variable is passed into the function.<br>it can avoid unnecessary copy construction of object and improve the speed.</p>
<h3 id="overloading-vs-overriding"><a href="#overloading-vs-overriding" class="headerlink" title="overloading vs overriding"></a>overloading vs overriding</h3><p>overloading occurs when two or more functions in same scope have same name but different parameters list or constantness.<br>overriding occurs when a method in derived class and a method in base class have the same name and same parameters list. (different from re-definition)</p>
<h3 id="virtual-function"><a href="#virtual-function" class="headerlink" title="virtual function"></a>virtual function</h3><p>is an important part of runtime polymorphism. A vitual function gives a target function to be executed but the target function might not be known at compile time.<br>Class containing pure virtual functions is termed “abstract” and they cann’t be instantiated directly.<br>A pure virtual function is required to be implemented by a derived class if the derived class is not abstract.</p>
<h3 id="virtual-destructor"><a href="#virtual-destructor" class="headerlink" title="virtual destructor"></a>virtual destructor</h3><p>a class intended to be base class should declare a virtual destructor<br>why?<br>If an object of type Wolf is created but pointed to by an Animal pointer, and it is this Animal pointer type that is deleted, the destructor called may actually be the one defined for Animal and not the one for Wolf, unless the destructor is virtual. This is particularly the case with C++, where the behaviour is a common source of programming errors.</p>
<h3 id="virtual-inheritance"><a href="#virtual-inheritance" class="headerlink" title="virtual inheritance"></a>virtual inheritance</h3><p>is a C++ technique that ensures only one copy of base class’s member variables are inherited by grandchild derived class.<br>without virtual inheritance, if class A and class B both inherite from class X, class C inherites from A and B, then class C will contain two copies of X’s member variables: one via A and one via B.These will be accessible independently using scope resolution.</p>
<h3 id="smart-pointer"><a href="#smart-pointer" class="headerlink" title="smart pointer"></a>smart pointer</h3><p>prevent memory leak by making the memory deallocation automatic.<br>works with reference counting.<br>smart pointer is a container for raw pointer.<br>smart pointer in C++ is a class template that mimics raw pointer by operator overloading while providing memory management features.</p>
<p><hr><br>shared_ptr: when reference counting is down to zero, the object is destoryed.<br>unique_ptr: explicitly prevents copying of its contained raw pointer, but the std::move function can be used to transfer the ownership of the contained raw pointer to another unique_ptr. A unique_ptr can’t be copied because its copy constructor and copy assignment operator are explicitly deleted.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">std::unique_ptr&lt;int&gt; p1(new int(5));</div><div class="line">std::unique_ptr&lt;int&gt; p2 = p1; // compile error</div><div class="line">std::unique_ptr&lt;int&gt; p3 = std::move(p1);  // ok</div><div class="line">// transfer the ownership of the contained raw pointer</div><div class="line">p3.reset(); // delete the memory</div><div class="line">p1.reset(); // does nothing</div></pre></td></tr></table></figure></p>
<p><strong>std::auto_ptr is deprecated under C++ 11 and will be removed completely from C++ 17.</strong><br>weak_ptr is created as a copy of shared_ptr, it doesn’t increase the reference counting of the object controlled by shared_ptr.</p>
<h3 id="database-transaction"><a href="#database-transaction" class="headerlink" title="database transaction"></a>database transaction</h3><p>a bunch of SQL statements<br>a unit of work performed by database management system against database<br>a database transaction, by definition, must be atomic, consistent, isolated, durable, ACID.<br>transaction provides an “all-or-nothing” proposition, stating that each unit of work must either complete entirely or have no effect whatsoever.</p>
<h3 id="primary-key"><a href="#primary-key" class="headerlink" title="primary key"></a>primary key</h3><p>a column or a set of columns that uniquely identify a row in a table.</p>
<h3 id="foreign-key"><a href="#foreign-key" class="headerlink" title="foreign key"></a>foreign key</h3><p>a field or a collection of fields in one table that uniquely identify a row in another table.</p>
<h3 id="inter-process-communication"><a href="#inter-process-communication" class="headerlink" title="inter-process communication"></a>inter-process communication</h3><p>refers to system-provided mechanisms that allow processes to communicate with each other.<br>Typically, applications use IPC, categoried as client and server, where the client requests data and server responds to client requests.<br>Method:</p>
<ul>
<li>file</li>
<li>socket</li>
<li>message queue</li>
<li>pipe </li>
<li>shared memory</li>
<li>memory-mapped file</li>
<li>signal (asynchronous system trap): a system message sent from one process to another not usually used to transfer data, but to remotely command the partnered process.</li>
</ul>
<h3 id="UDP-vs-TCP"><a href="#UDP-vs-TCP" class="headerlink" title="UDP vs TCP"></a>UDP vs TCP</h3><p><strong>TCP</strong> (transmission control protocol) is <strong>connection-oriented</strong> protocol, which means that it requires handshaking to set up end-to-end connection. Once the connection is set up, user data may be sent bi-directionally over the connection.</p>
<ul>
<li>Reliable - Strictly only at transport layer, TCP manages message <strong>acknowledgement, retransmission, timeout</strong>. This reliability does not cover application layer, at which a separate acknowledgement flow control is still necessary.</li>
<li>ordered - if two messages are sent over a connection in sequence, the first message will reach the receiving application first. When data segments arrive in wrong order, TCP buffers delay the out-of-order segments utill all data segments can be properly re-ordered and delivered to application.</li>
<li>heavyweight - TCP requires handshaking (3 packets) to set up connection, before data be sent. TCP handles reliability and <strong>congestion control</strong>.</li>
<li>streaming - data is read as a byte stream, no distinguishing indications are transmitted to signal message boundaries.</li>
</ul>
<p><strong>UDP</strong> (user datagram protocol) is a simpler message-based connectionless protocol. Communication is achieved by transmitting information in one direction from source to destination without verifying the readiness or the state of receiver.</p>
<ul>
<li>Unreliable - When a UDP message is sent, it can be not known if it will reach its destination; it could be lost along the way. there is no concept of acknowledgement, retransmission, timeout.</li>
<li>not ordered - if two messages are sent to same recipient, the order in which they arrive can’t be predicted.</li>
<li>ligthweight - it’s a small transport layer designed on top of IP.</li>
<li>datagrams - packets have definite boundaries, which means that a read recipient at the receiver socket will yield an entire message as it was sent originally.</li>
<li>no congestion control</li>
<li>broadcast - being connectionless, UDP can broadcast. Sent packets are accessible by all devices on the subnet.</li>
</ul>
<h3 id="Connection-establishment-of-TCP"><a href="#Connection-establishment-of-TCP" class="headerlink" title="Connection establishment of TCP"></a>Connection establishment of TCP</h3><p>three-way handshake<br>Before a client attempts to connect with a server, the server must first bind to and listen to a port to open it up for connections: this is called ‘passive open’. Once the passive open is established, a client may initiate an ‘active open’.<br>To establish a connection, the three-way shake occurs:</p>
<ol>
<li>SYN: The client sends a SYN to server. The sequence number is set to a random value A;</li>
<li>SYN-ACK: In response, the server replies with a SYN-ACK. The acknowledgement number is set to A+1; The sequence number is set to another random value B.</li>
<li>ACK: Finally, the client sends a ACK to server. The acknowledgement number is set to B+1; the sequence number is set to A+1.</li>
</ol>
<h4 id="Connection-termination-of-TCP"><a href="#Connection-termination-of-TCP" class="headerlink" title="Connection termination of TCP"></a>Connection termination of TCP</h4><p>four-way handshake<br>when an end-point wishes to stop its half of the connection, it transmits a FIN packet, which the other will acknowledge with an ACK.</p>
<h3 id="thread-vs-process"><a href="#thread-vs-process" class="headerlink" title="thread vs process"></a>thread vs process</h3><ul>
<li>processes have independent/separate address space, while threads in a process share their address space.</li>
<li>context switching between threads is much faster than context switching between processes.</li>
<li>processes interact only throuth system-provided inter-process communication mechanisms.</li>
<li>multiple threads within a process share process state as well as memory and other resources</li>
</ul>
<h3 id="stack-vs-heap-1"><a href="#stack-vs-heap-1" class="headerlink" title="stack vs heap"></a>stack vs heap</h3><ul>
<li>the stack is memory set aside as scratch space for a thread execution.</li>
<li>the heap is memory set aside for dynamic allocation.</li>
<li>variables created on stack will be deallocated automatically when they go out of scope </li>
<li>variables created on heap must be destroyed manually.</li>
<li>allocation on stack is faster than heap</li>
<li>stack stores local variables, return addresses, and is used for parameters passing.</li>
<li>heap can have fragmentations when there are a lot of allocations and deallocations.</li>
</ul>
<h3 id="polymorphism"><a href="#polymorphism" class="headerlink" title="polymorphism"></a>polymorphism</h3><p>a single interface to different entities.</p>
<ul>
<li>function overloading, compile polymorphism</li>
<li>template, generic programming</li>
<li>virtual function, runtime polymorphism, call a method by a base class pointer, the actual method been called depends on the pointer’s dynamic type instead of static type.</li>
</ul>
<h3 id="recursion"><a href="#recursion" class="headerlink" title="recursion"></a>recursion</h3><p>the solution to a problem depends on solutions to smaller instances of the same problem.<br>programming languages support recursion by allowing a function to call itself.</p>
<h3 id="quick-sort"><a href="#quick-sort" class="headerlink" title="quick sort"></a>quick sort</h3><ol>
<li>pick an element as pivot from the array</li>
<li>partitioning: reorder the array so that all elements smaller than the pivot come before the pivot, while all elements bigger than the pivot come after the pivot. After the partitioning, the pivot is in its final position.</li>
<li>recursively apply the above steps to the sub-arrays.</li>
</ol>
<h3 id="public-private-protected"><a href="#public-private-protected" class="headerlink" title="public, private, protected"></a>public, private, protected</h3><ol>
<li>public: members are accessible outside the class</li>
<li>protected: members are only available to derived class</li>
<li>private: members are only accessible inside the class</li>
</ol>
<h3 id="copy-constructor"><a href="#copy-constructor" class="headerlink" title="copy constructor"></a>copy constructor</h3><p>initialize its object member variables with another object of the same class</p>
<h3 id="inline-function"><a href="#inline-function" class="headerlink" title="inline function"></a>inline function</h3><p>should be put into header file, and the header file is included as required.</p>
<h3 id="default-constructor"><a href="#default-constructor" class="headerlink" title="default constructor"></a>default constructor</h3><p>is declared by compiler.<br>it is an inline public member function, have no constructor initializer and have a null body.</p>
<h3 id="default"><a href="#default" class="headerlink" title="default"></a>default</h3><p>the members of class are private by default</p>
<h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>used to group entities like class, objects, functions under a name.</p>
<h3 id="late-binding-vs-early-binding"><a href="#late-binding-vs-early-binding" class="headerlink" title="late binding vs early binding"></a>late binding vs early binding</h3><p><strong>late binding</strong> refers to function calls that are resolved at runtime (occurs through virtual function)<br><strong>early binding</strong> refers to function calls that are resolved at compile time. (increase efficiency)</p>
<h3 id="hash-collision"><a href="#hash-collision" class="headerlink" title="hash collision"></a>hash collision</h3><ul>
<li>linear probing</li>
<li>quadratic probing</li>
<li>separate chaining<hr></li>
<li>lazy deletion</li>
<li>rehashing</li>
</ul>
<h3 id="inline-vs-macro"><a href="#inline-vs-macro" class="headerlink" title="inline vs macro"></a>inline vs macro</h3><ul>
<li>type check</li>
<li>debug </li>
<li>a function vs just text </li>
</ul>
<p>the code is inserted into the position where the function is called.</p>
<p>speed up execution vs code bloat</p>
<h3 id="when-a-smart-pointer-1"><a href="#when-a-smart-pointer-1" class="headerlink" title="when a smart pointer + 1"></a>when a smart pointer + 1</h3><ol>
<li>use the shared_ptr to initialize another shared_ptr</li>
<li>as parameter been passed into a funciton</li>
<li>returned by a function</li>
</ol>
<h3 id="when-a-smart-pointer-1-1"><a href="#when-a-smart-pointer-1-1" class="headerlink" title="when a smart pointer - 1"></a>when a smart pointer - 1</h3><ol>
<li>shared_ptr been assigned a new value</li>
<li>shared_ptr been destroyed</li>
</ol>
<h3 id="why-MS"><a href="#why-MS" class="headerlink" title="why MS?"></a>why MS?</h3><p>when answering the question of what motivated you to join morgan stanley, Bjarne Stroustrup said “I find myself motivated by the technical challenges and by working with a technical community that is among the best skilled in the world.” That’s also my motivation.</p>
<h3 id="have-you-ever-seen-the-designer-of-C"><a href="#have-you-ever-seen-the-designer-of-C" class="headerlink" title="have you ever seen the designer of C++?"></a>have you ever seen the designer of C++?</h3><p>Do I have a chance to listen to his lecture in the future?</p>

        </div>
    

</div>
            
                
<div class="post">

    <div class="post-header index">
        <h1 class="title">
            <a href="/2018/03/15/MySQL-Crash-Course-读书笔记/">
                MySQL Crash Course 读书笔记
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-03-15</span>
            
            
            
        </div>
    </div>

    
        <div class="content">
            <h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><p>数据库就是数据库管理系统创建和操纵的容器。<br>模式(schema) 可以用来描述数据库中特定的表以及整个数据库（和其中表的关系），即关于数据库和表的布局及特性信息。</p>
<p>数据类型限制可存储在列中的数据类型，帮助正确的排序数据，并在优化磁盘使用方面起重要的作用。<br>主键：一列或者一组列，其值可以唯一区分表中的每行。没有主键，更新后者删除表中特定行是困难的，因为没有安全的方式保证只涉及相关的行。虽然并不总是需要主键，但是大多数数据库设计人员应该保证他们创建额每个表具有一个主键，以便于以后的数据操纵和管理。<br>表中的任何列都可以作为主键，只要满足两个条件：</p>
<ol>
<li>任意两行不具有相同的主键</li>
<li>每个行都必须具有一个主键值，主键列不允许NULL值。<br>主键的最佳实践：</li>
<li>不更新主键列的值</li>
<li>不重用主键列的值</li>
<li>不在主键列中使用可能会更改的值。</li>
</ol>
<h2 id="Chapter-2"><a href="#Chapter-2" class="headerlink" title="Chapter 2"></a>Chapter 2</h2><p>DBMS 可以分为两类</p>
<ol>
<li>基于共享文件系统， Microsoft Access， FileMaker，桌面用途。</li>
<li>基于客户机-服务器， MySQL， Oracle，Microsoft SQL Server。<br>注意：</li>
<li>命令用;或者\g结束，换句话说，仅按Enter不执行命令。</li>
<li>help or \h</li>
<li>quit or exit</li>
</ol>
<h2 id="Chapter-3-使用-MySQL"><a href="#Chapter-3-使用-MySQL" class="headerlink" title="Chapter 3 使用 MySQL"></a>Chapter 3 使用 MySQL</h2><p>默认端口 3306<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use crashcourse;</div><div class="line">Database changed</div></pre></td></tr></table></figure></p>
<p>数据库、表、列、用户、权限等的信息被存储在数据库和表中，MySQL 使用 MySQL 来存储这些信息。不过，内部的表一般不直接访问，可使用 MySQL 的 show 命令来显示这些信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show databases;</div></pre></td></tr></table></figure></p>
<p>包含在结果列表中的可能是 MySQL 内部使用的数据库，如 mysql， information_schema。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show tables;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">show columns from customers;</div></pre></td></tr></table></figure>
<p>什么是自动增量？<br>某些表列需要唯一值，例如订单编号，在每个行添加至表中时，MySQL 可以自动地为每个行分配下一个可用编号，不用在添加一行时手动分配唯一值（这样必须记住最后一次使用的值）。<br>describe 语句， MySQL 支持用 describe 作为 show columns from 的一种快捷方式。<br>所支持的其他show语句还有：</p>
<ul>
<li>show status, 用于显示广泛的服务器状态信息</li>
<li>show create database, show create table，用来显示创建特定数据库或表的MySQL语句。</li>
<li>show grants, 用来显示授予用户（所有用户或特定用户）的安全权限。</li>
<li>show errors, show warnings 用来显示服务器错误或者警告信息。</li>
</ul>
<h3 id="Chapter-4-检索数据"><a href="#Chapter-4-检索数据" class="headerlink" title="Chapter 4 检索数据"></a>Chapter 4 检索数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select prod_name from products;</div><div class="line">``` </div><div class="line">如果没有明确排序查询结果，则返回的数据的顺序并没有特殊意义，返回数据的顺序可能是数据被添加到表中的顺序，也可能不是。</div><div class="line">多条 SQL 语句必须以分号分隔，MySQL 如同多数DBMS一样，不需要在单条SQL语句后加分号，但是在mysql 命令行，必须加上分号来结束SQL语句。</div></pre></td></tr></table></figure>
<p>select * from products;<br>select distinct vend_id from products;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">不能部分使用distinct, distinct 关键字应用于所有列而不仅仅是前置它的列。</div></pre></td></tr></table></figure></p>
<p>select prod_name from products limit 5;<br>select prod_name from products limit 6, 5;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">limit 6, 5 返回从行6开始的5行。包前。</div><div class="line">如果没有足够的行，只返回它能返回的行数。</div><div class="line">由于这两位数字的混淆，MySQL 5 支持limit 的另一种替代语法，`limit 4 offset 3`。</div><div class="line">表名和列名可以是完全限定的，`select products.prod_name from crashcourse.products`，在一些情形下是需要完全限定名的。</div><div class="line"></div><div class="line">### Chapter 5 排序检索数据</div><div class="line">select 语句的 order by 子句。</div><div class="line">子句 clause，SQL 语句由子句构成，有些子句是必须的，有些子句是可选的。</div></pre></td></tr></table></figure></p>
<p>select prod_name from products order by prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">用非检索的列排序数据是完全合法的。</div></pre></td></tr></table></figure></p>
<p>select prod_id, prod_price, prod_name from products order by prod_price, prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">指定排序方向</div></pre></td></tr></table></figure></p>
<p>select prod_id, prod_price, prod_name from products order by prod_price desc, prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">desc 关键字只应用于直接位于其前面的列名。</div><div class="line">在给出 order by 子句时，应该保证它位于from子句之后，如果使用limit子句，它必须位于order by子句之后，使用的子句顺序不对将产生错误信息。</div><div class="line"></div><div class="line">### Chapter 6 过滤数据</div></pre></td></tr></table></figure></p>
<p>select prod_name, prod_price from products where prod_price = 2.50;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">SQL 过滤与应用过滤：SQL 过滤快速且节省带宽。</div><div class="line">在同时使用 order by 和 where时，应该让 order by 位于where之后。</div><div class="line">where 子句操作符：</div><div class="line"></div><div class="line">+ = 等于</div><div class="line">+ &lt;&gt; 不等于</div><div class="line">+ != 不等于</div><div class="line">+ &lt;, &lt;=, &gt;, &gt;=</div><div class="line">+ between</div></pre></td></tr></table></figure></p>
<p>select prod_name, prod_price from products where prod_name = ‘fuses’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">何时使用括号？</div><div class="line">单引号用来限定字符串，如果将值与串类型的列进行比较，则需要引号。</div></pre></td></tr></table></figure></p>
<p>select prod_name, prod_price from products where prod_price between 5 and 10;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">包前包后。</div><div class="line">NULL 与0，空字符串或者仅仅包含空格不同。</div></pre></td></tr></table></figure></p>
<p>select prod_name from products where prod_name is null;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### Chapter 7 数据过滤</div><div class="line">MySQL 允许给出多个where子句，并用and或者or进行连接。</div><div class="line">计算次序</div></pre></td></tr></table></figure></p>
<p>select prod_name, prod_price from products where vend_id = 1002 or vend_id = 1003 and prod_price &gt;= 10;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SQL 在处理or操作符之前，优先处理and操作符，当MySQL 看到上面的句子时，它理解为由供应商1003制造的价格10美元（含）以上的产品，或者由供应商1002 制造的任何产品，而不管其价格如何。</div><div class="line">换句话说，and 在计算次序中优先级更高。</div></pre></td></tr></table></figure></p>
<p>select prod_name, prod_price from products where (vend_id = 1003 or vend_id = 1002) and prod_price &gt;= 10;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">圆括号在where子句中除了用于明确计算顺序，还能用来指定 in 操作符的范围，合法值由逗号分隔，全部都在圆括号中。</div></pre></td></tr></table></figure></p>
<p>select prod_name, prod_price from products where vend_id in (1002, 1003, 1004) order by prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">in 操作符与 or 操作符完成相同的功能，那为什么使用 in 操作符呢？</div><div class="line">1. 直观</div><div class="line">2. 计算次序更加容易管理</div><div class="line">3. 比 or 更快</div><div class="line">4. in 的最大优点是可以包含其他的select 语句，使得能够动态地建立where子句。</div></pre></td></tr></table></figure></p>
<p>select prod_name, prod_price from products where vend_id not in (1002, 1003, 1004) order by prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">MySQL 支持使用 not 对 in，between，exists 子句取反。</div><div class="line"></div><div class="line">### Chapter 8 用通配符进行过滤</div><div class="line">like 操作符</div><div class="line">为在搜索子句中使用通配符，必须使用like操作符，like 指示 MySQL 后跟的搜索模式利用通配符匹配而不是直接相等比较。</div><div class="line">%表示任意字符出现任意次数。</div></pre></td></tr></table></figure></p>
<p>select prod_id, prod_name from products where prod_name like ‘jet%’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">**根据MySQL的配置方式，搜索可以是区分大小写的，如果区分大小写，&apos;jet%&apos;与JetPack 1000将不匹配。**</div><div class="line">注意尾空格，例如，在保存词anvil时，如果它后面有一个或者多个空格，则子句where prod_name like &apos;%anvil&apos;将不会匹配它们，解决这个问题的一个简单办法是在搜索模式（search pattern）的最后附加一个%，一个更好的方式是使用函数去掉尾空格。</div><div class="line">**%似乎可以匹配任何东西，但是NULL除外。**</div><div class="line">\_通配符，只匹配单个字符。</div><div class="line">通配符的使用技巧：</div><div class="line">1. 不要过度使用通配符。</div><div class="line">2. 在确实需要使用通配符时，除非有必要，否则不要将通配符放在搜索模式的开始处，放在开始处搜索起来是最慢的。</div><div class="line"></div><div class="line">### Chapter 9 使用正则表达式</div><div class="line">MySQL 仅支持正则表达式的一个很小的子集。</div><div class="line">基本字符匹配</div></pre></td></tr></table></figure></p>
<p>select prod_name from products where prod_name regexp ‘1000’ order by prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">返回列 prod_name 包含&apos;1000&apos;的所有行。</div></pre></td></tr></table></figure></p>
<p>select prod_name from products where prod_name regexp ‘.000’ order by prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MySQL 的正则表达式匹配不区分大小写，为了区分大小写可以用 binary 关键字，如 where prod_name regexp binary &apos;JetPack .000&apos;</div><div class="line">进行or匹配</div></pre></td></tr></table></figure></p>
<p>select prod_name from products where prod_name regexp ‘1000|2000|3000’ order by prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">输出</div></pre></td></tr></table></figure></p>
<p>prod_name<br>JetPack 1000<br>JetPack 2000<br>JetPack 3000<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">匹配几个字符之一</div></pre></td></tr></table></figure></p>
<p>select prod_name from products where prod_name regexp ‘[123] Ton’ order by prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">输出</div></pre></td></tr></table></figure></p>
<p>prod_name<br>1 ton anvil<br>2 ton anvil<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">select prod_name from products where prod_name regexp &apos;[^123] Ton&apos; order by prod_name;</div></pre></td></tr></table></figure></p>
<p>匹配除这些字符外的任何东西。<br>匹配范围[1-9]，[a-z]。<br>匹配特殊字符，必须以<code>\\</code>为前导。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select prod_name from products where </div><div class="line">prod_name regexp &apos;\\([0-9] sticks?\\)&apos;</div><div class="line">order by prod_name;</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">prod_name</div><div class="line">TNT (1 stick)</div><div class="line">TNT (7, sticks)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">select prod_name from products where </div><div class="line">prod_name regexp &apos;[[:digit:]]&#123;4&#125;&apos; order by prod_name;</div></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">prod_name</div><div class="line">JetPack 1000</div><div class="line">JetPack 2000</div></pre></td></tr></table></figure></p>
<p>定位符 <code>^, $, [[:&lt;:]], [[:&gt;:]]</code>。</p>
<h3 id="Chapter-10-创建计算字段"><a href="#Chapter-10-创建计算字段" class="headerlink" title="Chapter 10 创建计算字段"></a>Chapter 10 创建计算字段</h3><p>计算字段，比如城市、州、邮编的拼接，单价乘以数量，根据表数据进行总数、平均数或者其他的计算。计算字段也是一个字段，但是它并不存在于实际的数据库表中，计算字段是在运行时在select 语句内创建出来的。</p>
<h4 id="拼接字段"><a href="#拼接字段" class="headerlink" title="拼接字段"></a>拼接字段</h4><p>concatenate 将值连起来一起构成单个值。<br>MySQL 的不同之处，多数DBMS 使用+或||实现拼接，而MySQL则使用Concat()函数来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select concat(vend_name, &apos; (&apos;, vend_county, &apos;)&apos;) from vendors order by vend_name;</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">concat(vend_name, &apos; (&apos;, vend_county, &apos;)&apos;)</div><div class="line">ACME (USA)</div><div class="line">Anvil R us (USA)</div></pre></td></tr></table></figure></p>
<p>通过使用rtrim()函数来删除数据右侧多余的空格整理数据。<br>ltrim，trim。<br>使用别名，上面的语句工作得很好，但是在select语句内创建出来的计算字段并没有名称，不能被后续使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select concat(rtrim(vend_name), &apos; (&apos;, rtrim(vend_county), &apos;)&apos;) as vend_title from vendors order by vend_name;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vend_title</div><div class="line">ACME (USA)</div><div class="line">Anvil R us (USA)</div></pre></td></tr></table></figure>
<p>如今就像一个实际的表列一样。<br>别名还有其他的用处，包括在实际的表列名包含不符合规定的字符（如空格）时重新命名它，在原来的名字含混或者容易误解时扩充它。</p>
<h4 id="执行算术运算"><a href="#执行算术运算" class="headerlink" title="执行算术运算"></a>执行算术运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">select prod_id, quantity, item_price from orderitems where order_num = 2005;</div></pre></td></tr></table></figure>
<p>检索出订单号为2005的订单包含的所有物品。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select prod_id, quantity, item_price, quantity * item_price as expanded_price </div><div class="line">from orderitems </div><div class="line">where order_num = 2005;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select 3*2; 6</div><div class="line">select trim(&apos; abc &apos;); abc</div><div class="line">select now(); 当前的日期与时间</div></pre></td></tr></table></figure>
<h3 id="Chapter-11-使用数据处理函数"><a href="#Chapter-11-使用数据处理函数" class="headerlink" title="Chapter 11 使用数据处理函数"></a>Chapter 11 使用数据处理函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">select vend_name, upper(vend_name) as vend_name_uppercase from vendors order by vend_name;</div><div class="line">``` </div><div class="line">#### 文本处理函数</div><div class="line">+ left</div><div class="line">+ right</div><div class="line">+ length</div><div class="line">+ locate</div><div class="line">+ lower</div><div class="line">+ upper</div><div class="line">+ ltrim</div><div class="line">+ rtrim</div><div class="line">+ trim</div><div class="line">+ substring</div><div class="line">+ soundex</div><div class="line"></div><div class="line">#### 日期和时间处理函数</div><div class="line">日期和时间采用相应的数据类型和特殊的格式存储，以便能够快速和有效地排序或过滤，并节省物理存储空间。</div><div class="line">一般地，应用程序并不直接处理、使用这样的格式，因此就需要日期和时间处理函数来读取、统计和处理这些值。由于这个原因，日期和时间处理函数在MySQL中具有重要的作用。</div><div class="line">常用的函数：</div><div class="line"></div><div class="line">+ adddate</div><div class="line">+ addtime</div><div class="line">+ curdate</div><div class="line">+ curtime</div><div class="line">+ date 返回日期时间的日期部分</div><div class="line">+ datediff 计算两个日期之差</div><div class="line">+ date_add</div><div class="line">+ date_format 返回一个格式化的日期或者时间字符串</div><div class="line">+ day</div><div class="line">+ dayofweek</div><div class="line">+ hour</div><div class="line">+ minute</div><div class="line">+ month</div><div class="line">+ now</div><div class="line">+ second</div><div class="line">+ time</div><div class="line">+ year</div><div class="line"></div><div class="line">首先需要注意的是MySQL使用的日期格式，无论你什么时候指定一个日期，不管是插入或者更新表值还是使用where子句进行过滤，日期都必须为 yyyy-mm-dd。</div></pre></td></tr></table></figure>
<p>select cust_id, order_num from orders where order_date = ‘2015-09-01’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">order_date 的数据类型是 datetime，这种类型存储日期及时间，因此&apos;2015-09-01&apos;匹配的是&apos;2015-09-01 00:00:00&apos;。</div><div class="line">如果是要日期请使用date()函数。</div></pre></td></tr></table></figure></p>
<p>select cust_id, order_num from orders where date(order_date) = ‘2015-09-01’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">使用 date 是一个良好的习惯，即使你知道相应的列只包含日期也是如此，这样由于某种原因表中以后有日期和时间值，你的SQL代码也不用修改。</div></pre></td></tr></table></figure></p>
<p>select cust_id, order_num from orders where date(order_date) between ‘2015-09-01’ and ‘2005-09-30’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 数值处理函数</div><div class="line">+ abs </div><div class="line">+ cos</div><div class="line">+ exp</div><div class="line">+ mod</div><div class="line">+ pi</div><div class="line">+ rand</div><div class="line">+ sin </div><div class="line">+ sqrt</div><div class="line">+ tan</div><div class="line"></div><div class="line">### Chapter 12 汇总数据</div><div class="line">聚集函数</div><div class="line">我们经常需要汇总数据而不用把它们实际检索出来，当需要的是对表中数据汇总而不是实际数据本身时，返回实际数据是对处理时间和处理资源的一种浪费，更不用说带宽了。</div><div class="line">MySQL 给出了5个聚集函数（aggregate function），聚集函数是运行在行组上，计算和返回单个值的函数。</div><div class="line"></div><div class="line">+ avg 返回某列的平均值</div><div class="line">+ count 返回某列的行数</div><div class="line">+ max 返回某列的最大值</div><div class="line">+ min 返回某列的最小值</div><div class="line">+ sum 返回某列值之和</div></pre></td></tr></table></figure></p>
<p>select avg(prod_price) as avg_price from products where vend_id = 1003;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">输出：</div></pre></td></tr></table></figure></p>
<p>avg_price<br>16.133571<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">avg 只能用于单个列，为了获得多个列的平均值，必须使用多个avg函数，avg 函数会自动忽略null的行。</div><div class="line">count 函数有两种使用方式：</div><div class="line">1. 使用 count(\*) 对表中行的数目进行计数，不管表列中包含的是空值还是非空值。</div><div class="line">2. 使用 count(column) 对特定列中具有值的行进行计数，忽略null值。</div></pre></td></tr></table></figure></p>
<p>select count(*) as num_cust from customers;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sum 函数</div></pre></td></tr></table></figure></p>
<p>select sum(item_price*quantity) as total_price from orderitems where order_num = 2005;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">聚集不同值</div></pre></td></tr></table></figure></p>
<p>select avg(distinct prod_price) as avg_price from products where vend_id = 1003;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">all 为默认值。</div><div class="line">聚集函数组合</div></pre></td></tr></table></figure></p>
<p>select count(*) as num_items,<br>    min(prod_price) as price_min,<br>    max(prod_price) as price_max,<br>    avg(prod_price) as price_avg<br>from products;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### Chapter 13 分组数据</div><div class="line">这涉及到两个 select 语句子句，分别是 group by 和 having。</div><div class="line">在上一章汇总数据时，是在表的所有数据或匹配特定的where子句的数据上进行的。</div></pre></td></tr></table></figure></p>
<p>select vend_id, count(*) as num_prods from products group by vend_id;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">输出</div></pre></td></tr></table></figure></p>
<p>vend_id num_prods<br>1001 3<br>1002 2<br>1003 7<br>1005 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">group by 的注意：</div><div class="line">1. 可以嵌套</div><div class="line">2. **除了聚集计算语句外，select语句中的每个列都必须在 group by 子句中给出**</div><div class="line">3. 如果分组列中有null值，则null将作为一个分组返回。</div><div class="line">4. group by 子句必须出现在where 子句之后，order by 子句之前。</div><div class="line"></div><div class="line">#### 过滤分组</div><div class="line">MySQL 允许过滤分组，规定包括哪些分组，排除哪些分组，例如，可能想要列出至少有两个订单的所有顾客，为了得到这个结果，必须基于用户分组进行计数并过滤而不是个别的行进行过滤。</div><div class="line">where 可以基于行而不是分组进行过滤，事实上，where 没有分组的概念。</div><div class="line">使用 having， having 非常类似where，事实上，目前为止所学的所有类型的where子句都用在having中来，唯一的差别是having 是过滤分组。</div><div class="line">having 支持所有where 操作符。</div></pre></td></tr></table></figure></p>
<p>select cust_id, count(<em>) as orders from orders group by cust_id having count(</em>) &gt;= 2;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">select vend_id, count(*) as num_prods from products where prod_price &gt;= 10</div><div class="line">group by vend_id having count(*) &gt;= 2;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">select order_num, sum(quantity*item_price) as ordertotal </div><div class="line">from orderitems</div><div class="line">group by order_num </div><div class="line">having sum(quantity*item_price) &gt;= 50</div><div class="line">order by ordertotal;</div></pre></td></tr></table></figure>
<p>having 子句中使用 <code>sum(quantity*item_price)</code>，而order by 子句中使用 ordertotal ，这是因为这两个子句分别运行于 as 子句之前和之后。</p>
<h3 id="Chapter-14-使用子查询"><a href="#Chapter-14-使用子查询" class="headerlink" title="Chapter 14 使用子查询"></a>Chapter 14 使用子查询</h3><p>子查询嵌套在其他查询中的查询。<br>orderitems&lt;-orders-&gt;customers<br>要求列出订购物品TNT2的所有客户：<br>需要三条查询语句</p>
<ol>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select order_num from orderitems where prod_id = &apos;TNT2&apos;;</div><div class="line">order_num</div><div class="line">20005</div><div class="line">20007</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">select cust_id from orders where order_num in (20005, 20007);</div><div class="line">cust_id</div><div class="line">10001</div><div class="line">10004</div></pre></td></tr></table></figure>
</li>
</ol>
<p>3.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">select cust_name, cust_contact from customers where cust_id in (10001, 10004);</div><div class="line">``` </div><div class="line">也可以使用一条语句</div></pre></td></tr></table></figure></p>
<p>select cust_name, cust_contact from customers where cust_id in (<br>    select cust_id from orders where order_num in (<br>        select order_num from orderitems where prod_id = ‘TNT2’<br>    )<br>);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">**列必须匹配： 在where子句中使用子查询， 应该保证select语句具有与where子句中相同数目的列，通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列。**</div><div class="line">子查询及其性能，这里给出的代码有效并获得了所需的结果，但是，使用子查询并不总是执行这种类型的数据检索的最有效的方法。</div><div class="line">#### 子查询结果作为计算字段使用</div></pre></td></tr></table></figure></p>
<p>select cust_name, cust_state,<br>    (select count(*) from orders where orders.cust_id = customers.cust_id) as orders<br>from customers order by cust_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">子查询及其性能，这里给出的代码有效并获得了所需的结果，但是，使用子查询并不总是执行这种类型的数据检索的最有效的方法。</div><div class="line">逐渐增加子查询来建立查询，首先，建立和测试最内层的查询，然后，用硬编码数据建立和测试外层查询，并且仅在确认它正常后才嵌入子查询，这时再次测试它。</div><div class="line"></div><div class="line">### Chapter 15 联结表</div><div class="line">SQL 最强大的功能之一就是能在数据检索查询的执行中联结 (join) 表。</div><div class="line">外键 (foreign key)，外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系：</div><div class="line">这样做的好处是：</div><div class="line">1. 数据不重复，节省空间。</div><div class="line">2. 信息变动时，可以只更新一个表中的单个记录，相关表中的数据不用改动。</div><div class="line">3. 数据的一致性好。</div></pre></td></tr></table></figure></p>
<p>select vend_name, prod_name, prod_price<br>from vendors, products<br>where vendors.vend_id = products.vend_id<br>order by vend_name, prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">笛卡儿积 由没有联结条件的表关系返回的结果为笛卡儿积，检索出的行的数目为第一个表中的行数乘以第二个表中的行数。</div></pre></td></tr></table></figure></p>
<p>select vend_name, prod_name, prod_price<br>from vendors, products<br>order by vend_name, prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">因此应该确保所有的联结都有where子句。</div><div class="line"></div><div class="line">#### 内部联结</div><div class="line">目前为止所用的联结称为等值联结，它基于两个表之间的相等测试，这种联结也成为内部联结，其实这种联结可以使用稍微不同的语法来明确指定联结的类型，下面的语句与前面的例子返回完全相同的数据</div></pre></td></tr></table></figure></p>
<p>select vend_name, prod_name, prod_price<br>from vendors inner join products<br>on vendors.vend_id = products.vend_id<br>order by vend_name, prod_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 联结多个表</div></pre></td></tr></table></figure></p>
<p>select prod_name, vend_name, prod_price, quantity<br>from orderitems, products, vendors<br>where products.vend_id = vendors.vend_id<br>and orderitems.prod_id = products.prod_id<br>and order_num = 2005;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">正如第14章所述，子查询并不总是执行复杂select操作的最有效的方法，下面是使用联结的相同查询：</div></pre></td></tr></table></figure></p>
<p>select cust_name, cust_contact<br>from customers, orders, orderitems<br>where customers.cust_id = order.cust_id<br>and order.order_num = orderitems.order_num<br>and prod_id = ‘TNT2’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### Chapter 16 创建高级联结</div><div class="line">#### 使用表别名</div><div class="line">SQL 的别名除了用于列名和计算字段外，SQL还允许给表名起别名，这样做主要有两个主要理由：</div><div class="line">1. 缩短SQL语句</div><div class="line">2. 允许在单条select语句中多次使用相同的表</div></pre></td></tr></table></figure></p>
<p>select cust_name, cust_contact<br>from customers as c, orders as o, orderitems as oi<br>where c.cust_id = o.cust_id<br>and o.order_num = oi.order_num<br>and prod_id = ‘TNT2’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 使用不同类型的联结</div><div class="line">迄今为止，使用的仅是称为内部联结或等值联结的简单联结。</div><div class="line">现在看其他三种联结，分别为自联结，自然联结，外部联结。</div><div class="line">自联结，如前所述，使用表别名的主要原因是能在单条select语句中不止一次引用相同的表。</div><div class="line">假设发现某物品id为DTNTR存在问题，想知道生产该物品的供应商的其他物品是否也存在这些问题。即在同一个表中。</div><div class="line">一种解决方式是使用子查询：</div></pre></td></tr></table></figure></p>
<p>select prod_id, prod_name<br>from products<br>where vend_id = (select vend_id from products where prod_id = ‘DTNTR’);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">现在看使用联结的相同查询：</div></pre></td></tr></table></figure></p>
<p>select p1.prod_id, p1.prod_name<br>from products as p1, products as p2<br>where p1.vend_id = p2.vend_id<br>and p2.prod_id = ‘DTNTR’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">p1.prod_id, p1.prod_name，如果不这样，MySQL将返回错误信息，因为分别存在两个名为 prod_id, prod_name 的列，MySQL 不知道想要的是哪一列，即使事实上它们是同一列。</div><div class="line">自联结通常用于替代在相同表中检索数据的子查询语句，虽然最终的结果是相同的，但有时候处理联结远比处理子查询要快得多。</div><div class="line">##### 自然联结</div><div class="line">无论何时对表进行联结，至少应该有一个列出现在不止一个表中，被联结的列，标准的联结，前一章中的内部联结，返回所有数据，甚至相同的列多次出现，自然联结则排除多次出现，使每个列只返回一次。</div></pre></td></tr></table></figure></p>
<p>select c.*, o.order_num, o.order_date, oi.prod_id, oi.quantity, oi.item_price<br>from customers as c, orders as o, orderitems as oi<br>where c.cust_id = o.cust_id<br>and o.order_num = oi.order_num<br>and prod_id = ‘FB’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">在这个例子中，通配符只对第一个表使用，所有其他列明确列出，所以没有重复的列被检索出来。</div><div class="line">事实上，迄今为止，我们建立的每个内部联结都是自然联结，很有可能我们永远都不会用到不是自然联结的内部联结。</div><div class="line">##### 外部联结</div><div class="line">检索所有客户及其订单：</div></pre></td></tr></table></figure></p>
<p>select customers.cust_name, orders.order_num<br>from customers inner join orders<br>on customers.cust_id = orders.cust_id;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">外部联结语法类似，检索所有的用户，包括那些没有订单的用户：</div></pre></td></tr></table></figure></p>
<p>select customers.cust_name, orders.order_num<br>from customers left outer join orders<br>on customers.cust_id = orders.cust_id;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">在使用 outer join 时，必须使用right或者left指定包括其所有行的表。外部联结的类型，存在两种形式的外部联结，它们之间唯一的差别在于所关联的表的顺序不同，换句话说，左外部联结可以通过颠倒from 或者 where子句中的表的顺序转换为右外部联结。</div><div class="line"></div><div class="line">##### 使用带聚集函数的联结</div><div class="line">检索所有客户及其订单数：</div></pre></td></tr></table></figure></p>
<p>select customers.cust_name, customers.cust_id,<br>count(orders.order_num) as num_ord<br>from customers inner join orders<br>on customers.cust_id = orders.cust_id<br>group by customers.cust_id;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">输出：</div></pre></td></tr></table></figure></p>
<p>cust_name cust_id num_ord<br>….        ….    2<br>….        ….    1<br>….        ….    1<br>….        ….    1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>select customers.cust_name, customers.cust_id,<br>count(orders.order_num) as num_ord<br>from customers left outer join orders<br>on customers.cust_id = orders.cust_id<br>group by customers.cust_id;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">输出：</div></pre></td></tr></table></figure></p>
<p>cust_name cust_id num_ord<br>….        ….    2<br>….        ….    1<br>….        ….    0<br>….        ….    1<br>….        ….    1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### Chapter 17 组合查询 compound query</div><div class="line">利用 union 操作符将多条select语句组合成一个结果集。</div><div class="line">组合查询和多个where条件：</div><div class="line">多数情况下，组合相同表的两个查询与具有多个where条件子句的单条查询完成的工作是相同的。</div></pre></td></tr></table></figure></p>
<p>select vend_id, prod_id, prod_price<br>from products<br>where prod_price &lt;= 5<br>union<br>select vend_id, prod_id, prod_price<br>from products<br>where vend_id in (1001, 1002);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">等于</div></pre></td></tr></table></figure></p>
<p>select vend_id, prod_id, prod_price<br>from products<br>where prod_price &lt;= 5<br>or<br>vend_id in (1001, 1002);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">union 规则：</div><div class="line">1. union 中的每个查询必须包含相同的列，表达式或者聚集函数（不过各个列不需要以相同的次序列出）。</div><div class="line">2. 列数据类型必须兼容，类型不必完全相同，但必须是 DBMS可以隐含地转换类型。</div><div class="line"></div><div class="line">##### 对组合查询结果进行排序</div><div class="line">在 union 组合查询时，只能使用一条order by 子句，它必须出现在最后一条select语句之后。</div><div class="line"></div><div class="line">### Chapter 18 全文本搜索</div><div class="line">并非所有引擎都支持全文本搜索</div><div class="line">MySQL 支持几种基本的数据库引擎，两个最常使用的引擎为MyISAM 和 InnoDB，前者支持全文本搜索，而后者不支持，这就是为什么这本书创建的多数样例表使用 InnoDB，而一个样例表（productnotes表）却使用MyISAM的原因。</div><div class="line">like关键字和正则表达式这两个搜索机制非常有用，但是却存在几个重要的限制：</div><div class="line">1. 性能，这两个搜索极少使用表索引，因此，随着被搜索行数不断增加，这些搜索可能会非常耗时。</div><div class="line">2. 控制不明确</div><div class="line">2. 不够智能</div><div class="line">使用全文本搜索时，MySQL不要分别查看每个行，不需要分别分析处理每个词，MySQL创建指定列中各词的一个索引，搜索可以针对这些词进行，这样，MySQL可以快速有效地决定哪些词匹配（哪些行包含它们），哪些词不匹配，以及它们的匹配频率。</div><div class="line">为了进行全文本搜索，必须索引被搜索的列，而且要随着数据的改动不断地重新索引，在对表列进行适当设计后，MySQL会自动进行所有索引和重新索引。</div><div class="line">在索引之后，select 可与match 和 against 一起使用以实际执行搜索。</div><div class="line">一般在创建表时启用全文本搜索，create table 语句接受 fulltext子句，它给出一个被索引列的一个逗号分隔的列表。</div></pre></td></tr></table></figure></p>
<p>create table productnotes (<br>    note_id     int        not null auto_increment,<br>    prod_id     char(10)   not null,<br>    note_date   datetime   not null,<br>    node_text   text       null,<br>    primary key(note_id),<br>    fulltext(node_text)<br>) engine=myisam;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">进行全文本搜索</div></pre></td></tr></table></figure></p>
<p>select node_text from productnotes where<br>match(node_text) against(‘rabbit’);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">有两行包含词 rabbit，这两行被返回。</div><div class="line">上述的搜索可以简单的使用like子句完成</div></pre></td></tr></table></figure></p>
<p>select node_text from productnotes where node_text like ‘%rabbit%’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">两行都包含词 rabbit，但包含词 rabbit 作为第三个词的等级比作为第二十个词的等级高，全文搜索的一个重要特点就是具有较高等级的行优先返回。</div><div class="line">**....to do**</div><div class="line"></div><div class="line">### Chapter 19 插入数据</div><div class="line">毫无疑问，select 是最常用的SQL语句了，但是还有其他3个经常使用的SQL语句。</div><div class="line">insert 可以以几种方式使用：</div><div class="line"></div><div class="line">+ 插入完整的行</div><div class="line">+ 插入行的一部分</div><div class="line">+ 插入多行</div><div class="line">+ 插入某些查询结果</div><div class="line"></div><div class="line">**插入及系统安全：可针对每个表或每个用户，利用MySQL的安全机制禁止使用insert语句**</div></pre></td></tr></table></figure></p>
<p>insert into customers<br>values (<br>    null,<br>    ‘Pep E. LaPaw’,<br>    ‘100 Main Street’,<br>    ‘Los Angeles’,<br>    ‘CA’,<br>    ‘90046’,<br>    ‘USA’,<br>    NULL,<br>    NULL<br>);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">依序，第一列 cust_id 为 null，是因为这列是由MySQL自动增量的。</div><div class="line">这种语法很简单，但并不安全，高度依赖于表中列的定义次序，不能保证表结构变动后各个列保持完全相同的次序。更加安全也更加繁琐的方式是：</div></pre></td></tr></table></figure></p>
<p>insert into customers (<br>    cust_name,<br>    cust_address,<br>    cust_city,<br>    cust_state,<br>    cust_zip,<br>    cust_county,<br>    cust_contact,<br>    cust_email<br>    )<br>    values (<br>    ‘Pep E. LaPaw’,<br>    ‘100 Main Street’,<br>    ‘Los Angeles’,<br>    ‘CA’,<br>    ‘90046’,<br>    ‘USA’,<br>    NULL,<br>    NULL<br>);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">省略的列：</div><div class="line">1. NULL</div><div class="line">2. default value</div><div class="line">否则就会产生一条错误信息，并相应的行插入不成功。</div><div class="line">提高整体性能：</div><div class="line">insert 操作可能很耗时，特别是有很多索引需要更新时，而它可能降低等待处理的select语句的性能。</div><div class="line">如果数据检索是重要的，通常如此，则你需要通过在insert 和into 之间添加关键字low_priority，指示MySQL降低insert语句的优先级。这也适用于 update 和 delete语句。</div></pre></td></tr></table></figure></p>
<p>insert into customers (…)<br>values (…), (…);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">此技术可以提高数据库处理的性能，因为MySQL用单条insert语句处理多个插入比使用多条insert语句要快。</div><div class="line"></div><div class="line">#### 插入检索出的数据</div><div class="line">将一条select语句的结果插入表中，这就是所谓的insert select。</div></pre></td></tr></table></figure></p>
<p>insert into customers (…)<br>select … from custnew;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Insert select 列名不一定匹配，MySQL使用的是其位置。</div><div class="line"></div><div class="line">### Chapter 20 更新和删除数据</div><div class="line">update 有两种使用方式：</div><div class="line">1. 更新表中特定行</div><div class="line">2. 更新表中所有行</div><div class="line">**一定要用where子句**</div></pre></td></tr></table></figure></p>
<p>update customers<br>set cust_email = ‘elmer@fudd.com’, cust_name = ‘The Fudds’<br>where cust_id = 10005;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">在update中可以使用子查询，使得能用select语句检索出的数据更新数据。</div><div class="line">ignore 关键字，在使用 update 更新多行时，如果其中的一行或者多行出现一个错误，则整个update操作被取消，错误发生前更新的所有行将恢复到其原有的值，为了即使发生错误，也能继续进行更新，可用ignore关键字。</div><div class="line">update ignore customers...</div><div class="line">delete 有两种使用方式：</div><div class="line">1. 删除表中特定行</div><div class="line">2. 删除表中所有行</div><div class="line">**一定要用where子句**</div></pre></td></tr></table></figure></p>
<p>delete from customers where cust_id = 10006;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">删除的是内容而不是表，即便是删除了表中所有的行。</div><div class="line">更快的删除</div><div class="line">如果想从表中删除所有行，不要使用delete，可以使用truncate table，它完成相同的工作，但是速度更快，它实际上是删除了原来的表并重新创建了一个表，而不是逐行删除表中的数据。</div><div class="line">更新和删除的指导原则</div><div class="line">1. 在对update 或delete语句使用where子句前，首先使用select进行测试，保证其过滤的是正确的记录，以免编写的where子句不正确。</div><div class="line">2. 使用强制实施引用完整性的数据库，这样MySQL不允许删除与其他表相关联的数据行。</div><div class="line"></div><div class="line">### Chapter 21 创建和操纵表</div><div class="line">迄今为止，我们看到的都是以单个列作为主键，为创建由多个列组成的主键，应该以逗号分隔的列表给出各列名，如下所示：</div></pre></td></tr></table></figure></p>
<p>create table orderitems (<br>    order_num    int           not null,<br>    order_item   int           not null,<br>    prod_id      char(10)      not null,<br>    quantity     int           not null,<br>    item_price   decimal(8, 2) not null,<br>    primary key (order_num, order_item)<br>) engine=innodb;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">+ 主键唯一标识表中的一行</div><div class="line">+ 外键是表中的一列，唯一标识另外一个表中的一行。</div><div class="line"></div><div class="line">每个表只允许一个 auto_increment 列，而且它必须被索引（如，通过使它成为主键）。</div><div class="line">覆盖 auto_increment，如果一个列被指定为 auto_increment，你可以简单地在insert语句中指定一个值，只要它是唯一的(至今尚未使用过)即可，该值将被用来代替自动生成的值，后续的增量将开始使用该手工插入的值。</div><div class="line">`select last_insert_id()` 返回最后一个 auto_increment 值。</div><div class="line">指定默认值 `quantity int not null default 1`，与大多数DBMS不一样，MySQL不允许使用函数作为默认值，它只支持常量。</div><div class="line"></div><div class="line">#### 引擎类型</div><div class="line">具体管理和处理数据的内部引擎。</div><div class="line"></div><div class="line">+ InnoDB 是一个可靠的事务处理引擎，但它不支持全文本搜索。</div><div class="line">+ Memory 功能等同于 MyISAM，但是数据存储在内存，而不是磁盘中，速度很快，特别适合于临时表。</div><div class="line">+ MyISAM 是一个性能极高的引擎，不支持事务处理，但是支持全文本搜索。</div><div class="line"></div><div class="line">在同一个数据库中引擎可以混用，一个表用 MyISAM，另一个表用 InnoDB。</div><div class="line">外键不能跨引擎。</div><div class="line"></div><div class="line">#### alter 表</div><div class="line">alter table，但是理想状态下，当表中存储数据后，该表就不应该被alter，在表的设计过程中需要花费大量的时间来考虑，以便后期不对该表进行大的变动。</div></pre></td></tr></table></figure></p>
<p>alter table vendors<br>add vend_phone char(20);</p>
<p>alter table vendors<br>drop column vend_phone;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alter table 的一个常见用途是定义外键：</div></pre></td></tr></table></figure></p>
<p>alter table orderitems<br>add constraint fk_orderitems_orders<br>foreign key (order_num) references orders (order_num);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">小心使用alter table，数据表的更改不能撤销，如果增加了不需要的列，可能不能删除它们，类似地，如果删除了不应该删除的列，可能会丢失该列中的所有数据。</div><div class="line">删除表 `drop table customers2;`</div><div class="line">重命名表 `rename table customers2 to customers;`</div><div class="line"></div><div class="line">### Chapter 22 使用视图</div><div class="line">视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询。</div></pre></td></tr></table></figure></p>
<p>select cust_name, cust_contact<br>from customers, orders, orderitems<br>where customers.cust_id = order.cust_id<br>and order.order_num = orderitems.order_num<br>and prod_id = ‘TNT2’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">此查询用来检索订购了某个特定产品的客户，任何需要这个数据的人都必须理解相关表的结构，并知道如何创建查询和对表进行联结，为了检索其他的产品或者多个产品的相同数据，必须修改最后的where子句。</div><div class="line">现在，假如可以把整个查询包装成为一个 productcustomers 的虚拟表，则可以轻松地检索出相同的数据：</div></pre></td></tr></table></figure></p>
<p>select cust_name, cust_contact from<br>productcustomers<br>where prod_id = ‘TNT2’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">productcustomers 是一个视图，作为视图，它不包含表中应该有的任何列或者数据，它包含的是一个SQL 查询。</div><div class="line">#### 视图用处</div><div class="line">+ 重用 SQL 语句</div><div class="line">+ 简化复杂的 SQL 操作</div><div class="line">+ 使用表的组成部分而不是整个表</div><div class="line">+ 保护数据，可以给用户授予表的特定部分的访问权限而不是整个表的访问权限</div><div class="line">+ 更改数据格式和表示，视图可返回与底层表的数据格式和表示不同的数据</div><div class="line"></div><div class="line">在视图创建之后，可以用与表基本相同的方式利用它们，可以对视图执行select操作，过滤和排序数据，将视图联结到其他视图或者表，甚至能添加和更新数据（添加和更新数据存在某些限制），重要的是，在添加或者更改表中的数据时，视图将立即进行反映。</div><div class="line">视图的规则和限制：</div><div class="line">1. 视图可以嵌套</div><div class="line">2. order by 可以用在视图中，但如果从该视图检索数据的select 中也包含order by，那么该视图的order by 将被覆盖。</div><div class="line">3. 视图不能索引，也不能有关联的触发器或者默认值</div><div class="line">4. 为创建视图，必须有足够的访问权限，这些限制通常由数据库管理人员授予。</div><div class="line">5. 视图可以和表一起使用，例如编写一条联结表和视图的select语句。</div><div class="line"></div><div class="line">使用视图：</div><div class="line">1. 视图用 create view 语句来创建</div><div class="line">2. 使用 show create view viewname;来查看创建视图的语句。</div><div class="line">3. drop view viewname;</div><div class="line">4. 更新视图时，可以先用drop再用create，也可以直接用create or replace view。</div><div class="line"></div><div class="line">#### 利用视图简化复杂的联结</div><div class="line">视图的最常用的应用之一是隐藏复杂的SQL，这通常会涉及到联结。</div></pre></td></tr></table></figure></p>
<p>ceate view productcustomers as<br>select cust_name, cust_contact, prod_id<br>from customers, orders, orderitems<br>where customers.cust_id = orders.cust_id<br>and orders.order_num = orderitems.order_num;</p>
<p>select cust_name, cust_contact<br>from productcustomers<br>where prod_id = ‘TNT2’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 利用视图重新格式化检索出的数据</div></pre></td></tr></table></figure></p>
<p>select concat(rtrim(vend_name), ‘ (‘, rtrim(vend_county), ‘)’) as vend_title<br>from vendors<br>order by vend_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">现在假设经常需要这个格式的结果，创建视图，重用 SQL 语句。</div></pre></td></tr></table></figure></p>
<p>create view vendorlocations as<br>select concat(rtrim(vend_name), ‘ (‘, rtrim(vend_county), ‘)’) as vend_title<br>from vendors<br>order by vend_name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">这样就可以在应用中使用 `select * from vendorlocations;`进行数据检索了，重用了SQL语句，简化了应用中的SQL语句，并且没有造成数据的重复。</div><div class="line"></div><div class="line">#### 用视图过滤不想要的数据</div><div class="line">可以定义 customeremaillist 视图，它过滤了没有电子邮件地址的用户。</div></pre></td></tr></table></figure></p>
<p>create view customeremaillist as<br>select cust_id, cust_name, cust_email<br>from customers<br>where cust_email is not null;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">此时可以在应用中通过`select * from customeremaillist;`进行检索了。</div><div class="line"></div><div class="line">#### 使用视图与计算字段</div></pre></td></tr></table></figure></p>
<p>create view orderitemsexpanded as<br>select order_num, prod_id, quantity, item_price quantity*item_price as expanded_price<br>from orderitems;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 更新视图</div><div class="line">视图是可更新的，即可以对其使用insert，update，delete，更新一个视图将更新其基表，可以回忆一下，视图本身并没数据，如果对视图增加或者删除行，实际上是对其基表增加或者删除行。</div><div class="line">但是并非所有的视图都是可更新的，基本上说，如果MySQL不能正确地确定被更新的基数据，则不允许更新，这实际上是说，如果视图中定义有如下的操作，则不能进行视图的更新：</div><div class="line"></div><div class="line">1. 分组 （使用 group by 和 having）</div><div class="line">2. 联结</div><div class="line">3. 子查询</div><div class="line">4. 并</div><div class="line">5. 聚集函数（min，max， count， sum等）</div><div class="line">6. distinct</div><div class="line">7. 导出（计算）列</div><div class="line"></div><div class="line">### Chapter 23 使用存储过程</div><div class="line">迄今为止，使用的大多数SQL语句都是针对一个或者多个表的**单条语句**，但是并非所有的操作都这么简单，经常会有一个完整的操作需要多条语句才能完成。</div><div class="line">那么如何编写此代码？可以单独编写每条语句，并根据结果有条件地执行另外的语句。在每次需要这个处理时，重复一遍如此的操作即可。</div><div class="line">可以创建存储过程，存储过程简单来说，就为以后使用而保存地一条或者多条MySQL语句的集合，可将其视为批处理文件。</div><div class="line">#### 为什么要使用存储过程？</div><div class="line">1. 把处理封装在容易使用的单元中</div><div class="line">2. 不需要反复建立一系列处理步骤，让所有开发人员和应用程序都使用同一存储过程的相同代码，防止错误，鲁棒性。</div><div class="line">3. 简化对变动的管理，如果表名、列名或者业务逻辑有变动，只需要更改存储过程的代码，使用的它人员甚至对于变动都没有察觉，增加安全性。</div><div class="line">4. 提高性能，因为使用存储过程要比使用单独的SQL语句要快。</div><div class="line">简单来说就是三点，简单，鲁棒，安全，高性能。</div><div class="line">不过将SQL语句转换为存储过程前，也必须知道其缺陷：</div><div class="line">1. 编写存储过程比基本的SQL语句复杂</div><div class="line">2. 可能没有创建存储过程的安全访问权限，很多数据库管理人员允许用户使用存储过程，但是不允许他们创建存储过程。</div><div class="line"></div><div class="line">#### 使用存储过程</div><div class="line">存储过程的执行称之为调用，call 接受存储过程的名字以及需要传递给它的任意参数</div></pre></td></tr></table></figure></p>
<p>call productpricing(<br>    @pricelow,<br>    @pricehigh,<br>    @priceaverage<br>    );<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 创建存储过程</div></pre></td></tr></table></figure></p>
<p>create procedure productpricing()<br>begin<br>    select avg(prod_price) as priceaverage<br>    from products;<br>end;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">call productpricing();</div><div class="line">priceaverage</div><div class="line">16.133571</div></pre></td></tr></table></figure></p>
<h4 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h4><p>存储过程被创建之后，被保存在服务器上以供使用，直至被删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">drop procedure productpricing;</div><div class="line">``` </div><div class="line"></div><div class="line">#### 使用参数</div><div class="line">productpricing 只是一个简单的存储过程，它简单地显示select语句的结果，一般，存储过程并不显示结果，而是把结果返回给你指定的变量。</div><div class="line">**变量内存中的一个特定位置，用来临时存储数据**</div><div class="line">以下是 productpricing 的修改版本，如果不先删除此存储过程，则不能再次创建它</div></pre></td></tr></table></figure></p>
<p>create procedure productpricing (<br>    out pl decimal(8, 2),<br>    out ph decimal(8, 2),<br>    out pa decimal(8, 2)<br>)<br>begin<br>    select min(prod_price)<br>    into pl<br>    from products;<br>    select max(prod_price)<br>    into ph<br>    from products;<br>    select avg(prod_price)<br>    into pa<br>    from products;<br>end;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">关键字 out 指出相应的参数用来从存储过程传出一个值（返回给调用者），MySQL 支持IN（传递给存储过程）、out（从存储过程传出）和inout（对存储过程传入和传出）。</div></pre></td></tr></table></figure></p>
<p>call productpricing(<br>    @pricelow,<br>    @pricehigh,<br>    @priceaverage<br>    );<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">由于此存储过程要求3个参数，因此必须正好传递3个参数，不多也不少，所以，这条call语句给出3个参数，存储过程将把结果保存进这三个变量中。</div></pre></td></tr></table></figure></p>
<p>select @priceaverage;<br>@priceaverage<br>16.133571428<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">下面是一个使用in和out参数的例子，ordertotal 接受订单号并返回该订单的合计：</div></pre></td></tr></table></figure></p>
<p>create procedure ordertotal (<br>    in onumber int,<br>    out ototal decimal(8, 2)<br>)<br>begin<br>    select sum(item_price*quantity)<br>    from orderitems<br>    where order_num = onumber<br>    into ototal;<br>end;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">call ordertotal(20005, @total);</div><div class="line">select @total;</div><div class="line">@total</div><div class="line">149.87</div></pre></td></tr></table></figure></p>
<h3 id="Chapter-24-使用游标"><a href="#Chapter-24-使用游标" class="headerlink" title="Chapter 24 使用游标"></a>Chapter 24 使用游标</h3><p>有时，需要在检索出来的行中前进或者后退一行或者多行，这就是使用游标的原因，cursor 是一个存储在MySQL服务器上的数据库查询，它不是一条select语句，而是被该语句检索出来的数据集，在得到了游标之后，应用程序可以根据需要滚动或者浏览其中的数据。游标主要应用于交互式应用，其中用户可以滚动数据并对数据进行浏览或者做出更改。<br>不像多数DBMS，MySQL游标只能用于存储过程和函数。</p>
<h4 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h4><ol>
<li>在能够使用游标前，必须定义它，这个过程实际上并没有检索数据，它只是定义要使用的select语句。</li>
<li>一旦定义之后，必须打开游标以供使用，这个过程用前面定义的select语句把实际数据检索出来了</li>
<li>对于填有数据的游标，根据需要取出各行</li>
<li>在结束游标使用之后，必须关闭游标。<br>在定义游标之后，可以按需频繁的打开和关闭游标，在游标打开之后，可按需频繁地执行取操作。</li>
</ol>
<h4 id="创建游标"><a href="#创建游标" class="headerlink" title="创建游标"></a>创建游标</h4><p>游标用declare 语句创建，并定义相应地select语句，根据需要带where和其他子句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">create procedure processorders()</div><div class="line">begin</div><div class="line">    declare ordernumbers cursor</div><div class="line">    for</div><div class="line">    select order_num from orders;</div><div class="line">end;</div></pre></td></tr></table></figure></p>
<h4 id="打开和关闭游标"><a href="#打开和关闭游标" class="headerlink" title="打开和关闭游标"></a>打开和关闭游标</h4><p>在处理open语句时执行查询，临时存储检索出的数据以供浏览和滚动。<br><code>open ordernumbers;</code><br>close 释放游标所使用的所有内部内存和资源，因此每个游标在不再需要时就应该关闭。<br><code>close ordernumbers;</code><br><strong>隐含关闭</strong>： 如果你不明确关闭游标，MySQL 将会在到达end语句时自动关闭它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">create procedure processorders()</div><div class="line">begin</div><div class="line">    -- declare the cursor</div><div class="line">    declare ordernumbers cursor</div><div class="line">    for</div><div class="line">    select order_num from orders;</div><div class="line"></div><div class="line">    -- open the cursor</div><div class="line">    open ordernumbers;</div><div class="line"></div><div class="line">    -- close the cursor</div><div class="line">    close ordernumbers;</div><div class="line">end;</div></pre></td></tr></table></figure></p>
<p>这个存储过程定义，打开和关闭了一个游标，但是对于检索出来的数据什么处理也没有做。</p>
<h4 id="使用游标数据"><a href="#使用游标数据" class="headerlink" title="使用游标数据"></a>使用游标数据</h4><p>在一个游标被打开之后，可以使用fetch语句分别访问它的每一行，fetch 指定检索什么数据（所需的列），检索出来的数据存储在什么地方，它还向前移动游标中的内部指针，使得下一条fetch语句检索的是下一行而不是同一行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">create procedure processorders()</div><div class="line">begin</div><div class="line">    -- declare local variable</div><div class="line">    declare o int;</div><div class="line"></div><div class="line">    -- declare the cursor</div><div class="line">    declare ordernumbers cursor</div><div class="line">    for</div><div class="line">    select order_num from orders;</div><div class="line"></div><div class="line">    -- open the cursor</div><div class="line">    open ordernumbers;</div><div class="line"></div><div class="line">    -- get order number</div><div class="line">    fetch ordernumbers into o;</div><div class="line">    </div><div class="line">    -- close the cursor</div><div class="line">    close ordernumbers;</div><div class="line">end;</div></pre></td></tr></table></figure></p>
<p>fetch 检索当前行的 order_num 列（自动从第一行开始）到一个名为 o 的局部变量中，对检索出的数据不做任何处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">create procedure processorders()</div><div class="line">begin</div><div class="line">    -- declare local variable</div><div class="line">    declare done boolean default 0;</div><div class="line">    declare o int;</div><div class="line"></div><div class="line">    -- declare the cursor</div><div class="line">    declare ordernumbers cursor</div><div class="line">    for</div><div class="line">    select order_num from orders;</div><div class="line"></div><div class="line">    -- declare continue handler</div><div class="line">    declare continue handler for sqlstate &apos;02000&apos; set done = 1;</div><div class="line"></div><div class="line">    -- open the cursor</div><div class="line">    open ordernumbers;</div><div class="line"></div><div class="line">    -- loop through all rows</div><div class="line">    repeat</div><div class="line"></div><div class="line">        -- get order number</div><div class="line">        fetch ordernumbers into o;</div><div class="line"></div><div class="line">    -- end of loop</div><div class="line">    until done end repeat;</div><div class="line"></div><div class="line">    -- close the cursor</div><div class="line">    close ordernumbers;</div><div class="line">end;</div></pre></td></tr></table></figure></p>
<p><code>declare continue handler for sqlstate &#39;02000&#39; set done = 1;</code>这条语句定义了一个 continue handler，它是在条件出现时被执行的代码，这里，它指出当 SQLSTATE 为 ‘02000’ 条件出现时，set done = 1。SQLSTATE ‘02000’ 是一个未找到条件，当 repeat 由于没有更多的行供循环时，就会出现这个条件。</p>
<p><strong>declare 语句的次序</strong>：declare 语句的发布存在特定的次序，用declare 语句定义的局部变量必须在定义在任意游标或句柄之前，而句柄必须定义在游标之后，不遵守此顺序将产生错误信息。<br>进一步修改的版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">create procedure processorders()</div><div class="line">begin</div><div class="line">    -- declare local variable</div><div class="line">    declare done boolean default 0;</div><div class="line">    declare o int;</div><div class="line">    declare t decimal(8, 2);</div><div class="line"></div><div class="line">    -- declare the cursor</div><div class="line">    declare ordernumbers cursor</div><div class="line">    for</div><div class="line">    select order_num from orders;</div><div class="line"></div><div class="line">    -- declare continue handler</div><div class="line">    declare continue handler for sqlstate &apos;02000&apos; set done = 1;</div><div class="line"></div><div class="line">    -- create a table to store the results</div><div class="line">    create table if not exists ordertotals (</div><div class="line">        order_num   int,</div><div class="line">        total       decimal(8, 2)</div><div class="line">    );</div><div class="line"></div><div class="line">    -- open the cursor</div><div class="line">    open ordernumbers;</div><div class="line"></div><div class="line">    -- loop through all rows</div><div class="line">    repeat</div><div class="line"></div><div class="line">        -- get order number</div><div class="line">        fetch ordernumbers into o;</div><div class="line"></div><div class="line">        -- get the total for this order </div><div class="line">        call ordertotal(o, t);</div><div class="line"></div><div class="line">        -- insert order and total into ordertotals</div><div class="line">        insert into ordertotals (order_num, total)</div><div class="line">        values (o, t);</div><div class="line"></div><div class="line">    -- end of loop</div><div class="line">    until done end repeat;</div><div class="line"></div><div class="line">    -- close the cursor</div><div class="line">    close ordernumbers;</div><div class="line">end;</div></pre></td></tr></table></figure></p>
<p>此存储过程不返回数据，但它能够创建和填充另一个表，可以查看该表：<br><code>select * from ordertotals;</code>。</p>
<h3 id="Chapter-25-使用触发器"><a href="#Chapter-25-使用触发器" class="headerlink" title="Chapter 25 使用触发器"></a>Chapter 25 使用触发器</h3><p>需要某条语句或者某些语句在事件发生时自动执行。<br>比如：</p>
<ul>
<li>每当增加一个顾客到某个数据库表时，都检查其电话号码格式是否正确，州的缩写是否大写；</li>
<li>每当订购一个产品时，都从库存数量中减去订购的数量</li>
<li>无论何时删除一行，都在某个存档表中保留一个副本</li>
</ul>
<p>所有的这些例子共同之处就是它们都需要在某个表发生变动时自动处理，触发器是MySQL响应以下任意语句时而自动执行的一条MySQL语句（或位于begin和end之间的一组语句）：</p>
<ul>
<li>update</li>
<li>insert</li>
<li>delete<br>其他语句不触发触发器。</li>
</ul>
<h4 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h4><ol>
<li>唯一的触发器名</li>
<li>触发器关联的表</li>
<li>触发器应该响应的活动（update insert delete）</li>
<li>触发器何时执行（处理之前或者处理之后）<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">create trigger newproduct after insert on products</div><div class="line">for each row select &apos;Product added&apos;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>文本 Product added 将对每个插入的行显示一次。<br><strong>只有表才支持触发器，视图不支持，临时表也不支持。</strong><br>触发器按每个表每个事件每次地定义，每个表每个事件只允许一个触发器，每个表最多支持6个触发器，每条insert，update，delete的之前和之后，单一触发器不能与多个事件或者多个表关联，所以如果你需要一个对insert和update操作都触发的触发器，则应该定义两个触发器。<br><strong>触发器失败</strong>：如果before触发器失败，则mysql将不执行请求的操作，此外如果before触发器或者语句本身失败，MySQL将不执行after触发器。</p>
<h4 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">drop trigger newproduct;</div></pre></td></tr></table></figure>
<p>触发器不能更改或者覆盖，为了修改一个触发器，必须先删除它，然后再重新创建。</p>
<h4 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h4><h5 id="insert-触发器："><a href="#insert-触发器：" class="headerlink" title="insert 触发器："></a>insert 触发器：</h5><ol>
<li>在insert触发器代码内部可以引用一个名为NEW的虚拟表，访问被插入的行</li>
<li>在before insert触发器中，NEW中的值也可以被更新（允许更改被插入的值）</li>
<li>对于 auto_increment 列，new 在insert执行之前是0，在insert执行之后包含新的自动生成值。<br>比<code>select last_insert_id();</code>更好的方法是<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">create trigger neworder after insert on orders</div><div class="line">for each row select new.order_num;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>为了测试这个触发器<br><code>insert into orders (order_date, cust_id) values (now(), 10001);</code><br>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">order_num</div><div class="line">20010</div></pre></td></tr></table></figure></p>
<p><strong>before or after</strong>: 通常将before用于数据验证和净化，目的是保证插入表中的数据确实是需要的数据。</p>
<h5 id="delete触发器"><a href="#delete触发器" class="headerlink" title="delete触发器"></a>delete触发器</h5><p>在delete触发器代码内部，可以引用一个名为old的虚拟表，访问被删除的行。</p>
<h3 id="Chapter-26-管理事务处理"><a href="#Chapter-26-管理事务处理" class="headerlink" title="Chapter 26 管理事务处理"></a>Chapter 26 管理事务处理</h3><p>并不是所有的引擎都支持事务处理<br>transaction processing 可以用于维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。<br>几个常用的术语：</p>
<ol>
<li>事务 transaction 指一组SQL语句</li>
<li>回退 rollback 指撤销指定SQL语句的过程</li>
<li>提高 commit 指将未存储的SQL语句结果写入数据库表</li>
<li>保留点 savepoint 指事务处理中设置的临时占位符，你可以对它发布回退（与回退整个事务处理不同）</li>
</ol>
<h4 id="控制事务处理"><a href="#控制事务处理" class="headerlink" title="控制事务处理"></a>控制事务处理</h4><p>管理事务处理的关键在于将SQL语句组分解为逻辑块，并明确规定数据何时应该回退，何时不应该回退。<br>用<code>start transaction</code>标识事务的开始</p>
<h6 id="使用rollback-来回退MySQL语句"><a href="#使用rollback-来回退MySQL语句" class="headerlink" title="使用rollback 来回退MySQL语句"></a>使用rollback 来回退MySQL语句</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">select * from ordertotals;</div><div class="line">start transaction;</div><div class="line">delete from ordertotals;</div><div class="line">select * from ordertotals;</div><div class="line">rollback;</div><div class="line">select * from ordertotals;</div></pre></td></tr></table></figure>
<p>哪些语句可以回退？<br>事务处理用来管理insert，update，delete语句，不能回退create或者drop操作，事务处理块中可以使用这两条语句，但是如果你执行回退，它们不会被撤销。</p>
<h6 id="使用-commit"><a href="#使用-commit" class="headerlink" title="使用 commit"></a>使用 commit</h6><p>一般的MySQL语句都是直接针对数据库表执行和编写的，这就是所谓的隐含提交（implicit commit），即提交操作是自动进行的。<br>但是，在事务处理块中，提交不会隐含地进行，为明确地进行提交，使用commit语句，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">start transaction;</div><div class="line">delete from orderitems where order_num = 20010;</div><div class="line">delete from orders where order_num = 20010;</div><div class="line">commit;</div></pre></td></tr></table></figure></p>
<p>在这个例子中，从系统中完全删除订单20010，因为涉及到更新两个数据库表，所以使用事务处理块来保证订单不会被部分删除。最后地commit仅在不出错时写出更改，如果第一条delete起作用，但第二条语句失败，则delete会被撤销。<br>当commit或者rollback之后，事务会自动隐含关闭。</p>
<h5 id="使用保留点"><a href="#使用保留点" class="headerlink" title="使用保留点"></a>使用保留点</h5><p>简单的 rollback 和 commit 语句就可以写入或者撤销整个事务处理，但是更复杂的事务处理可能需要部分提交或者部分回退。<br>为了支持回退部分事务处理，必须在事务处理块中的合适位置放置占位符，这样，如果需要回退，可以回退到某个占位符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">savepoint delete1;</div><div class="line">....</div><div class="line">rollback to delete1;</div></pre></td></tr></table></figure></p>
<p>savepoint 越多越好。<br>保留点在事务处理完成（执行一条rollback或者commit）后自动释放，也可以使用release savepoint 来显式地释放保留点。<br>更改默认的提交行为，默认的MySQL行为是自动提交所有更改，为了指示MySQL不自动提交更改，需要使用以下语句<br><code>set autocommit = 0;</code><br>autocommit 标志是针对每个连接而不是服务器的。</p>
<h3 id="Chapter-28-安全管理"><a href="#Chapter-28-安全管理" class="headerlink" title="Chapter 28 安全管理"></a>Chapter 28 安全管理</h3><p>访问控制，MySQL服务器的安全基础是：用户对于他们需要的数据具有适当的访问权，既不能多也不能少。<br>不要使用root，应该严肃对待root登陆的使用，仅在绝对需要时使用它，或许在你不能登陆其他管理账号时使用，不应该在日常的MySQL操作中使用root。<br>MySQL 用户账号和信息存储在名为mysql的MySQL数据库中，一般不需要直接访问mysql数据库和表，但是有时需要直接访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">use mysql;</div><div class="line">select user from user;</div></pre></td></tr></table></figure></p>
<h5 id="创建用户账号"><a href="#创建用户账号" class="headerlink" title="创建用户账号"></a>创建用户账号</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">create user ben identified by &apos;opop&apos;;</div></pre></td></tr></table></figure>
<p>使用 grant 或者 insert 也可以创建用户账号。但是为了安全起见，不建议直接对user表进行插入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rename user ben to bforta;</div><div class="line">...</div><div class="line">drop user bforta;</div></pre></td></tr></table></figure></p>
<p>MySQL 5 之前：自MySQL 5 以来，drop user 删除用户账号和所有相关的账号权限，在MySQL 5以前，drop user 只能用于删除用户账户，不能删除相关的权限，因此如果使用旧版本的MySQL，需要先revoke删除与账号相关的权限，然后再使用 drop user 删除账号。</p>
<h4 id="设置访问权限"><a href="#设置访问权限" class="headerlink" title="设置访问权限"></a>设置访问权限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">show grants for bforta;</div><div class="line"></div><div class="line">Grants for bforta@%</div><div class="line">GRANT USAGE ON *.* TO &apos;bforta&apos;@&apos;%&apos;</div></pre></td></tr></table></figure>
<p>USAGE 表示根本没有任何权限，此结果表示在任意数据库和任意表上对任何东西都没有权限。<br>为了设置权限，使用grant语句，grant要求你至少给出以下信息：</p>
<ul>
<li>要授予的权限</li>
<li>被授予访问权限的数据库或表</li>
<li>用户名<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grant select on crashcourse.* to bforta;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>用户 bforta 对于 crashcourse 数据库中的所有数据具有只读访问权限。<br><code>show grants for bforta;</code>反映了这个更改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Grants for bforta@%</div><div class="line">GRANT USAGE ON *.* TO &apos;bforta&apos;@&apos;%&apos;</div><div class="line">GRANT SELECT ON &apos;crashcourse&apos;.* TO &apos;bforta&apos;@&apos;%&apos;</div></pre></td></tr></table></figure></p>
<p>grant 的反操作为 revoke，用它来撤销特定的权限，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">revoke select on crashcourse.* from bforta;</div></pre></td></tr></table></figure></p>
<p>被撤销的访问权限必须存在，否则就会出错。<br>grant 和 revoke 可在几个层次上控制访问权限：</p>
<ul>
<li>整个服务器，grant all 和 revoke all</li>
<li>整个数据库，使用 on database.*</li>
<li>特定的表，使用 on database.table</li>
<li>特定的列</li>
<li>特定的存储过程</li>
</ul>
<h3 id="Chapter-30-改善性能"><a href="#Chapter-30-改善性能" class="headerlink" title="Chapter 30 改善性能"></a>Chapter 30 改善性能</h3><p><strong>数据库管理员把他们生命中的相当一部分时间花在了调整、试验以及改善DBMS性能之上</strong>。在诊断应用的滞缓现象和性能问题时，性能不良的数据库以及数据库查询通常是最常见的祸因。</p>
<ul>
<li>调整内存分配，缓冲区大小，为了查看当前设置，可使用show variable;和show status;。</li>
<li>MySQL 是一个多用户多线程的DBMS，换言之，它经常同时执行多个任务，如果这些任务中的某一个执行缓慢，则所有请求都会执行缓慢，使用 show processlist; 显示所有活动进程以及它们的线程ID和执行时间，还可以使用kill命令终结某个特定的进程。</li>
<li>总是有不止一种方法编写同一条select语句，应该试验join，union，子查询等，找出最佳的方法。</li>
<li>使用explain 语句让MySQL 解释它将如何执行一条select语句</li>
<li>一般而言，存储过程执行得比逐条要快</li>
<li>应该总是使用正确的数据类型</li>
<li>绝不要检索比需求还要多的数据</li>
<li>有的操作（包括insert）支持一个可选的delayed关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。</li>
<li>在导入数据时，应该关闭自动提交，可以删除索引，包括fulltext索引，然后在导入完成后再重建它们。</li>
<li>必须索引数据库表以改善数据检索的性能确认索引挺难的，需要分析实用的select语句以找出重复的where和order by 子句，如果一个简单的where子句返回结果所需的时间太长，则可以判定其中使用的列或者几列就是需要索引的对象。</li>
<li>你的select 语句中有一系列复杂的or条件吗？通过使用多条select语句和连接它们的union语句，你能看到极大的性能提升。</li>
<li>索引可以改善数据检索的性能，但是损害数据插入、删除和更新的性能，如果一些表收集数据且不被经常检索，可以无需索引，索引可以按需添加和删除</li>
<li>like 很慢，一般来说，使用 fulltext 而不是 like。</li>
</ul>

        </div>
    

</div>
            
        </section>
    </div>
</div>



    <div class="row">
        <div class="col-sm-12">
            <div class="wrap-pagination">
                <a class="" href="/page/2/">
                    <i class="fa fa-chevron-left" aria-hidden="true"></i>
                </a>
                <a class="" href="/page/4/">
                    <i class="fa fa-chevron-right" aria-hidden="true"></i>
                </a>
            </div>
        </div>
    </div>




</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This is Robert Lexis (FengCun Li). To see the world, things dangerous to come to, to see behind walls, to draw closer, to find each other and to feel. That is the purpose of LIFE.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2018/08/26/YOLO/">YOLO</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/26/非最大值抑制/">非最大值抑制</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/26/目标定位-vs-目标检测/">目标定位 vs 目标检测</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/13/消失的梯度/">消失的梯度</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/RobertLexis">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:robert_lexis@163.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Robert Lexis Loves Wenny
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>