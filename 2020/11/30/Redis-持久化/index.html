<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Redis 持久化 如果使用默认的数据 fsync 策略，也就是 appendfsync everysec，如果硬件宕机（server power outage），上图中整个图就会死掉，Buffer 中数据丢失，（仅仅）会丢失一秒的 writes 记录；如果是 Redis 进程出错/死掉而操作系统依旧正常运行，也就是上图中 1 处出现问题，仅仅会丢失一条 writes 记录。">
<meta name="keywords" content="Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 持久化">
<meta property="og:url" content="http://yoursite.com/2020/11/30/Redis-持久化/index.html">
<meta property="og:site_name" content="The next stop - Antarctica">
<meta property="og:description" content="Redis 持久化 如果使用默认的数据 fsync 策略，也就是 appendfsync everysec，如果硬件宕机（server power outage），上图中整个图就会死掉，Buffer 中数据丢失，（仅仅）会丢失一秒的 writes 记录；如果是 Redis 进程出错/死掉而操作系统依旧正常运行，也就是上图中 1 处出现问题，仅仅会丢失一条 writes 记录。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2020/11/30/Redis-持久化/fsync.png">
<meta property="og:updated_time" content="2020-12-25T07:35:01.567Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis 持久化">
<meta name="twitter:description" content="Redis 持久化 如果使用默认的数据 fsync 策略，也就是 appendfsync everysec，如果硬件宕机（server power outage），上图中整个图就会死掉，Buffer 中数据丢失，（仅仅）会丢失一秒的 writes 记录；如果是 Redis 进程出错/死掉而操作系统依旧正常运行，也就是上图中 1 处出现问题，仅仅会丢失一条 writes 记录。">
<meta name="twitter:image" content="http://yoursite.com/2020/11/30/Redis-持久化/fsync.png">

<link rel="canonical" href="http://yoursite.com/2020/11/30/Redis-持久化/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Redis 持久化 | The next stop - Antarctica</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">The next stop - Antarctica</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">To see behind walls. To draw closer.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/30/Redis-持久化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Fengcun Li">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The next stop - Antarctica">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis 持久化
        </h1>

        <div class="post-meta">
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-25 15:35:01" itemprop="dateModified" datetime="2020-12-25T15:35:01+08:00">2020-12-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><p><img src="/2020/11/30/Redis-持久化/fsync.png" alt="fsync"></p>
<p>如果使用默认的数据 <code>fsync</code> 策略，也就是 <code>appendfsync everysec</code>，如果硬件宕机（server power outage），上图中整个图就会死掉，Buffer 中数据丢失，（仅仅）会丢失一秒的 <code>writes</code> 记录；如果是 Redis 进程出错/死掉而操作系统依旧正常运行，也就是上图中 1 处出现问题，仅仅会丢失一条 <code>writes</code> 记录。</p>
<a id="more"></a>
<blockquote>
<p>For instance using the default data fsync policy<br>(see later in the config file) Redis can lose just one second of writes in a<br>dramatic event like a server power outage, or a single write if something<br>wrong with the Redis process itself happens, but the operating system is<br>still running correctly.</p>
</blockquote>
<blockquote>
<p>By default Redis <strong>asynchronously</strong> dumps the dataset on disk. This mode is<br>good enough in many applications, but an issue with the Redis process or<br>a power outage may result into a few minutes of writes lost (depending on<br>the configured save points).<br>The Append Only File is an alternative persistence mode that provides<br>much better durability.</p>
</blockquote>
<blockquote>
<p><strong>AOF</strong> and <strong>RDB</strong> persistence can be enabled at the same time without problems.<br>If the AOF is enabled on startup Redis will load the AOF, <strong>that is the file with the better durability guarantees</strong>.</p>
</blockquote>
<h2 id="BSD-System-Calls-Manual-fsync"><a href="#BSD-System-Calls-Manual-fsync" class="headerlink" title="BSD System Calls Manual fsync"></a>BSD System Calls Manual fsync</h2><h3 id="NAME"><a href="#NAME" class="headerlink" title="NAME"></a>NAME</h3><p><code>fsync</code> – synchronize a file’s in-core state with that on disk</p>
<h3 id="SYNOPSIS"><a href="#SYNOPSIS" class="headerlink" title="SYNOPSIS"></a>SYNOPSIS</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fildes)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="DESCRIPTION"><a href="#DESCRIPTION" class="headerlink" title="DESCRIPTION"></a>DESCRIPTION</h3><p><code>fsync()</code> causes all modified data and attributes of fildes to be moved to a permanent storage device. This normally results in all in-core modified copies of buffers for the associated file to be written to a disk.</p>
<p>Note that while <code>fsync()</code> will flush all data from the host to the drive (i.e. the “permanent storage device”), the drive itself may not physically write the data to the platters for quite some time and it may be written in an out-of-order sequence.</p>
<p>Specifically, if the drive loses power or the OS crashes, the application may find that only some or none of their data was written. The disk drive may also re-order the data so that later writes may be present, while earlier writes are not.</p>
<p>This is not a theoretical edge case. This scenario is easily reproduced with real world workloads and drive power failures.</p>
<p>For applications that require tighter guarantees about the integrity of their data, Mac OS X provides the <code>F_FULLFSYNC fcntl</code>. The <code>F_FULLFSYNC fcntl</code> asks the drive to flush all buffered data to permanent storage. Applications, such as databases, that require a strict ordering of writes should use <code>F_FULLFSYNC</code> to ensure that their data is written in the order they expect. Please see fcntl(2) for more detail.</p>
<h3 id="RETURN-VALUES"><a href="#RETURN-VALUES" class="headerlink" title="RETURN VALUES"></a>RETURN VALUES</h3><p>The <code>fsync()</code> function returns the value 0 if successful; otherwise the value -1 is returned and the global variable errno is set to indicate the error.</p>
<h3 id="ERRORS"><a href="#ERRORS" class="headerlink" title="ERRORS"></a>ERRORS</h3><p>The <code>fsync()</code> system call will fail if:</p>
<p><code>[EBADF]</code> fildes is not a valid descriptor.</p>
<p><code>[EINTR]</code> Its execution is interrupted by a signal.</p>
<p><code>[EINVAL]</code> fildes refers to a file type (e.g., a socket) that does not support this operation.</p>
<p><code>[EIO]</code> An I/O error occurred while reading from or writing to the file system. If a queued I/O operation fails, <code>fsync()</code> may fail with any of the errors defined for <code>read(2)</code> or <code>write(2)</code>.</p>
<h3 id="HISTORY"><a href="#HISTORY" class="headerlink" title="HISTORY"></a>HISTORY</h3><p>The <code>fsync()</code> function call appeared in 4.2BSD.</p>
<h2 id="Linux-Programmer’s-Manual-fsync"><a href="#Linux-Programmer’s-Manual-fsync" class="headerlink" title="Linux Programmer’s Manual fsync"></a>Linux Programmer’s Manual fsync</h2><h3 id="NAME-1"><a href="#NAME-1" class="headerlink" title="NAME"></a>NAME</h3><p><code>fsync</code>, <code>fdatasync</code> - synchronize a file’s in-core state with storage device</p>
<h3 id="SYNOPSIS-1"><a href="#SYNOPSIS-1" class="headerlink" title="SYNOPSIS"></a>SYNOPSIS</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="DESCRIPTION-1"><a href="#DESCRIPTION-1" class="headerlink" title="DESCRIPTION"></a>DESCRIPTION</h3><p><code>fsync()</code> transfers (“flushes”) all modified in-core data of (i.e., modified buffer cache pages for) the file referred to by the file descriptor <code>fd</code> to the disk device (or other permanent storage device) so that all changed information can be retrieved even if the system crashes or is rebooted. This includes writing through or flushing a disk cache if present. <strong>The call blocks until the device reports that the transfer has completed.</strong></p>
<p>As well as flushing the file data, <code>fsync()</code> also flushes the metadata information associated with the file (see <code>inode(7)</code>).</p>
<p>Calling <code>fsync()</code> does not necessarily ensure that the entry in the directory containing the file has also reached disk. For that an explicit <code>fsync()</code> on a file descriptor for the directory is also needed.</p>
<p><code>fdatasync()</code> is similar to <code>fsync()</code>, but does not flush modified metadata unless that metadata is needed in order to allow a subsequent data retrieval to be correctly handled. For example, changes to <code>st_atime</code> or <code>st_mtime</code> (respectively, time of last access and time of last modification; see <code>inode(7)</code>) do not require flushing because they are not necessary for a subsequent data read to be handled correctly. On the other hand, a change to the file size (<code>st_size</code>, as made by say <code>ftruncate(2)</code>), would require a metadata flush.</p>
<p>The aim of <code>fdatasync()</code> is to reduce disk activity for applications that do not require all metadata to be synchronized with the disk.</p>
<h3 id="RETURN-VALUE"><a href="#RETURN-VALUE" class="headerlink" title="RETURN VALUE"></a>RETURN VALUE</h3><p>On success, these system calls return zero. On error, -1 is returned, and errno is set appropriately.</p>
<h3 id="ERRORS-1"><a href="#ERRORS-1" class="headerlink" title="ERRORS"></a>ERRORS</h3><p><code>EBADF</code> fd is not a valid open file descriptor.</p>
<p><code>EIO</code> An error occurred during synchronization. This error may relate to data written to some other file descriptor on the same file. Since Linux 4.13, errors from write-back will be reported to all file descriptors that might have written the data which triggered the error. Some filesystems (e.g., NFS) keep close track of which data came through which file descriptor, and give more precise reporting. Other filesystems (e.g., most local filesystems) will report errors to all file descriptors that were open on the file when the error was recorded.</p>
<p><code>ENOSPC</code> Disk space was exhausted while synchronizing.</p>
<p><code>EROFS, EINVAL</code><br>fd is bound to a special file (e.g., a pipe, FIFO, or socket) which does not support synchronization.</p>
<p><code>ENOSPC, EDQUOT</code><br>fd is bound to a file on NFS or another filesystem which does not allocate space at the time of a write(2) system call, and some previous write failed due to insufficient storage space.</p>
<h3 id="NOTES"><a href="#NOTES" class="headerlink" title="NOTES"></a>NOTES</h3><p>On some UNIX systems (but not Linux), fd must be a writable file descriptor.</p>
<p>In Linux 2.2 and earlier, fdatasync() is equivalent to fsync(), and so has no performance advantage.</p>
<p>The <code>fsync()</code> implementations in older kernels and lesser used file systems do not know how to flush disk caches. In these cases disk caches need to be disabled using <code>hdparm(8)</code> or <code>sdparm(8)</code> to guarantee safe operation.</p>
<p>This page provides a technical description of Redis persistence, it is a suggested read for all Redis users. For a wider overview of Redis persistence and the durability guarantees it provides you may also want to read Redis persistence demystified.</p>
<h2 id="Redis-Persistence"><a href="#Redis-Persistence" class="headerlink" title="Redis Persistence"></a>Redis Persistence</h2><p><a href="https://redis.io/topics/persistence" target="_blank" rel="noopener">Redis Persistence</a><br><strong>和 replication 一样，理解 Redis 的持久化也主要关注堵塞操作、一致性、完整性（integrity）的问题。</strong></p>
<p>Redis provides a different range of persistence options:</p>
<ul>
<li>The RDB persistence performs point-in-time snapshots of your dataset at specified intervals.</li>
<li>The AOF persistence logs every write operation received by the server, that will be played again at server startup, reconstructing the original dataset. Commands are logged using the same format as the Redis protocol itself, in an append-only fashion. Redis is able to rewrite the log in the background when it gets too big.</li>
<li>If you wish, you can disable persistence completely, if you want your data to just exist as long as the server is running.</li>
<li>It is possible to combine both AOF and RDB in the same instance. Notice that, in this case, when Redis restarts the AOF file will be used to reconstruct the original dataset since it is guaranteed to be the most complete.</li>
</ul>
<p>The most important thing to understand is the different trade-offs between the RDB and AOF persistence. Let’s start with RDB:</p>
<h3 id="RDB-advantages"><a href="#RDB-advantages" class="headerlink" title="RDB advantages"></a>RDB advantages</h3><p>RDB is a very compact single-file point-in-time representation of your Redis data. <strong>RDB files are perfect for backups.（备份）</strong> For instance you may want to archive your RDB files every hour for the latest 24 hours, and to save an RDB snapshot every day for 30 days. This allows you to easily restore different versions of the data set in case of disasters.<br>RDB is very good for disaster recovery, being a single compact file that can be transferred to far data centers, or onto Amazon S3 (possibly encrypted).<br><strong>RDB maximizes Redis performances since the only work the Redis parent process needs to do in order to persist is forking a child that will do all the rest. The parent instance will never perform disk I/O or alike. 无需堵塞，子进程拥有独立的进程地址空间（copy-on-write），将数据由内存写入文件时，父进程可以继续处理来自客户端的请求，虽然子进程看到的内存是过期的，但是这也正是快照的含义，允许两者之间 diverge。</strong><br>RDB allows faster restarts with big datasets compared to AOF.</p>
<h3 id="RDB-disadvantages"><a href="#RDB-disadvantages" class="headerlink" title="RDB disadvantages"></a>RDB disadvantages</h3><p>RDB is NOT good if you need to minimize the chance of data loss in case Redis stops working (for example after a power outage). You can configure different save points where an RDB is produced (for instance after at least five minutes and 100 writes against the data set, but you can have multiple save points). However you’ll usually create an RDB snapshot every five minutes or more, so in case of Redis stopping working without a correct shutdown for any reason you should be prepared to lose the latest minutes of data.<br>RDB needs to <code>fork()</code> often in order to persist on disk using a child process. <code>Fork()</code> can be time consuming if the dataset is big, and <strong>may result in Redis to stop serving clients for some millisecond or even for one second if the dataset is very big and the CPU performance not great（父进程堵在 fork 调用上，等待 fork return，这个过程，父进程是无法处理来自客户端的请求的）</strong>. AOF also needs to <code>fork()</code> but you can tune how often you want to rewrite your logs without any trade-off on durability.</p>
<h3 id="AOF-advantages"><a href="#AOF-advantages" class="headerlink" title="AOF advantages"></a>AOF advantages</h3><p>Using AOF Redis is much more durable: you can have different <code>fsync</code> policies: no fsync at all, fsync every second, fsync at every query. With the default policy of fsync every second write performances are still great (<strong>fsync is performed using a background thread and the main thread will try hard to perform writes when no fsync is in progress. 这个过程是需要加锁的，因为 write 需要在 buffer 里面写东西，而 fsync 是将 buffer 中的东西 flush 到硬盘，如果不加锁，就会出现混乱，interleave/覆盖等等各种形式的混乱。由于处理客户端写请求和将该写请求 log 进 buffer 是同步的，所以当 no fsync is in progress，Redis 可以很快地返回到用户；当 fsync 正在进行，造成锁定，此时 Redis 不得不等待锁的释放，从而将该写请求 log 进 buffer，然后才能返回到用户。</strong>) but you can only lose one second worth of writes.</p>
<p>The AOF log is an append only log, so there are no seeks, nor corruption problems if there is a power outage. Even if the log ends with an half-written command for some reason (disk full or other reasons) the redis-check-aof tool is able to fix it easily.<br>Redis is able to automatically rewrite the AOF in background when it gets too big. The rewrite is completely safe as while Redis continues appending to the old file, a completely new one is produced with the minimal set of operations needed to create the current data set, and once this second file is ready Redis switches the two and starts appending to the new one.<br>AOF contains a log of all the operations one after the other in an easy to understand and parse format. You can even easily export an AOF file. For instance even if you flushed everything for an error using a <code>FLUSHALL</code> command, if no rewrite of the log was performed in the meantime you can still save your data set just stopping the server, removing the latest command, and restarting Redis again.</p>
<h3 id="AOF-disadvantages"><a href="#AOF-disadvantages" class="headerlink" title="AOF disadvantages"></a>AOF disadvantages</h3><p>AOF files are usually bigger than the equivalent RDB files for the same dataset.<br>AOF can be slower than RDB depending on the exact fsync policy. In general with fsync set to every second performance is still very high, and with fsync disabled it should be exactly as fast as RDB even under high load. Still RDB is able to provide more guarantees about the maximum latency even in the case of an huge write load.<br>In the past we experienced rare bugs in specific commands (for instance there was one involving blocking commands like <code>BRPOPLPUSH</code>) causing the AOF produced to not reproduce exactly the same dataset on reloading. These bugs are rare and we have tests in the test suite creating random complex datasets automatically and reloading them to check everything is fine. However, these kind of bugs are almost impossible with RDB persistence. To make this point more clear: <strong>the Redis AOF works by incrementally updating an existing state, like MySQL or MongoDB does</strong>, while the RDB snapshotting creates everything from scratch again and again, that is conceptually more robust. However -</p>
<ol>
<li>It should be noted that every time the AOF is rewritten by Redis <strong>it is recreated from scratch starting from the actual data contained in the data set</strong>, making resistance to bugs stronger compared to an always appending AOF file (or one rewritten reading the old AOF instead of reading the data in memory).</li>
<li>We have never had a single report from users about an AOF corruption that was detected in the real world.</li>
</ol>
<h3 id="Ok-so-what-should-I-use"><a href="#Ok-so-what-should-I-use" class="headerlink" title="Ok, so what should I use?"></a>Ok, so what should I use?</h3><p>The general indication is that you should use both persistence methods if you want a degree of data safety comparable to what PostgreSQL can provide you.</p>
<p>If you care a lot about your data, but still can live with a few minutes of data loss in case of disasters, you can simply use RDB alone.</p>
<p>There are many users using AOF alone, but we discourage it since to have an RDB snapshot from time to time is a great idea for doing database backups, for faster restarts, and in the event of bugs in the AOF engine.</p>
<p>Note: for all these reasons we’ll likely end up unifying AOF and RDB into a single persistence model in the future (long term plan).</p>
<p>The following sections will illustrate a few more details about the two persistence models.</p>
<h3 id="Snapshotting"><a href="#Snapshotting" class="headerlink" title="Snapshotting"></a>Snapshotting</h3><p>By default Redis saves snapshots of the dataset on disk, in a binary file called dump.rdb. You can configure Redis to have it save the dataset every N seconds if there are at least M changes in the dataset, or you can manually call the SAVE or BGSAVE commands.</p>
<p>For example, this configuration will make Redis automatically dump the dataset to disk every 60 seconds if at least 1000 keys changed:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save 60 1000</span><br></pre></td></tr></table></figure>
<p>This strategy is known as snapshotting.</p>
<h4 id="How-it-works"><a href="#How-it-works" class="headerlink" title="How it works"></a>How it works</h4><p>Whenever Redis needs to dump the dataset to disk, this is what happens:</p>
<ol>
<li>Redis forks. We now have a child and a parent process. 自此之后，持久化过程就和父进程无关了。</li>
<li>The child starts to write the dataset to a temporary RDB file.</li>
<li>When the child is done writing the new RDB file, it replaces the old one.</li>
<li>This method allows Redis to benefit from copy-on-write semantics.</li>
</ol>
<h3 id="Append-only-file"><a href="#Append-only-file" class="headerlink" title="Append-only file"></a>Append-only file</h3><p>Snapshotting is not very durable. If your computer running Redis stops, your power line fails, or you accidentally kill -9 your instance, the latest data written on Redis will get lost. While this may not be a big deal for some applications, there are use cases for full durability, and in these cases Redis was not a viable option.</p>
<p>The append-only file is an alternative, fully-durable strategy for Redis. It became available in version 1.1.</p>
<p>You can turn on the AOF in your configuration file:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
<p>From now on, every time Redis receives a command that changes the dataset (e.g. SET) it will append it to the AOF. When you restart Redis it will re-play the AOF to rebuild the state.</p>
<h4 id="Log-rewriting"><a href="#Log-rewriting" class="headerlink" title="Log rewriting"></a>Log rewriting</h4><p>As you can guess, the AOF gets bigger and bigger as write operations are performed. For example, if you are incrementing a counter 100 times, you’ll end up with a single key in your dataset containing the final value, but 100 entries in your AOF. 99 of those entries are not needed to rebuild the current state.</p>
<p>So Redis supports an interesting feature: <strong>it is able to rebuild the AOF in the background without interrupting service to clients.（rewrite 是不会打扰到服务的，这和 fsync 不一样。）</strong> Whenever you issue a <code>BGREWRITEAOF</code> Redis will write the shortest sequence of commands needed to rebuild the current dataset in memory. If you’re using the AOF with Redis 2.2 you’ll need to run <code>BGREWRITEAOF</code> from time to time. Redis 2.4 is able to trigger log rewriting automatically (see the 2.4 example configuration file for more information).</p>
<h4 id="How-durable-is-the-append-only-file"><a href="#How-durable-is-the-append-only-file" class="headerlink" title="How durable is the append only file?"></a>How durable is the append only file?</h4><p>You can configure how many times Redis will fsync data on disk. There are three options:</p>
<ul>
<li>appendfsync always: fsync every time new commands are appended to the AOF. Very very slow, very safe. Note that the commands are apended to the AOF after a batch of commands from multiple clients or a pipeline are executed, so it means a single write and a single fsync (before sending the replies).</li>
<li>appendfsync everysec: fsync every second. Fast enough (in 2.4 likely to be as fast as snapshotting), and you can lose 1 second of data if there is a disaster.</li>
<li>appendfsync no: Never fsync, <strong>just put your data in the hands of the Operating System. The faster and less safe method. Normally Linux will flush data every 30 seconds with this configuration, but it’s up to the kernel exact tuning.</strong><br>The suggested (and default) policy is to fsync every second. It is both very fast and pretty safe. The always policy is very slow in practice, but it supports group commit, so if there are multiple parallel writes Redis will try to perform a single fsync operation.</li>
</ul>
<h4 id="What-should-I-do-if-my-AOF-gets-truncated"><a href="#What-should-I-do-if-my-AOF-gets-truncated" class="headerlink" title="What should I do if my AOF gets truncated?"></a>What should I do if my AOF gets truncated?</h4><p>It is possible that the server crashed while writing the AOF file, or that the volume where the AOF file is stored was full at the time of writing. When this happens the AOF still contains consistent data representing a given point-in-time version of the dataset (that may be old up to one second with the default AOF fsync policy), but the last command in the AOF could be truncated. The latest major versions of Redis will be able to load the AOF anyway, just discarding the last non well formed command in the file. In this case the server will emit a log like the following:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* Reading RDB preamble from AOF file...</span><br><span class="line">* Reading the remaining AOF tail...</span><br><span class="line"># !!! Warning: short read while loading the AOF file !!!</span><br><span class="line"># !!! Truncating the AOF at offset 439 !!!</span><br><span class="line"># AOF loaded anyway because aof-load-truncated is enabled</span><br></pre></td></tr></table></figure>
<p>You can change the default configuration to force Redis to stop in such cases if you want, but the default configuration is to continue regardless the fact the last command in the file is not well-formed, in order to guarantee availability after a restart.</p>
<p>Older versions of Redis may not recover, and may require the following steps:</p>
<ul>
<li>Make a backup copy of your AOF file.</li>
<li><p>Fix the original file using the redis-check-aof tool that ships with Redis:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ redis-check-aof --fix</span><br></pre></td></tr></table></figure>
</li>
<li><p>Optionally use diff -u to check what is the difference between two files.</p>
</li>
<li>Restart the server with the fixed file.</li>
</ul>
<h4 id="What-should-I-do-if-my-AOF-gets-corrupted"><a href="#What-should-I-do-if-my-AOF-gets-corrupted" class="headerlink" title="What should I do if my AOF gets corrupted?"></a>What should I do if my AOF gets corrupted?</h4><p>If the AOF file is not just truncated, but corrupted with invalid byte sequences in the middle, things are more complex. Redis will complain at startup and will abort:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* Reading the remaining AOF tail...</span><br><span class="line"># Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>The best thing to do is to run the redis-check-aof utility, initially without the –fix option, then understand the problem, jump at the given offset in the file, and see if it is possible to manually repair the file: the AOF uses the same format of the Redis protocol and is quite simple to fix manually. Otherwise it is possible to let the utility fix the file for us, but in that case all the AOF portion from the invalid part to the end of the file may be discarded, leading to a massive amount of data loss if the corruption happened to be in the initial part of the file.</p>
<h4 id="How-it-works-1"><a href="#How-it-works-1" class="headerlink" title="How it works"></a>How it works</h4><p>Log rewriting uses the same <code>copy-on-write</code> trick already in use for snapshotting. This is how it works:</p>
<ul>
<li>Redis forks, so now we have a child and a parent process.</li>
<li>The child starts writing the new AOF in a temporary file.</li>
<li>The parent accumulates all the new changes in an in-memory buffer (but at the same time it writes the new changes in the old append-only file, so if the rewriting fails, we are safe).</li>
<li>When the child is done rewriting the file, the parent gets a signal, and appends the in-memory buffer at the end of the file generated by the child. 这个过程中，parent 忙于该操作，是无法对外提供服务的，因此不会出现数据混乱的情况。</li>
<li>Profit! Now Redis atomically renames the old file into the new one, and starts appending new data into the new file. 这个过程中，parent 忙于该操作，是无法对外提供服务的，因此不会出现数据混乱的情况。</li>
</ul>
<h4 id="How-I-can-switch-to-AOF-if-I’m-currently-using-dump-rdb-snapshots"><a href="#How-I-can-switch-to-AOF-if-I’m-currently-using-dump-rdb-snapshots" class="headerlink" title="How I can switch to AOF, if I’m currently using dump.rdb snapshots?"></a>How I can switch to AOF, if I’m currently using dump.rdb snapshots?</h4><p>There is a different procedure to do this in Redis 2.0 and Redis 2.2, as you can guess it’s simpler in Redis 2.2 and does not require a restart at all.</p>
<h5 id="Redis-gt-2-2"><a href="#Redis-gt-2-2" class="headerlink" title="Redis &gt;= 2.2"></a>Redis &gt;= 2.2</h5><ol>
<li>Make a backup of your latest dump.rdb file.</li>
<li>Transfer this backup into a safe place.</li>
<li><p>Issue the following two commands:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli config set appendonly yes</span><br><span class="line">redis-cli config set save &quot;&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Make sure that your database contains the same number of keys it contained.</p>
</li>
<li>Make sure that writes are appended to the append only file correctly.</li>
</ol>
<p>The first CONFIG command enables the Append Only File. <strong>In order to do so Redis will block to generate the initial dump, then will open the file for writing, and will start appending all the next write queries. 必须得停下来，不能像 RDB 那样 fork 一个子进程去 dump，因为那样的话拿到的是内存快照，如果主进程继续对外提供服务则会出现 diverge，在具有 diverge 的基础上 aof 会谬以千里的。只能停下来，保证内存不会被修改，然后快照 dump，保证 aof 的基础是对的，这一切做完之后才能继续对外提供服务。为了保证一致性/完整性，在必要的地方停止服务，也实属无奈之举。</strong></p>
<p>The second CONFIG command is used to turn off snapshotting persistence. This is optional, if you wish you can take both the persistence methods enabled.</p>
<p>IMPORTANT: remember to edit your redis.conf to turn on the AOF, otherwise when you restart the server the configuration changes will be lost and the server will start again with the old configuration.</p>
<h5 id="Redis-2-0"><a href="#Redis-2-0" class="headerlink" title="Redis 2.0"></a>Redis 2.0</h5><ol>
<li>Make a backup of your latest dump.rdb file.</li>
<li>Transfer this backup into a safe place.</li>
<li>Stop all the writes against the database!</li>
<li>Issue a redis-cli BGREWRITEAOF. This will create the append only file.</li>
<li>Stop the server when Redis finished generating the AOF dump.</li>
<li>Edit redis.conf end enable append only file persistence.</li>
<li>Restart the server.</li>
<li>Make sure that your database contains the same number of keys it contained.</li>
<li>Make sure that writes are appended to the append only file correctly.</li>
</ol>
<h3 id="Interactions-between-AOF-and-RDB-persistence"><a href="#Interactions-between-AOF-and-RDB-persistence" class="headerlink" title="Interactions between AOF and RDB persistence"></a>Interactions between AOF and RDB persistence</h3><p>Redis &gt;= 2.4 makes sure to avoid triggering an AOF rewrite when an RDB snapshotting operation is already in progress, or allowing a BGSAVE while the AOF rewrite is in progress. <strong>This prevents two Redis background processes from doing heavy disk I/O at the same time.都是 fork 出了子进程去做事情。</strong></p>
<p>When snapshotting is in progress and the user explicitly requests a log rewrite operation using <code>BGREWRITEAOF</code> the server will reply with an OK status code telling the user the operation is scheduled, and the rewrite will start once the snapshotting is completed.</p>
<p>In the case both AOF and RDB persistence are enabled and Redis restarts the AOF file will be used to reconstruct the original dataset since it is guaranteed to be the most complete.</p>
<h3 id="Backing-up-Redis-data"><a href="#Backing-up-Redis-data" class="headerlink" title="Backing up Redis data"></a>Backing up Redis data</h3><p>Before starting this section, make sure to read the following sentence: <strong>Make Sure to Backup Your Database.</strong> Disks break, instances in the cloud disappear, and so forth: no backups means huge risk of data disappearing into /dev/null.</p>
<p>Redis is very data backup friendly since you can copy RDB files while the database is running: <strong>the RDB is never modified once produced, and while it gets produced it uses a temporary name and is renamed into its final destination atomically using rename(2) only when the new snapshot is complete.</strong> This means that copying the RDB file is completely safe while the server is running. This is what we suggest:</p>
<ul>
<li>Create a cron job in your server creating hourly snapshots of the RDB file in one directory, and daily snapshots in a different directory.</li>
<li>Every time the cron script runs, make sure to call the find command to make sure too old snapshots are deleted: for instance you can take hourly snapshots for the latest 48 hours, and daily snapshots for one or two months. Make sure to name the snapshots with data and time information.</li>
<li>At least one time every day make sure to transfer an RDB snapshot outside your data center or at least outside the physical machine running your Redis instance.</li>
</ul>
<p>If you run a Redis instance with only AOF persistence enabled, you can still copy the AOF in order to create backups. The file may lack the final part but Redis will be still able to load it (see the previous sections about truncated AOF files).</p>
<h3 id="Disaster-recovery"><a href="#Disaster-recovery" class="headerlink" title="Disaster recovery"></a>Disaster recovery</h3><p>Disaster recovery in the context of Redis is basically the same story as backups, plus the ability to transfer those backups in many different external data centers. This way data is secured even in the case of some catastrophic event affecting the main data center where Redis is running and producing its snapshots.</p>
<p>Since many Redis users are in the startup scene and thus don’t have plenty of money to spend we’ll review the most interesting disaster recovery techniques that don’t have too high costs.</p>
<ul>
<li>Amazon S3 and other similar services are a good way for implementing your disaster recovery system. Simply transfer your daily or hourly RDB snapshot to S3 in an encrypted form. You can encrypt your data using gpg -c (in symmetric encryption mode). Make sure to store your password in many different safe places (for instance give a copy to the most important people of your organization). It is recommended to use multiple storage services for improved data safety.</li>
<li>Transfer your snapshots using SCP (part of SSH) to far servers. This is a fairly simple and safe route: get a small VPS in a place that is very far from you, install ssh there, and generate an ssh client key without passphrase, then add it in the authorized_keys file of your small VPS. You are ready to transfer backups in an automated fashion. Get at least two VPS in two different providers for best results.<br>It is important to understand that this system can easily fail if not implemented in the right way. At least make absolutely sure that after the transfer is completed you are able to verify the file size (that should match the one of the file you copied) and possibly the SHA1 digest if you are using a VPS.</li>
</ul>
<p>You also need some kind of independent alert system if the transfer of fresh backups is not working for some reason.</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Redis/" rel="tag"># Redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/30/Redis-哨兵/" rel="prev" title="Redis 哨兵">
      <i class="fa fa-chevron-left"></i> Redis 哨兵
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/11/30/Redis-Top-K/" rel="next" title="Redis Top-K">
      Redis Top-K <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-持久化"><span class="nav-number">1.</span> <span class="nav-text">Redis 持久化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BSD-System-Calls-Manual-fsync"><span class="nav-number">2.</span> <span class="nav-text">BSD System Calls Manual fsync</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NAME"><span class="nav-number">2.1.</span> <span class="nav-text">NAME</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SYNOPSIS"><span class="nav-number">2.2.</span> <span class="nav-text">SYNOPSIS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DESCRIPTION"><span class="nav-number">2.3.</span> <span class="nav-text">DESCRIPTION</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RETURN-VALUES"><span class="nav-number">2.4.</span> <span class="nav-text">RETURN VALUES</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ERRORS"><span class="nav-number">2.5.</span> <span class="nav-text">ERRORS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HISTORY"><span class="nav-number">2.6.</span> <span class="nav-text">HISTORY</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-Programmer’s-Manual-fsync"><span class="nav-number">3.</span> <span class="nav-text">Linux Programmer’s Manual fsync</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NAME-1"><span class="nav-number">3.1.</span> <span class="nav-text">NAME</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SYNOPSIS-1"><span class="nav-number">3.2.</span> <span class="nav-text">SYNOPSIS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DESCRIPTION-1"><span class="nav-number">3.3.</span> <span class="nav-text">DESCRIPTION</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RETURN-VALUE"><span class="nav-number">3.4.</span> <span class="nav-text">RETURN VALUE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ERRORS-1"><span class="nav-number">3.5.</span> <span class="nav-text">ERRORS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NOTES"><span class="nav-number">3.6.</span> <span class="nav-text">NOTES</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-Persistence"><span class="nav-number">4.</span> <span class="nav-text">Redis Persistence</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-advantages"><span class="nav-number">4.1.</span> <span class="nav-text">RDB advantages</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-disadvantages"><span class="nav-number">4.2.</span> <span class="nav-text">RDB disadvantages</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF-advantages"><span class="nav-number">4.3.</span> <span class="nav-text">AOF advantages</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF-disadvantages"><span class="nav-number">4.4.</span> <span class="nav-text">AOF disadvantages</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ok-so-what-should-I-use"><span class="nav-number">4.5.</span> <span class="nav-text">Ok, so what should I use?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Snapshotting"><span class="nav-number">4.6.</span> <span class="nav-text">Snapshotting</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#How-it-works"><span class="nav-number">4.6.1.</span> <span class="nav-text">How it works</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Append-only-file"><span class="nav-number">4.7.</span> <span class="nav-text">Append-only file</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Log-rewriting"><span class="nav-number">4.7.1.</span> <span class="nav-text">Log rewriting</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#How-durable-is-the-append-only-file"><span class="nav-number">4.7.2.</span> <span class="nav-text">How durable is the append only file?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#What-should-I-do-if-my-AOF-gets-truncated"><span class="nav-number">4.7.3.</span> <span class="nav-text">What should I do if my AOF gets truncated?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#What-should-I-do-if-my-AOF-gets-corrupted"><span class="nav-number">4.7.4.</span> <span class="nav-text">What should I do if my AOF gets corrupted?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#How-it-works-1"><span class="nav-number">4.7.5.</span> <span class="nav-text">How it works</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#How-I-can-switch-to-AOF-if-I’m-currently-using-dump-rdb-snapshots"><span class="nav-number">4.7.6.</span> <span class="nav-text">How I can switch to AOF, if I’m currently using dump.rdb snapshots?</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Redis-gt-2-2"><span class="nav-number">4.7.6.1.</span> <span class="nav-text">Redis &gt;= 2.2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Redis-2-0"><span class="nav-number">4.7.6.2.</span> <span class="nav-text">Redis 2.0</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interactions-between-AOF-and-RDB-persistence"><span class="nav-number">4.8.</span> <span class="nav-text">Interactions between AOF and RDB persistence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Backing-up-Redis-data"><span class="nav-number">4.9.</span> <span class="nav-text">Backing up Redis data</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Disaster-recovery"><span class="nav-number">4.10.</span> <span class="nav-text">Disaster recovery</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Fengcun Li"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Fengcun Li</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">106</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Fengcun Li</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  











<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
