<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="yanm1ng&#39;s blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Python os.system 与 os.popen 的不同 | This is WHY.
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>This is WHY.</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>Python os.system 与 os.popen 的不同</h2>
  <p class="post-date">2017-11-03</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h3 id="两者是否等待子进程退出"><a href="#两者是否等待子进程退出" class="headerlink" title="两者是否等待子进程退出"></a>两者是否等待子进程退出</h3><p>在参加阿里金服《商场中精确定位用户所在店铺》的算法比赛时，使用的是 pandas 和 sklearn ，虽然在数据预处理时使用了 pandas 的 <code>melt</code> 和 <code>pivot</code> 等“批处理”方式，避免了使用循环对每一条记录进行预处理，但是由于数据量较大还是挺费时的，且这个过程是单线程的。在使用 sklearn 的 <code>RandomForestClassifier</code> 时通过指定 <code>n_jobs=-1</code>，可以开启多线程进行训练。在数据预处理和模型拟合是串行的情况下，数据预处理阶段 CPU 的线程（服务器是8核16线程）是没有跑满的，这是一个性能瓶颈。因此想要通过多线程或者多进程的方式充分利用 CPU 的计算能力。达到下面的效果。<br><img src="http://oytnj8g2y.bkt.clouddn.com/multithread.png" alt="multiprocess"><br>由于不同商场记录数目不一，所需的预处理和模型拟合时间不一，期望达到同一时刻有的进程处在预处理阶段，有的进程处于模型拟合阶段，避免 CPU 计算能力的浪费。</p>
<p>因此尝试了 Python os.system 和 os.popen，发现两者在是否等待子进程退出上存在不同。</p>
<h4 id="os-system"><a href="#os-system" class="headerlink" title="os.system"></a>os.system</h4><p>main.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line">print(&quot;Entering into main.py&quot;)</div><div class="line">os.system(&quot;python slave.py&quot;)</div><div class="line">print(&quot;Exiting from main.py&quot;)</div></pre></td></tr></table></figure></p>
<p>slave.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import time</div><div class="line">print(&quot;Entering into slave.py&quot;)</div><div class="line">time.sleep(10)</div><div class="line">print(&quot;Exiting from slave.py&quot;)</div></pre></td></tr></table></figure></p>
<p><code>python main.py</code>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Entering into main.py</div><div class="line">Entering into slave.py</div><div class="line">等待了大约10秒钟...</div><div class="line">Exiting from slave.py</div><div class="line">Exiting from main.py</div></pre></td></tr></table></figure></p>
<h4 id="os-popen"><a href="#os-popen" class="headerlink" title="os.popen"></a>os.popen</h4><p>main.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line">print(&quot;Entering into main.py&quot;)</div><div class="line">ofp = os.popen(python slave.py&quot;)</div><div class="line">print(&quot;Exiting from main.py&quot;)</div></pre></td></tr></table></figure></p>
<p>slave.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import time</div><div class="line">print(&quot;Entering into slave.py&quot;)</div><div class="line">time.sleep(10)</div><div class="line">print(&quot;Exiting from slave.py&quot;)</div></pre></td></tr></table></figure></p>
<p><code>python main.py</code>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Entering into main.py</div><div class="line">Exiting from main.py</div><div class="line">等待了大约10秒钟...</div><div class="line">Exception ignored in: &lt;_io.TextIOWrapper name=&apos;&lt;stdout&gt;&apos; mode=&apos;w&apos; encoding=&apos;UTF-8&apos;&gt;</div><div class="line">BrokenPipeError: [Errno 32] Broken pipe</div></pre></td></tr></table></figure></p>
<p>上面报错是因为<code>os.popen(python slave.py&quot;)</code>：</p>
<blockquote>
<p>os.popen: Open a pipe to or from command. The return value is an open file object connected to the pipe, which can be read or written depending on whether mode is ‘r’ (default) or ‘w’. </p>
</blockquote>
<p>main.py 建立了 pipe ，但是 main.py 却又提前退出中断了pipe，当 <code>python slave.py</code>运行完之后想要向这个 pipe 的缓冲里面写入时，就会报出<code>BrokenPipeError</code>。<br>修改 main.py 让主进程等待子进程返回，从而允许<code>python slave.py</code>运行完之后向 pipe 的缓冲写入。<br>main.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line">print(&quot;Entering into main.py&quot;)</div><div class="line">ofp = os.popen(python slave.py&quot;)</div><div class="line">print(ofp.readlines())</div><div class="line">print(&quot;Exiting from main.py&quot;)</div></pre></td></tr></table></figure></p>
<p><code>python main.py</code>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Entering into main.py</div><div class="line">等待了大约10秒钟...</div><div class="line">[&apos;Entering into slave.py\n&apos;, &apos;Exiting from slave.py\n&apos;]</div><div class="line">Exiting from main.py</div></pre></td></tr></table></figure></p>
<p>这次在退出主进程 main.py 之前等待了10秒钟，这是因为<code>print(ofp.readlines())</code>需要读取 pipe 缓冲里的内容，因此堵塞在这一行。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ol>
<li>os.system 会等待子进程的退出。</li>
<li>popen 不会等待子进程的退出，但是主进程如果提前退出会 break pipe 从而导致 BrokenPipeError。</li>
<li>另外  <code>os.system</code> 只会返回子进程 exit 的代号，popen 则会建立一个 pipe 来接收子进程的“print”，可以利用 popen 将一系列具有输入输出依赖关系的命令形成管道（命令1–&gt;命令2–&gt;命令3–&gt;）。</li>
<li>在不需要利用 pipe 形成命令管道的情况下，使用 os.system 新建一个子进程是比较合适的。 </li>
</ol>
<h4 id="最终的解决方案"><a href="#最终的解决方案" class="headerlink" title="最终的解决方案"></a>最终的解决方案</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import os</div><div class="line">import threading</div><div class="line">import time</div><div class="line">def func(begin, end):</div><div class="line">    print(&quot;Starting mall [&#123;&#125; to &#123;&#125;)&quot;.format(begin, end))</div><div class="line">    os.system(&quot;python train_horizon_cv.py &#123;&#125; &#123;&#125; &gt;&gt; log_&#123;&#125;_&#123;&#125;.txt&quot;.format(begin, end, begin, end))</div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    threadpool=[]</div><div class="line">    nos = [0, 40, 97]</div><div class="line">    for i in range(2):</div><div class="line">        th = threading.Thread(target=func,args=(nos[i], nos[i+1]))</div><div class="line">        threadpool.append(th)</div><div class="line">    for th in threadpool:</div><div class="line">        th.start()</div><div class="line">    for th in threadpool:</div><div class="line">        threading.Thread.join(th)</div></pre></td></tr></table></figure>
<p>通过两个线程去启动两个训练进程，每个线程等待其启动的训练进程，主线程等待两个子线程。<br>如果直接像下面这样把 os.system 写在一个循环里面，实际上两个训练进程仍然是串行执行的，这是由于 os.system 的等待子进程返回的性质决定的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nos = [0, 40, 97]</div><div class="line">for i in range(2):</div><div class="line">    os.system(&quot;python train_horizon_cv.py &#123;&#125; &#123;&#125; &gt;&gt; log_&#123;&#125;_&#123;&#125;.txt&quot;.format(nos[i], nos[i+1], nos[i], nos[i+1]))</div></pre></td></tr></table></figure></p>
<p><img src="http://oytnj8g2y.bkt.clouddn.com/multithread2.png" alt="multithread2"></p>
</section>
    <!-- Tags START -->
    
    <!-- Tags END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    <div class="qrcode">
      <canvas id="share-qrcode"></canvas>
      <p class="notice">扫描二维码，分享此文章</p>
    </div>
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#两者是否等待子进程退出"><span class="toc-nav-text">两者是否等待子进程退出</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#os-system"><span class="toc-nav-text">os.system</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#os-popen"><span class="toc-nav-text">os.popen</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#结论"><span class="toc-nav-text">结论</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#最终的解决方案"><span class="toc-nav-text">最终的解决方案</span></a></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2017/11/03/Python-os-system-与-os-popen-的不同/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "yanm1ng";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "Python os.system 与 os.popen 的不同",
        owner: "yanm1ng",
        repo: "yanm1ng.github.io",
        oauth: {
          client_id: "0f87e490e00ee3fd87ef",
          client_secret: "4a9d2b148e7971c2201ad12131ce8bf8159ccd2e"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2017 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>