<!DOCTYPE html>
<html lang="zh-CN">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="SimPy 基础How SimPy worksSimPy 就是一个异步事件调度器，使用者要做的就是生成事件并指定事件在什么情况下触发。事件按照优先级和仿真时间排序，拥有递增的事件id。一个事件有一个回调列表，这些回调会在事件触发时被执行。事件可以有返回值。另一个概念就是进程函数，进程函数就是一个 y">
    

    <!--Author-->
    
        <meta name="author" content="Robert Lexis">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Learning Simpy"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="This is WHY."/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

        <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>Learning Simpy - This is WHY.</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


    <!-- favicon -->
    
	
</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">This is WHY.</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/RobertLexis">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Learning Simpy</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2017-11-16
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h3 id="SimPy-基础"><a href="#SimPy-基础" class="headerlink" title="SimPy 基础"></a>SimPy 基础</h3><h4 id="How-SimPy-works"><a href="#How-SimPy-works" class="headerlink" title="How SimPy works"></a>How SimPy works</h4><p>SimPy 就是一个异步事件调度器，使用者要做的就是生成事件并指定事件在什么情况下触发。<br><strong>事件</strong>按照优先级和仿真时间排序，拥有递增的事件id。一个事件有一个回调列表，这些回调会在事件触发时被执行。事件可以有返回值。<br>另一个概念就是<strong>进程函数</strong>，进程函数就是一个 <code>yield</code> 出 <code>Event</code> 实例的 Python 生成器函数。<br><strong>环境</strong>将事件存储在事件列表中，并 keeps track of 当前的仿真时间。<br>关键流程：当一个进程函数 yield 出一个事件时，SimPy 会将进程函数加入事件的回调列表，并挂起进程函数直到事件触发。当等待事件触发的进程函数恢复执行时就会得到事件的返回值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> simpy</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">example</span><span class="params">(env)</span>:</span></div><div class="line">    event = simpy.events.Timeout(env, delay=<span class="number">1</span>, value=<span class="number">42</span>)</div><div class="line">    value = <span class="keyword">yield</span> event</div><div class="line">    print(<span class="string">'now=%d, value=%d'</span> % (env.now, value))</div><div class="line"></div><div class="line">env = simpy.Environment()</div><div class="line">example_gen = example(env)</div><div class="line">p = simpy.events.Process(env, example_gen)</div><div class="line">env.run()</div><div class="line"></div><div class="line">now=<span class="number">1</span>, value=<span class="number">42</span></div></pre></td></tr></table></figure></p>
<p>The <code>example()</code> process function above first creates a <code>Timeout</code> event. It passes the environment, a delay, and a value to it. The Timeout schedules itself at <code>now + delay</code> (that’s why the environment is required); other event types usually schedule themselves at the current simulation time.<br>（<code>Timeout</code> 事件，超时事件，这个事件的调度触发时间是 <code>now + delay</code>， 因此会 <code>now + delay</code> 时触发。其他类型的事件通常的调度触发时间是<code>current simulation time</code>，即当环境运行到此处时即刻触发。）<br>Starting a process function involves two things:</p>
<ol>
<li>You have to call the process function to create a generator object. (This will not execute any code of that function yet.)</li>
<li>You then create an instance of Process and pass the environment and the generator object to it. This will schedule an Initialize event at the current simulation time which starts the execution of the process function. The process instance is also an event that is triggered when the process function returns.<br>进程的实例化会调度一个 <code>Initialize</code> 事件，这个事件的调度触发时间是 <code>current simulation time</code>，因此会在环境运行到此处时即刻触发。进程也是一个事件，会在进程函数返回时触发。<br>“Best practice” version of the example above<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> simpy</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">example</span><span class="params">(env)</span>:</span></div><div class="line">    value = <span class="keyword">yield</span> env.timeout(<span class="number">1</span>, value=<span class="number">42</span>)</div><div class="line">    print(<span class="string">'now=%d, value=%d'</span> % (env.now, value))</div><div class="line"></div><div class="line">env = simpy.Environment()</div><div class="line">p = env.process(example(env))</div><div class="line">env.run()</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><ol>
<li><p>仿真控制<br> SimPy 的仿真控制十分的灵活，可以运行仿真直到事件列表为空、直到某个仿真时间、直到某个事件触发，也可以逐个事件运行仿真。</p>
<p> <code>env.run()</code> 会运行仿真直到事件列表为空。</p>
<blockquote>
<p>If your processes run forever (<code>while True: yield env.timeout(1)</code>), this method will never terminate (unless you kill your script by e.g., pressing <code>Ctrl-C</code>).</p>
</blockquote>
<p> <code>env.run(until=10)</code> 仿真会在内部时钟到达 10 时停止，但是不会处理 time 10 的事件。<br> If you want to integrate your simulation in a GUI and want to draw a process bar, you can repeatedly call this function with increasing until values and update your progress bar after each call:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for i in range(100):</div><div class="line">    env.run(until=i)</div><div class="line">    progressbar.update(i)</div></pre></td></tr></table></figure>
<p> <code>env.run(event)</code> or <code>env.run(process)</code> 会运行仿真直到事件触发（进程函数返回）。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import simpy</div><div class="line">def my_proc(env):</div><div class="line">    yield env.timeout(1)</div><div class="line">    return &apos;Monty Python’s Flying Circus&apos;</div><div class="line">env = simpy.Environment()</div><div class="line">proc = env.process(my_proc(env))</div><div class="line">print(env.run(until=proc))</div></pre></td></tr></table></figure>
<p> <code>peek()</code> returns the time of the next scheduled event or infinity (<code>float(&#39;inf&#39;)</code>) if no future events are scheduled.</p>
<p> <code>step()</code> processes the next scheduled event. It raises an <code>EmptySchedule</code> exception if no event is available.</p>
<p> In a typical use case, you use these methods in a loop like:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">until = 10</div><div class="line">while env.peek() &lt; until:</div><div class="line">   env.step()</div></pre></td></tr></table></figure>
</li>
<li><p>状态访问<br> <code>Environment.now</code> 可以获得仿真时间，仿真时间是没有单位的，并且只会通过 <code>Timeout</code> 事件增加。<br> <code>Environment.active_process</code> is comparable to <code>os.getpid()</code> and is either <code>None</code> or pointing at the currently active <code>Process</code>. A process is active when its process function is being executed. <strong>It becomes inactive (or suspended) when it yields an event.</strong><br> Thus, it only makes sense to access this property from within a process function or a function that is called by your process function:<br> 如果不是这样的话，在进程函数外（即执行流在进程函数外）时，访问到的<code>Environment.active_process</code>肯定是 <code>None</code>。被进程函数调用的函数可以通过这个属性获得调用者（进程）的信息。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">import simpy</div><div class="line">def subfunc(env):</div><div class="line">    print(env.active_process)  # will print &quot;p1&quot;</div><div class="line"></div><div class="line">def my_proc(env):</div><div class="line">    while True:</div><div class="line">        print(env.active_process)  # will print &quot;p1&quot;</div><div class="line">        subfunc(env)</div><div class="line">        yield env.timeout(1)</div><div class="line"></div><div class="line">env = simpy.Environment()</div><div class="line">p1 = env.process(my_proc(env))</div><div class="line">print(env.active_process)  # None</div><div class="line">env.step()</div><div class="line">print(env.active_process)  # None</div><div class="line"></div><div class="line">None</div><div class="line">&lt;Process(my_proc) object at 0x183956c9278&gt;</div><div class="line">&lt;Process(my_proc) object at 0x183956c9278&gt;</div><div class="line">None</div></pre></td></tr></table></figure>
<p> An exemplary use case for this is the resource system: If a process function calls request() to request a resource, the resource determines the requesting process via env.active_process. </p>
</li>
<li><p>事件的创建<br> 创建事件 normally 需要导入 <code>simpy.events</code>，实例化一个事件类，并传入一个对环境的引用。SimPy 也提供了一下快捷方式，例如 <code>env.event()</code> 等效于<code>simpy.events.Event(env)</code>。其他的快捷方式还有:</p>
<ol>
<li>env.process()</li>
<li>env.timeout()</li>
<li>env.all_of()</li>
<li>env.any_of()</li>
</ol>
</li>
<li><p>Miscellaneous<br> 自从 Python 3.3 ，一个生成器函数可以有一个返回值。<br> 在 SimPy 中，一个进程通过这种方式提供可以被其他进程使用的返回值。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def my_proc(env):</div><div class="line">    yield env.timeout(1)</div><div class="line">    return 42</div><div class="line">def other_proc(env):</div><div class="line">    ret_val = yield env.process(my_proc(env))</div><div class="line">    assert ret_val == 42</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>SimPy 的内建事件层次：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">events.Event</div><div class="line">|</div><div class="line">+— events.Timeout</div><div class="line">|</div><div class="line">+— events.Initialize</div><div class="line">|</div><div class="line">+— events.Process</div><div class="line">|</div><div class="line">+— events.Condition</div><div class="line">|  |</div><div class="line">|  +— events.AllOf</div><div class="line">|  |</div><div class="line">|  +— events.AnyOf</div><div class="line">.</div><div class="line">.</div><div class="line">.</div></pre></td></tr></table></figure></p>
<p>资源定义了额外的事件。这一部分的内容主要聚焦在 <code>simpy.events</code>模块中的事件。</p>
<ol>
<li><p>事件基础<br> SimPy 的事件和 deferreds、futures 或者 promises 十分类似。一个事件会处于下面状态中的一个：</p>
<ul>
<li>might happen (not triggered),</li>
<li>is going to happen (triggered) or</li>
<li><p>has happened (processed).</p>
<p>事件会逐一按序经历上面的状态，事件和时间紧密结合，时间引起事件状态的更新。<br>初始的时候，事件没有被触发，它们仅仅是内存中的对象。<br>当一个事件触发，事件就会被调度 insert into SimPy 的事件队列，事件的 <code>triggered</code> 属性变为 <code>True</code>。<br>As long as the event is not processed, you can add callbacks to an event. <strong>Callbacks are callables that accept an event as parameter and are stored in the Event.callbacks list</strong>.<br>An event becomes processed when SimPy pops it from the event queue and calls all of its callbacks. It is now no longer possible to add callbacks. The property Event.processed becomes True.<br>Events also have a value. The value can be set before or when the event is triggered and can be retrieved via Event.value or, within a process, by yielding the event (value = yield event).<br>事件被调度，事件就会触发，就会加入事件队列，<code>triggered</code> 属性就会变为 <code>True</code>。<br>事件未被调度，事件就没有触发，就不会加入事件队列，<code>triggered</code> 属性就仍为 <code>False</code>。<br>一旦事件被加入队列，队列中的事件之间就会<strong>无时差地逐一处理</strong>，即处理队列中的事件并不会增加仿真时钟。像 Timeout(env, delay=10) 是在 env.now + delay 时才被加入事件队列的，之后就没有超时/定时一说了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> simpy</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_callback</span><span class="params">(event)</span>:</span></div><div class="line">    print(<span class="string">'Called back from'</span>, event)</div><div class="line"></div><div class="line">env = simpy.Environment()</div><div class="line">event = env.event()</div><div class="line">event.callbacks.append(my_callback)</div><div class="line">print(event.triggered)</div><div class="line">print(event.processed)</div><div class="line">env.run(event)</div></pre></td></tr></table></figure>
<p>上面的代码会抛出运行时错误<code>RuntimeError: No scheduled events left but &quot;until&quot; event was not triggered: &lt;Event() object at 0x18e07e36c18&gt;</code>这是因为<code>env.event()</code>也就是<code>simpy.events.Event(env)</code>并不会调度自身，事件队列为空，因此会报错，env.timeout(1) 就会在 now + 1 时调度自身，把自己加入事件列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> simpy</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_callback</span><span class="params">(event)</span>:</span></div><div class="line">    print(<span class="string">'Called back from'</span>, event)</div><div class="line"></div><div class="line">env = simpy.Environment()</div><div class="line"><span class="comment"># event = env.event()</span></div><div class="line">event = env.timeout(<span class="number">1</span>)</div><div class="line">event.callbacks.append(my_callback)</div><div class="line">print(event.triggered)</div><div class="line">print(event.processed)</div><div class="line">env.run(event)</div><div class="line">print(event.triggered)</div><div class="line">print(event.processed)</div><div class="line"></div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="keyword">False</span></div><div class="line">Called back <span class="keyword">from</span> &lt;Timeout(<span class="number">1</span>) object at <span class="number">0x23708a514a8</span>&gt;</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Adding callbacks to an event<br> The most common way to add a callback to an event is yielding it from your process function (yield event). This will add the process’ _resume() method as a callback. That’s how your process gets resumed when it yielded an event.<br> However, you can add any callable object (function) to the list of callbacks as long as it accepts an event instance as its <strong>single</strong> parameter。<br> If an event has been processed, all of its Event.callbacks have been executed and the attribute is set to None. This is to prevent you from adding more callbacks。<br> Processes are smart about this, though. If you yield a processed event, _resume() will immediately resume your process with the value of the event (because there is nothing to wait for).也就是 _resume() 方法加不进事件的回调列表了。 </p>
</li>
<li><p>Triggering events</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">import simpy</div><div class="line">class School:</div><div class="line">    def __init__(self, env):</div><div class="line">        self.env = env</div><div class="line">        print(&quot;1: &quot;, self.env._queue)</div><div class="line">        self.class_ends = env.event()</div><div class="line">        print(&quot;2: &quot;, self.env._queue)</div><div class="line">        self.pupil_procs = [env.process(self.pupil()) for i in range(3)]</div><div class="line">        print(&quot;3: &quot;, self.env._queue)</div><div class="line">        self.bell_proc = env.process(self.bell())</div><div class="line">        print(&quot;4: &quot;, self.env._queue)</div><div class="line"></div><div class="line">    def bell(self):</div><div class="line">        for i in range(2):</div><div class="line">            print(&quot;5: &quot;, i, self.env._queue)</div><div class="line">            yield self.env.timeout(45)</div><div class="line">            print(&quot;6: &quot;, i, self.env._queue)</div><div class="line">            self.class_ends.succeed()</div><div class="line">            print(&quot;7: &quot;, i, self.env._queue)</div><div class="line">            self.class_ends = self.env.event()</div><div class="line">            print(&quot;8: &quot;, i, self.env._queue)</div><div class="line">            print(&quot;bell is ringing...&quot;)</div><div class="line"></div><div class="line">    def pupil(self):</div><div class="line">        for i in range(2):</div><div class="line">            print(&apos;ZaZa...ZaZa...&apos;, end=&apos;&apos;)</div><div class="line">            print(&quot;9: &quot;, i, self.env._queue)</div><div class="line">            yield self.class_ends</div><div class="line">            print(&quot;10: &quot;, i, self.env._queue)</div><div class="line"></div><div class="line">env = simpy.Environment()</div><div class="line">school = School(env)</div><div class="line">print(&quot;Before runing...&quot;, env._queue, &quot;\n&quot;)</div><div class="line">env.run()</div><div class="line">print(&quot;After runing...&quot;, env._queue)</div></pre></td></tr></table></figure>
<p> 输出结果如下，逐一分析就可以看出，只有在有 yield 时才会发生执行流在协程之间的切换，env.event() 只有在显式地调用<code>.succeed()</code>方法时<strong>才会被调度，从而触发，加入事件队列。</strong></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">1:  []</div><div class="line">2:  []</div><div class="line">3:  [(0, 0, 0, &lt;Initialize() object at 0x1b74a129a58&gt;), (0, 0, 1, &lt;Initialize() object at 0x1b74a163e10&gt;), (0, 0, 2, &lt;Initialize() object at 0x1b74a170240&gt;)]</div><div class="line">4:  [(0, 0, 0, &lt;Initialize() object at 0x1b74a129a58&gt;), (0, 0, 1, &lt;Initialize() object at 0x1b74a163e10&gt;), (0, 0, 2, &lt;Initialize() object at 0x1b74a170240&gt;), (0, 0, 3, &lt;Initialize() object at 0x1b74a1706a0&gt;)]</div><div class="line"></div><div class="line">Before runing... [(0, 0, 0, &lt;Initialize() object at 0x1b74a129a58&gt;), (0, 0, 1, &lt;Initialize() object at 0x1b74a163e10&gt;), (0, 0, 2, &lt;Initialize() object at 0x1b74a170240&gt;), (0, 0, 3, &lt;Initialize() object at 0x1b74a1706a0&gt;)] </div><div class="line"></div><div class="line">ZaZa...ZaZa...9:  0 [(0, 0, 1, &lt;Initialize() object at 0x1b74a163e10&gt;), (0, 0, 3, &lt;Initialize() object at 0x1b74a1706a0&gt;), (0, 0, 2, &lt;Initialize() object at 0x1b74a170240&gt;)]</div><div class="line">ZaZa...ZaZa...9:  0 [(0, 0, 2, &lt;Initialize() object at 0x1b74a170240&gt;), (0, 0, 3, &lt;Initialize() object at 0x1b74a1706a0&gt;)]</div><div class="line">ZaZa...ZaZa...9:  0 [(0, 0, 3, &lt;Initialize() object at 0x1b74a1706a0&gt;)]</div><div class="line">5:  0 []</div><div class="line">6:  0 []</div><div class="line">7:  0 [(45, 1, 5, &lt;Event() object at 0x1b74a129f98&gt;)]</div><div class="line">8:  0 [(45, 1, 5, &lt;Event() object at 0x1b74a129f98&gt;)]</div><div class="line">bell is ringing...</div><div class="line">5:  1 [(45, 1, 5, &lt;Event() object at 0x1b74a129f98&gt;)]</div><div class="line">10:  0 [(90, 1, 6, &lt;Timeout(45) object at 0x1b74a1706d8&gt;)]</div><div class="line">ZaZa...ZaZa...9:  1 [(90, 1, 6, &lt;Timeout(45) object at 0x1b74a1706d8&gt;)]</div><div class="line">10:  0 [(90, 1, 6, &lt;Timeout(45) object at 0x1b74a1706d8&gt;)]</div><div class="line">ZaZa...ZaZa...9:  1 [(90, 1, 6, &lt;Timeout(45) object at 0x1b74a1706d8&gt;)]</div><div class="line">10:  0 [(90, 1, 6, &lt;Timeout(45) object at 0x1b74a1706d8&gt;)]</div><div class="line">ZaZa...ZaZa...9:  1 [(90, 1, 6, &lt;Timeout(45) object at 0x1b74a1706d8&gt;)]</div><div class="line">6:  1 []</div><div class="line">7:  1 [(90, 1, 7, &lt;Event() object at 0x1b74a1706a0&gt;)]</div><div class="line">8:  1 [(90, 1, 7, &lt;Event() object at 0x1b74a1706a0&gt;)]</div><div class="line">bell is ringing...</div><div class="line">10:  1 [(90, 1, 8, &lt;Process(bell) object at 0x1b74a170668&gt;)]</div><div class="line">10:  1 [(90, 1, 8, &lt;Process(bell) object at 0x1b74a170668&gt;), (90, 1, 9, &lt;Process(pupil) object at 0x1b74a129fd0&gt;)]</div><div class="line">10:  1 [(90, 1, 8, &lt;Process(bell) object at 0x1b74a170668&gt;), (90, 1, 9, &lt;Process(pupil) object at 0x1b74a129fd0&gt;), (90, 1, 10, &lt;Process(pupil) object at 0x1b74a163b00&gt;)]</div><div class="line">After runing... []</div><div class="line">[Finished in 0.2s]</div></pre></td></tr></table></figure>
<p> 上面的倒数第二条打印可以看到只有两个 Process(pupil) 对象，这是为什么呢？这是因为我们有三个 pupil 进程，进程只有结束时才会在事件队列中加入一个结束事件，也就是说这里的两个 Process(pupil) 是由第三个进程打印的前两个进程，由于第三个进程并没有结束，因此尚未将自己的结束事件加入事件列表。</p>
</li>
<li><p>Let time pass by: the Timeout<br> To <strong>actually</strong> let time pass in a simulation, there is the timeout event. A timeout has two parameters: a delay and an optional value: Timeout(delay, value=None). It triggers itself during its creation and schedules itself at now + delay. Thus, the succeed() and fail() methods cannot be called again.</p>
</li>
<li><p>Processes are events, too<br> SimPy processes (as created by Process or env.process()) have the nice property of being events, too.<br> That means, that a process can yield another process. 将第一个进程的 _resume() 方法加入第二个进程（作为事件）的回调列表。<br> It will then be resumed when the other process ends. The event’s value will be the return value of that process:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">import simpy</div><div class="line"></div><div class="line">def sub(env):</div><div class="line">    print(&quot;sub 1: &quot;, env.active_process.__repr__())</div><div class="line">    print(&quot;sub 1: &quot;, env.active_process.triggered)</div><div class="line">    print(&quot;sub 1: &quot;, env.active_process.processed)</div><div class="line">    print(&quot;sub 1: &quot;, env._queue)</div><div class="line">    yield env.timeout(1)</div><div class="line">    print(&quot;sub 2: &quot;, env.active_process.triggered)</div><div class="line">    print(&quot;sub 2: &quot;, env.active_process.processed)</div><div class="line">    print(&quot;sub 2: &quot;, env._queue)</div><div class="line">    return 23</div><div class="line">def parent(env):</div><div class="line">    print(&quot;parent 1: &quot;, env.active_process.__repr__())</div><div class="line">    print(&quot;parent 1: &quot;, env.active_process.triggered)</div><div class="line">    print(&quot;parent 1: &quot;, env.active_process.processed)</div><div class="line">    print(&quot;parent 1: &quot;, env._queue)</div><div class="line">    sp = env.process(sub(env))</div><div class="line">    print(&quot;parent 2: &quot;, env._queue)</div><div class="line">    ret = yield sp</div><div class="line">    print(&quot;parent 3: &quot;, env._queue)</div><div class="line">    print(&quot;parent 2: &quot;, env.active_process.processed)</div><div class="line">    print(&quot;parent 2: &quot;, env.active_process.processed)</div><div class="line">    return ret</div><div class="line">env = simpy.Environment()</div><div class="line">pp = env.process(parent(env))</div><div class="line">print(&quot;main: &quot;, env._queue)</div><div class="line">print(env.run(pp))</div><div class="line">print(pp.triggered)</div><div class="line">print(pp.processed)</div><div class="line"></div><div class="line">main:  [(0, 0, 0, &lt;Initialize() object at 0x2b6ea6f98d0&gt;)]</div><div class="line">parent 1:  &lt;Process(parent) object at 0x2b6ea6f9898&gt;</div><div class="line">parent 1:  False</div><div class="line">parent 1:  False</div><div class="line">parent 1:  []</div><div class="line">parent 2:  [(0, 0, 1, &lt;Initialize() object at 0x2b6ea7339e8&gt;)]</div><div class="line">sub 1:  &lt;Process(sub) object at 0x2b6ea6f9e10&gt;</div><div class="line">sub 1:  False</div><div class="line">sub 1:  False</div><div class="line">sub 1:  []</div><div class="line">sub 2:  False</div><div class="line">sub 2:  False</div><div class="line">sub 2:  []</div><div class="line">parent 3:  []</div><div class="line">parent 2:  False</div><div class="line">parent 2:  False</div><div class="line">23</div><div class="line">True</div><div class="line">True</div><div class="line">[Finished in 0.2s]</div></pre></td></tr></table></figure>
<p> <code>env.active_process.triggered</code> 和 <code>env.active_process.processed</code> 为什么总是返回 <code>False</code>, 从 <code>parent 1:  &lt;Process(parent) object at 0x2b6ea6f9898&gt;</code> 和 <code>sub 1:  &lt;Process(sub) object at 0x2b6ea6f9e10&gt;</code> 就可以看出来了，进程的 <code>triggered</code> 和 <code>processed</code> 只有在进程函数返回时才会被置为 <code>True</code>，因为进程作为事件标识的是结束事件。<br> The example above will only work in Python &gt;= 3.3. As a workaround for older Python versions, you can use env.exit(23) with the same effect.</p>
<p> When a process is created, it schedules an Initialize event which will start the execution of the process when triggered. You usually won’t have to deal with this type of event.</p>
<p> If you don’t want a process to start immediately but after a certain delay, you can use simpy.util.start_delayed(). This method returns a helper <strong>process</strong> that uses a timeout before actually starting a process.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import simpy</div><div class="line">env = simpy.Environment()</div><div class="line">from simpy.util import start_delayed</div><div class="line">def sub(env):</div><div class="line">    yield env.timeout(1)</div><div class="line">    return 23</div><div class="line">def parent(env):</div><div class="line">    start = env.now</div><div class="line">    sub_proc = yield start_delayed(env, sub(env), delay=3)</div><div class="line">    assert env.now - start == 3</div><div class="line">    ret = yield sub_proc</div><div class="line">    return ret</div><div class="line">print(env.run(env.process(parent(env))))</div></pre></td></tr></table></figure>
</li>
<li><p>Waiting for multiple events at once</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">import simpy</div><div class="line">env = simpy.Environment()</div><div class="line">def test_condition(env):</div><div class="line">    t1, t2 = env.timeout(1, value=&apos;spam&apos;), env.timeout(2, value=&apos;eggs&apos;)</div><div class="line">    ret = yield t1 | t2</div><div class="line">    assert ret == &#123;t1: &apos;spam&apos;&#125;</div><div class="line">    t1, t2 = env.timeout(1, value=&apos;spam&apos;), env.timeout(2, value=&apos;eggs&apos;)</div><div class="line">    ret = yield t1 &amp; t2</div><div class="line">    assert ret == &#123;t1: &apos;spam&apos;, t2: &apos;eggs&apos;&#125;</div><div class="line">    # You can also concatenate &amp; and |</div><div class="line">    e1, e2, e3 = [env.timeout(i) for i in range(3)]</div><div class="line">    yield (e1 | e2) &amp; e3</div><div class="line">    assert all(e.processed for e in [e1, e2, e3])</div><div class="line"></div><div class="line">proc = env.process(test_condition(env))</div><div class="line">print(env._queue[0][-1].triggered)</div><div class="line">print(env._queue[0][-1].processed)</div><div class="line">print(proc.triggered)</div><div class="line">print(proc.processed)</div><div class="line">print(env.run())</div><div class="line"></div><div class="line">True</div><div class="line">False</div><div class="line">False</div><div class="line">False</div><div class="line">None</div><div class="line">[Finished in 0.2s]</div></pre></td></tr></table></figure>
</li>
</ol>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/RobertLexis" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2017 Robert Lexis<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>