<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="如何停止/杀死一个线程？如何安全地从一个线程传入传出数据？下面是一个 worker 线程实现的例子，可以给它任务，这里的每一个任务就是一个目录名，它就会进行工作，这里的工作就是罗列出给定目录及其子目录下的文件名。">
    

    <!--Author-->
    
        <meta name="author" content="Robert Lexis">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Python threads: communication and stopping"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="This is Robert Lexis."/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>Python threads: communication and stopping - This is Robert Lexis.</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
    </div>
</header>

        <section class="main">
            
<div class="post">

    <div class="post-header">
        <h1 class="title">
            <a href="/2017/11/05/Python-threads-communication-and-stopping/">
                Python threads: communication and stopping
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2017-11-05</span>
            
            
            
        </div>
    </div>

    <div class="content">

        <!-- Gallery -->
        

        <!-- Post Content -->
        <h4 id="如何停止-杀死一个线程？如何安全地从一个线程传入传出数据？"><a href="#如何停止-杀死一个线程？如何安全地从一个线程传入传出数据？" class="headerlink" title="如何停止/杀死一个线程？如何安全地从一个线程传入传出数据？"></a>如何停止/杀死一个线程？如何安全地从一个线程传入传出数据？</h4><p>下面是一个 worker 线程实现的例子，可以给它任务，这里的每一个任务就是一个目录名，它就会进行工作，这里的工作就是罗列出给定目录及其子目录下的文件名。<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">import os, time</div><div class="line">import threading, Queue</div><div class="line">class WorkerThread(threading.Thread):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    A worker thread that takes directory names from a queue, finds all files in them </div><div class="line">    recursively and reports the result. </div><div class="line">    </div><div class="line">    Input is done by placing directory names (as strings) into the Queue passed in dir_q. </div><div class="line">    </div><div class="line">    Output is done by placing tuples into the Queue passed in result_q. Each tuple </div><div class="line">    is (thread name, dirname, [list of files]). </div><div class="line">    </div><div class="line">    Ask the thread to stop by calling its join() method. </div><div class="line">    &quot;&quot;&quot;</div><div class="line">    </div><div class="line">    def __init__(self, dir_q, result_q):</div><div class="line">        super(WorkerThread, self).__init__()</div><div class="line">        self.dir_q = dir_q</div><div class="line">        self.result_q = result_q</div><div class="line">        self.stoprequest = threading.Event()</div><div class="line">    </div><div class="line">    def run(self):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        As long as we weren&apos;t asked to stop, try to take new tasks from the queue. </div><div class="line">        The tasks are taken with a blocking &apos;get&apos;, so no CPU cycles are wasted </div><div class="line">        while waiting. Also, &apos;get&apos; is given a timeout, so stoprequest is always </div><div class="line">        checked, even if there&apos;s nothing in the queue. </div><div class="line">        &quot;&quot;&quot;</div><div class="line">        while not self.stoprequest.isSet():</div><div class="line">            try:</div><div class="line">                dirname = self.dir_q.get(True, 0.05)</div><div class="line">                filenames = list(self._files_in_dir(dirname))</div><div class="line">                self.result_q.put((self.name, dirname, filenames))</div><div class="line">            except Queue.Empty:</div><div class="line">                continue</div><div class="line"></div><div class="line">    def join(self, timeout=None):</div><div class="line">        self.stoprequest.set()</div><div class="line">        super(WorkerThread, self).join(timeout)</div><div class="line"></div><div class="line"></div><div class="line">    def _files_in_dir(self, dirname):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        Given a directory name, yields the names of all files (not dirs) </div><div class="line">        contained in this directory and its sub-directories.</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        for path, dirs, files in os.walk(dirname):</div><div class="line">            for file in files:</div><div class="line">                yield os.path.join(path, file)</div></pre></td></tr></table></figure>
<p>下面让我们依次谈一下如何解决上面提及到的两个问题：</p>
<ol>
<li>首先是杀死一个线程，这是通过礼貌地请求线程停止完成的。线程的 <code>join</code> 方法被重写了，在调用父类的 <code>join</code> 之前，首先设置了 <code>self.stoprequest</code> 属性，它是一个线程事件 <code>threading.Event</code>，在线程 <code>run</code> 方法中的主循环中会检查这个 flag，如果这个 flag 被设置了就退出循环。可以把这个 <code>threading.Event</code> 当作一个同步的布尔型 flag 。记住 <code>join</code> 方法是在主线程的上下文中被调用的，而 <code>run</code> 方法的函数体是在 worker 线程的上下文中执行的。</li>
<li>第二点，从一个线程传入传出数据。最佳实践就是使用 Python Queue 包中的 Queue 对象（在 Python 3 中这个包名是 queue）。当 worker 线程被创建时，输入一个输入队列的引用和一个输出队列的引用。队列对象可以在任意数量的线程间安全地共享，并且提供了一个同步的 FIFO 队列接口。这里的同步要注意和异步区分，异步比如 JS 的 promise 机制。</li>
</ol>
<p>代码中最重要的几行是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">while not self.stoprequest.isSet():</div><div class="line">    try:</div><div class="line">        dirname = self.dir_q.get(True, 0.05)</div><div class="line">        filenames = list(self._files_in_dir(dirname))</div><div class="line">        self.result_q.put((self.name, dirname, filenames))</div><div class="line">    except Queue.Empty:</div><div class="line">        continue</div></pre></td></tr></table></figure></p>
<p>除非我们要求它停止，线程不会停止，即使队列中并没有任务可做了。<br><code>Queue.get</code> 是这样使用的，它的 <code>blocking</code> 参数被设置为 <code>true</code>，因此它会堵塞 worker 线程直到在队列中有了新的任务或者 <code>timeout</code> 过期。<code>timeout</code> 被设置为 0.05s，意味着 <code>get</code> 堵塞 worker 线程最多 0.05s，如果在这段时间内，队列中还没有任务，就会抛出 <code>Queue.Empty</code> 异常。这里可以看出，<code>while not self.stoprequest.isSet()</code> 这条判断当队列中没有任务时，被检查的频率是 0.05s 一次。如果队列中有任务，那么被检查的频率就是任务执行时间，或长于或短于 0.05s。<br>在这里既能够不耗费 CPU 指令周期地等待队列，又能周期性地检查 <code>stoprequest</code> 事件（<code>get</code> 使用特定于操作系统的底层技术来实现不耗费 CPU 指令周期的等待）。这里有一个问题就是，如果 work 需要花费大量的时间，那么下一次对于 <code>stoprequest</code> 的检查就会被相应地推后。如果这一点对你的应用很敏感，可以考虑将长时 work 切成几块，在每一块完成之后对 <code>stoprequest</code> 进行检查。<br>下面是一个使用上面定义的 worker 线程的例子，创建了一个有 4 个线程的线程池，启动每个 work 并等待所有的结果被返回。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">def main(args):</div><div class="line">    # Create a single input and a single output queue for all threads.</div><div class="line">    dir_q = Queue.Queue()</div><div class="line">    result_q = Queue.Queue()</div><div class="line">    # Create the &quot;thread pool&quot;</div><div class="line">    pool = [WorkerThread(dir_q=dir_q, result_q=result_q) for i in range(4)]</div><div class="line">    # Start all threads</div><div class="line">    for thread in pool:</div><div class="line">        thread.start()</div><div class="line">    # Give the workers some work to do</div><div class="line">    work_count = 0</div><div class="line">    for dir in args:</div><div class="line">        if os.path.exists(dir):</div><div class="line">            work_count += 1</div><div class="line">            dir_q.put(dir)</div><div class="line">            print &apos;Assigned %s dirs to workers&apos; % work_count</div><div class="line">    # Now get all the results</div><div class="line">    while work_count &gt; 0:</div><div class="line">        # Blocking &apos;get&apos; from a Queue.</div><div class="line">        result = result_q.get()</div><div class="line">        print &apos;From thread %s: %s files found in dir %s&apos; \</div><div class="line">            % ( result[0], len(result[2]), result[1])</div><div class="line">        work_count -= 1</div><div class="line">    # Ask threads to die and wait for them to do it</div><div class="line">    # the threads will nerver die unless we ask them to stop</div><div class="line">    for thread in pool:</div><div class="line">        thread.join()</div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    import sys</div><div class="line">    main(sys.argv[1:])</div></pre></td></tr></table></figure></p>
<p>所有的 worker 线程共享输入和输出队列，这完全没有问题，这使得这样一个简单的线程池功能却很强大。<br>最后需要注意的一点是，在 Python 中这样的 worker 线程只有在 work 不是 CPU 密集型时才有用。上面就是一个很好的例子，罗列出文件夹和文件是一个 I/O 密集型任务。另外的比如 socket I/O，用户交互，以及任何涉及到 web 的任务（从 HTTP 或者 RPC 服务抓取数据），都是很好的应用场景。</p>
<p>CPU 密集型的任务对于 Python 线程并不太合适，这是因为 GIL（Global Interpreter Lock）。Python 并行计算应该使用多进程而不是多线程，比如可以使用 multiprocessing 模块去管理 worker 进程。</p>

    </div>

    

    

    <!-- Comments -->
    

</div>
        </section>

    </div>
</div>


</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This is Robert Lexis (FengCun Li). To see the world, things dangerous to come to, to see behind walls, to draw closer, to find each other and to feel. That is the purpose of LIFE.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2019/03/13/Move-semantic/">Move semantic</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/11/21/C-Concurrency-In-Action/">C++ Concurrency In Action</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/09/03/Optimizers/">Optimizers</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/28/Tensorflow-模型浮点数计算量和参数量统计/">TensorFlow 模型浮点数计算量和参数量统计</a>
            </li>
            
        </ul>
    </div>



            
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/RobertLexis">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:robert_lexis@163.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Robert Lexis Loves Wenny
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML'></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>